{"version":3,"sources":["serviceWorker.js","index.js","helpers/consts.js","helpers/helpers.js","reducer/settingsReducer.js","context/SettingsContext.js","MainPage/MainPageStyles.js","data/controlsPositions.js","MainPage/Display/Display.js","helpers/async/setParamsFromPath.js","MainPage/MainPage.js","App.js","data/face_offset.js","helpers/async/getModelMod.js","data/matcapList.js","helpers/FBXLoader.js","helpers/viewerHelpers.js","helpers/async/getDefaultAni.js","data/cameraPositions.js","hooks/useToggleState.js","helpers/getTextColor.js"],"names":["Boolean","window","location","hostname","match","ReactDOM","render","App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message","DRAWER_WIDTH","DRAWER_BGCOLOR","DEFAULT_MODEL_ID","DEFAULT_FACE_IDX","baseUrl","matcapDir","process","DEFAULT_ADV_ANI","WEAPON_LIST","matParamsDetails","wireframe","name","type","default","useTexture","transparent","flatShading","color","emissive","opacity","min","max","step","emissiveIntensity","specular","metalness","roughness","shininess","gradientMap","options","matcap","matcapList","map","matColorParams","matParamsEntries","Object","entries","defaultMatParams","fromEntries","needsUpdateParams","defaultLights","id","enable","intensity","position","asciiSet","defaultSettings","model","texture","eyeTexture","eyeIdx","NaN","mouthTexture","mouthIdx","weaponRight","weaponLeft","material","scene","rotateSpeed","background","initCameraPosition","lights","animation","code","timeScale","chainMaker","chain","app","sidebarContent","showSettings","showAniControl","antiAliasing","pixelRatio","viewerType","outline","size","capture","supportedCodecs","codec","format","export","binary","ascii","charSet","invert","bgColor","initKeyMap","group","key","modName","tx","et","ei","mt","mi","wr","wl","bg","cam","showAC","showOutline","AA","rot","ts","cc","commonInitKeys","aniInitKeys","initKeys","adv","dragon","ani","basic","MATERIALS","NO_LIGHT_MATERIALS","matCommonParams","matExtraParams","Basic","Toon","Lambert","Phong","Standard","Matcap","spFaceTextures","c110300_01","incompatibleModels","Set","specialBlades","commonColors","green","black","grey","white","CAM_PARAMS","angle","far","near","aniModList","defaultValue","r","videoCodecs","capitalize","first","rest","toUpperCase","join","getDateTimeString","date","Date","dateStr","toDateString","replace","timeStr","toLocaleTimeString","getDefaultTexture","filterObject","object","keys","filtered","filter","includes","getUpdated","prev","current","isBlade","modelId","has","startsWith","isCharaWithAni","endsWith","isDragon","getViewerType","getDefaultFace","callbackOnEach","list","callback","flat","forEach","child","generateChainCode","aniToCode","aniName","faceChanges","modCode","generateAniModCode","faceCode","generateFaceCode","modCodes","modKey","push","faceCodes","change","time","collectFilter","filterState","groupName","groupData","length","multiCondFilter","input","filterConditions","el","every","propName","listToAniButtons","handleSelect","style","maxWidth","variant","onClick","settingsReducer","state","action","value","currentValue","defaultSetting","changes","SettingsContext","createContext","DispatchContext","initSettings","SettingsProvider","props","useReducer","settings","dispatch","Provider","children","useSettings","context","useContext","undefined","Error","useDispatch","light","useStyles","makeStyles","theme","root","display","width","height","content","padding","openSidebarButton","top","left","margin","borderRadius","transition","backgroundColor","cursor","loadingMsg","zIndex","justifyContent","alignItems","fontSize","controlsPosition","c","d","w","b","e","h","o","d200017_01","d210001_01","d210002_01","d210003_01","d210004_01","d210005_01","d210020_01","d210038_01","d210039_01","d210040_01","d210041_01","d210042_01","d210048_01","d210052_01","d210054_01","d210072_01","d210076_01","d210077_01","d210078_01","d210079_01","d210081_01","d210082_01","d210087_01","d210093_01","d210094_01","d210095_01","d210102_01","d210103_01","d210104_01","d210109_01","d210111_01","d210112_01","d210113_01","d210114_01","d210115_01","d210116_01","d210117_01","d210118_01","d210123_01","d210125_01","d210126_01","d210127_01","d210128_01","d210133_01","d210146_01","d210136_01","h0010001_02","h0120201","h0110401","h0080501","h0090501","h0100301","r0070401","r0070501","r0080401","smith","AniControl","lazy","viewers","Display","viewport","toggleSetting","useCallback","onCaptureFinish","onExportFinish","modelType","defaultCameraPosition","cameraPositions","cameraPosition","n","i","isNaN","controlPosition","ModelViewer","className","getTextColor","fallback","setLoadingMsg","str2bool","str","str2xyz","split","parseFloat","str2bg","convertParamValue","xyz","float","int","parseInt","boolean","getParamsFromPath","path","reduce","output","paramText","keycode","valueParts","extractParam","filterParamsByGroup","params","setModelParams","a","modelParams","part","setModelMod","modelData","getDefaultModelMod","defaultMod","updateValue","getModelModByName","mod","setAniParams","aniParams","find","getDefaultAni","aniCode","chainCodeToList","setOtherParams","paramList","setParamsFromPath","definedGroups","delete","groups","groupSetPromise","Promise","all","Sidebar","Dock","MainPage","classes","useToggleState","sidebar","toggleSidebar","useState","initLoadDone","setInitLoadDone","innerWidth","innerHeight","setViewport","dockMode","setDockMode","dockHandle","useRef","viewerRef","currentId","updateViewportSize","clientWidth","clientHeight","updateSetings","useEffect","pathname","newViewerType","viewerChanged","viewerChangedToAdv","needResetAni","resetAni","modelMod","addEventListener","removeEventListener","CssBaseline","open","setDock","mode","ref","close","fbxSource","routeProps","textureOffsets","c110394_01","c100019_02","c100018_07","c110349_04","c100004_19","c110334_02","c100001_12","c100013_06","c100015_08","c100017_01","c110345_03","c110313_03","c100005_08","c100002_07","c100010_10","c110352_03","c110392_01","c110391_01","c100029_04","c100045_01","c110064_02","c110389_01","c110285_01","c110388_01","c110385_01","c100003_10","c110386_01","c110387_01","c100031_03","c100007_07","c110384_01","c110383_01","c110382_01","c110381_01","c110342_03","c110377_01","c110378_01","c110379_01","c110380_01","c100015_05","c100006_11","c110376_01","c110375_01","c110374_01","c110307_02","c110252_02","c110296_02","c100004_17","c110371_01","c110350_02","c110340_02","c110018_02","c110370_01","c100015_04","c110342_01","c110267_01","c110050_02","c110291_01","c110354_01","c110345_01","c110266_01","c110365_01","c110346_01","c110366_01","c110299_02","c110360_01","c110307_01","c110322_01","c110356_01","c110344_01","c110053_03","c110368_01","c110367_01","c110003_02","c110270_02","c110341_03","idxOffsets","face1","face2","face3","face4","face5","face6","face7","face8","face9","result","fbxTree","connections","sceneGraph","FBXLoader","url","onLoad","onProgress","onError","scope","this","LoaderUtils","extractUrlBase","loader","FileLoader","manager","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","buffer","parse","itemError","FBXBuffer","CORRECT","byteLength","convertArrayBufferToString","isFbxFormatBinary","BinaryParser","FBXText","text","read","offset","slice","isFbxFormatASCII","getFbxVersion","TextParser","textureLoader","TextureLoader","resourcePath","setCrossOrigin","crossOrigin","FBXTreeParser","Loader","parseConnections","images","parseImages","textures","parseTextures","materials","parseMaterials","deformers","parseDeformers","geometryMap","GeometryParser","parseScene","connectionMap","Map","Connections","rawConnection","fromID","toID","relationship","set","parents","parentRelationship","ID","get","childRelationship","blobs","Objects","videoNodes","Video","nodeID","videoNode","RelativeFilename","Filename","arrayBufferContent","Content","ArrayBuffer","base64Content","image","parseImage","filename","pop","fileName","extension","lastIndexOf","toLowerCase","getHandler","warn","array","Uint8Array","URL","createObjectURL","Blob","textureMap","textureNodes","Texture","parseTexture","textureNode","loadTexture","attrName","wrapModeU","WrapModeU","wrapModeV","WrapModeV","valueU","valueV","wrapS","RepeatWrapping","ClampToEdgeWrapping","wrapT","values","Scaling","repeat","x","y","currentPath","indexOf","FileName","materialMap","materialNodes","Material","parseMaterial","materialNode","ShadingModel","parameters","parseParameters","MeshPhongMaterial","MeshLambertMaterial","setValues","BumpFactor","bumpScale","Diffuse","Color","fromArray","DiffuseColor","DisplacementFactor","displacementScale","Emissive","EmissiveColor","EmissiveFactor","Opacity","ReflectionFactor","reflectivity","Shininess","Specular","SpecularColor","bumpMap","getTexture","aoMap","encoding","sRGBEncoding","displacementMap","emissiveMap","normalMap","envMap","mapping","EquirectangularReflectionMapping","specularMap","alphaMap","LayeredTexture","skeletons","morphTargets","DeformerNodes","Deformer","deformerNode","relationships","attrType","skeleton","parseSkeleton","geometryID","morphTarget","rawTargets","parseMorphTargets","deformerNodes","rawBones","boneNode","rawBone","indices","weights","transformLink","Matrix4","TransformLink","Indexes","Weights","bones","rawMorphTargets","morphTargetNode","rawMorphTarget","initialWeight","DeformPercent","fullWeights","FullWeights","geoID","Group","modelMap","parseModels","modelNodes","Model","modelNode","setLookAtProperties","connection","parent","add","bindSkeleton","createAmbientLight","setupMorphMaterials","traverse","node","userData","transformData","parentMatrix","matrix","parentMatrixWorld","matrixWorld","transform","generateTransform","applyMatrix4","updateWorldMatrix","animations","AnimationParser","isGroup","buildSkeleton","createCamera","createLight","createMesh","createCurve","Bone","PropertyBinding","sanitizeNodeName","getTransformData","bone","subBone","copy","cameraAttribute","attr","NodeAttribute","Object3D","CameraProjectionType","nearClippingPlane","NearPlane","farClippingPlane","FarPlane","AspectWidth","AspectHeight","aspect","fov","FieldOfView","focalLength","FocalLength","PerspectiveCamera","setFocalLength","OrthographicCamera","lightAttribute","LightType","Intensity","CastLightOnObject","distance","FarAttenuationEnd","EnableFarAttenuation","PointLight","DirectionalLight","Math","PI","InnerAngle","MathUtils","degToRad","penumbra","OuterAngle","SpotLight","CastShadows","castShadow","geometry","attributes","vertexColors","FBX_Deformer","SkinnedMesh","normalizeSkinWeights","Mesh","geo","LineBasicMaterial","linewidth","Line","inheritType","InheritType","eulerOrder","getEulerOrder","RotationOrder","translation","Lcl_Translation","preRotation","PreRotation","rotation","Lcl_Rotation","postRotation","PostRotation","scale","Lcl_Scaling","scalingOffset","ScalingOffset","scalingPivot","ScalingPivot","rotationOffset","RotationOffset","rotationPivot","RotationPivot","lookAtTarget","pos","target","lookAt","Vector3","bindMatrices","parsePoseNodes","geoConnParent","bind","Skeleton","BindPoseNode","Pose","poseNodes","PoseNode","Array","isArray","poseNode","Node","Matrix","GlobalSettings","ambientColor","AmbientColor","g","AmbientLight","isMesh","morphAttributes","setupMorphMaterial","index","uuid","matUuid","sharedMat","mat","clonedMat","clone","geoNodes","Geometry","parseGeometry","geoNode","parseMeshGeometry","parseNurbsGeometry","GeometricTranslation","GeometricRotation","GeometricScaling","genGeometry","preTransform","BufferGeometry","geoInfo","parseGeoNode","buffers","genBuffers","positionAttribute","Float32BufferAttribute","vertex","setAttribute","colors","Uint16BufferAttribute","weightsIndices","vertexWeights","normal","normalMatrix","Matrix3","getNormalMatrix","normalAttribute","applyNormalMatrix","uvs","uvBuffer","toString","mappingType","prevMaterialIndex","materialIndex","startIndex","currentIndex","addGroup","lastGroup","lastIndex","start","count","addMorphTargets","vertexPositions","Vertices","vertexIndices","PolygonVertexIndex","LayerElementColor","parseVertexColors","LayerElementMaterial","parseMaterialIndices","LayerElementNormal","parseNormals","LayerElementUV","uv","UV","parseUVs","weightTable","j","weight","polygonIndex","faceLength","displayedWeightsWarning","facePositionIndexes","faceNormals","faceColors","faceUVs","faceWeights","faceWeightIndices","vertexIndex","polygonVertexIndex","endOfFace","weightIndices","data","getData","wt","wIndex","Weight","weightIndex","currentWeight","comparedWeight","comparedWeightIndex","comparedWeightArray","tmp","genFace","parentGeo","parentGeoNode","morphTargetsRelative","rawTarget","morphGeoNode","genMorphGeometry","morphPositionsSparse","morphPositions","Float32Array","morphIndex","morphGeoInfo","morphBuffers","NormalNode","MappingInformationType","referenceType","ReferenceInformationType","Normals","indexBuffer","NormalIndex","NormalsIndex","dataSize","UVNode","UVIndex","ColorNode","Colors","ColorIndex","MaterialNode","materialIndexBuffer","Materials","materialIndices","NURBSCurve","order","Order","startKnot","endKnot","degree","knots","KnotVector","controlPoints","pointsValues","Points","l","Vector4","Form","points","getPoints","setFromPoints","animationClips","rawClips","parseClips","rawClip","clip","addClip","AnimationCurve","curveNodesMap","parseAnimationCurveNodes","parseAnimationCurves","layersMap","parseAnimationLayers","parseAnimStacks","rawCurveNodes","AnimationCurveNode","rawCurveNode","curveNode","curves","rawCurves","animationCurve","times","KeyTime","convertFBXTimeToSeconds","KeyValueFloat","animationCurveID","animationCurveRelationship","rawLayers","AnimationLayer","layerCurveNodes","z","modelID","rawModel","modelName","initialPosition","initialRotation","initialScale","morph","deformerID","morpherID","morphName","rawStacks","AnimationStack","layer","tracks","rawTracks","concat","generateTracks","AnimationClip","Quaternion","decompose","toArray","Euler","setFromQuaternion","T","positionTrack","generateVectorTrack","R","rotationTrack","generateRotationTrack","S","scaleTrack","morphTrack","generateMorphTrack","initialValue","getTimesForAllAxes","getKeyframeTrackValues","VectorKeyframeTrack","interpolateRotations","setFromEuler","quaternion","euler","quaternionValues","premultiply","multiply","QuaternionKeyframeTrack","val","morphNum","getObjectByName","morphTargetDictionary","NumberKeyframeTrack","sort","targetIndex","lastValue","prevValue","xIndex","yIndex","xValue","yValue","zValue","curve","valuesSpan","absoluteSpan","abs","numSubIntervals","nextValue","initialTime","interval","nextTime","interpolatedTimes","interpolatedValues","inject","nodeStack","currentIndent","currentProp","currentPropName","allNodes","FBXTree","line","matchComment","matchEmpty","matchBeginning","matchProperty","matchEnd","parseNodeBegin","parseNodeProperty","popStack","parseNodePropertyContinued","property","nodeName","trim","nodeAttrs","attrs","parseNodeAttr","currentNode","getCurrentNode","pushStack","contentLine","propValue","connProps","from","to","append","elem","setCurrentProp","parseNumberArray","parseNodeSpecialProperty","prop","innerPropName","innerPropType1","innerPropType2","innerPropFlag","innerPropValue","getPrevNode","type2","flag","reader","BinaryReader","skip","version","getUint32","endOfContent","parseNode","getOffset","endOffset","getUint64","numProperties","nameLen","getUint8","getString","propertyList","parseProperty","singleProperty","subNode","parseSubNode","getBoolean","getFloat64","getFloat32","getInt32","getInt64","getArrayBuffer","getInt16","arrayLength","compressedLength","getBooleanArray","getFloat64Array","getFloat32Array","getInt32Array","getInt64Array","fflate","reader2","littleEndian","dv","DataView","low","high","nullByte","decodeText","dataArray","infoObject","tempEuler","tempVec","lTranslationM","lPreRotationM","lRotationM","lPostRotationM","lScalingM","lScalingPivotM","lScalingOffsetM","lRotationOffsetM","lRotationPivotM","lParentGX","lParentLX","lGlobalT","setPosition","makeRotationFromEuler","lLRM","lParentGRM","extractRotation","lParentTM","copyPosition","lParentGRSM","lParentGSM","lLSM","lGlobalRS","lParentLSM_inv","setFromMatrixScale","lParentGSM_noLocal","lRotationPivotM_inv","lScalingPivotM_inv","lTransform","lLocalTWithAllPivotAndOffsetInfo","lGlobalTranslation","enums","a1","a2","loadModel","resolve","THREE","loadMatcap","getMatcapPath","loadSingleAni","fetch","response","json","loadAnimations","aniList","getMeshes","getOutline","meshes","unshift","getMaterial","flatMap","mesh","getModelPath","getTexturePath","analyzeWeaponCode","flipped","weaponCode","substring","modelPath","texturePath","dispose3dObject","disposedList","needToDispose","notDisposed","dispose","disposeObject","backupMap","disposeMaterial","getParamsList","matType","getDragonEye","eyes","nameRegex","test","getDragonMouth","mouths","removeEffects","visible","disableFrustumCulling","frustumCulled","createNewMaterial","materialType","changeMaterial","forced","matIsArray","checkParam","some","newMaterial","createOutline","outlines","createOutlineMaterial","outlineMaterial","skipList","word","replaceMaterial","isSkinnedMesh","bindMatrix","loadRawText","loadShaderFiles","dir","filePaths","loadShader","shaderDir","uniforms","vertexShader","fragmentShader","side","depthFunc","applyOutlineSettings","fill","calculateTextureOffset","currentTexture","prevTexture","prevOffsetX","prevOffsetY","currentOffsetX","currentOffsetY","calculateIdxOffset","currentIdx","prevIdx","applyOffset","offsetX","offsetY","targetGroup","end","u","getX","v","getY","setXY","needsUpdate","applyEyeOffset","applyMouthOffset","applyTexture","textureId","oldMaterial","applyEyeTexture","applyMouthTexture","getAniData","modifiers","modList","repetitions","faceMod","processFaceChanges","getAniModifiers","analyzeChainCode","sorted","timeStamps","nanoid","simplified","assign","getFaceChangesQueue","_","others","applyMaterialParam","param","handler","nTones","newMap","minFilter","magFilter","generateMipmaps","createGradientMap","matcapPromise","isColor","updateMatParams","prevParams","update","constructor","setValue","replaceTexture","oldTexture","newTexture","textureName","applyMod","cmd","opcode","outArgs","analyzeModelModCode","show","hide","logUpdate","oldValue","subkeys","log","JSON","stringify","subkey","getDefaultDragonAni","getDefaultEnemyAni","dragonAni","enemyAni","c100034_01","d210142_01","d210147_01","d210152_01","h0010001","h0040101","initVal","setState","toggleState","rgb","hex","exec","hexToRgb"],"mappings":"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","file":"static/js/main.c992d7ac.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import ReactDOM from \"react-dom\";\r\nimport \"styles/index.css\";\r\nimport App from \"App\";\r\nimport { BrowserRouter as Router } from \"react-router-dom\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nReactDOM.render(\r\n    <Router>\r\n        <App />\r\n    </Router>,\r\n    document.getElementById(\"root\")\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n","import matcapList from \"data/matcapList\";\r\n\r\nexport const DRAWER_WIDTH = \"16rem\";\r\nexport const DRAWER_BGCOLOR = \"#330000\";\r\n\r\nexport const DEFAULT_MODEL_ID = \"c100001_01\";\r\nexport const DEFAULT_FACE_IDX = 2;\r\nexport const DEFAULT_DRAGON_FACE_IDX = 1;\r\n\r\nexport const baseUrl = \"https://dgk3593.github.io/dl-model/#\";\r\nexport const matcapDir = `${process.env.PUBLIC_URL}/img/matcap`;\r\n\r\nexport const DEFAULT_ADV_ANI = \"CMN_MWM_03\";\r\n\r\n/**\r\n * @type {WeaponType[]}\r\n */\r\nexport const WEAPON_LIST = [\r\n    \"Sword\",\r\n    \"Blade\",\r\n    \"Dagger\",\r\n    \"Axe\",\r\n    \"Lance\",\r\n    \"Bow\",\r\n    \"Wand\",\r\n    \"Staff\",\r\n    \"Manacaster\",\r\n];\r\n\r\n/**\r\n * @type {{ [paramName: string]: MatParamDetails }}\r\n */\r\nexport const matParamsDetails = {\r\n    wireframe: {\r\n        name: \"Wireframe\",\r\n        type: \"boolean\",\r\n        default: false,\r\n    },\r\n    useTexture: {\r\n        name: \"Texture\",\r\n        type: \"boolean\",\r\n        default: true,\r\n    },\r\n    transparent: {\r\n        name: \"Transparent\",\r\n        type: \"boolean\",\r\n        default: false,\r\n    },\r\n    flatShading: {\r\n        name: \"Flat Shading\",\r\n        type: \"boolean\",\r\n        default: false,\r\n    },\r\n    color: {\r\n        name: \"Color\",\r\n        type: \"color\",\r\n        default: \"#ffffff\",\r\n    },\r\n    emissive: {\r\n        name: \"Emissive\",\r\n        type: \"color\",\r\n        default: \"#000000\",\r\n    },\r\n    opacity: {\r\n        name: \"Opacity\",\r\n        type: \"percentage\",\r\n        default: 1,\r\n        min: 0,\r\n        max: 1,\r\n        step: 0.05,\r\n    },\r\n    emissiveIntensity: {\r\n        name: \"Emissive Intensity\",\r\n        type: \"percentage\",\r\n        default: 1,\r\n        min: 0,\r\n        max: 1,\r\n        step: 0.05,\r\n    },\r\n    specular: {\r\n        name: \"Specular\",\r\n        type: \"color\",\r\n        default: \"#111111\",\r\n    },\r\n    metalness: {\r\n        name: \"Metalness\",\r\n        type: \"percentage\",\r\n        default: 0,\r\n        min: 0,\r\n        max: 1,\r\n        step: 0.05,\r\n    },\r\n    roughness: {\r\n        name: \"Roughness\",\r\n        type: \"percentage\",\r\n        default: 1,\r\n        min: 0,\r\n        max: 1,\r\n        step: 0.05,\r\n    },\r\n    shininess: {\r\n        name: \"Shininess\",\r\n        type: \"number\",\r\n        default: 30,\r\n        min: 1,\r\n        max: 100,\r\n        step: 1,\r\n    },\r\n    gradientMap: {\r\n        name: \"Gradient Map\",\r\n        type: \"select\",\r\n        default: \"none\",\r\n        options: [\"none\", \"2 Tones\", \"3 Tones\", \"4 Tones\", \"5 Tones\"],\r\n    },\r\n    matcap: {\r\n        name: \"Matcap\",\r\n        type: \"select\",\r\n        default: matcapList[0].name,\r\n        options: matcapList.map(({ name }) => name),\r\n    },\r\n};\r\n\r\n/** list of parameters that can be set directly */\r\nexport const matDirectSetParams = [\r\n    \"transparent\",\r\n    \"opacity\",\r\n    \"wireframe\",\r\n    \"emissiveIntensity\",\r\n    \"metalness\",\r\n    \"roughness\",\r\n    \"shininess\",\r\n];\r\n\r\n/** list of parameters whose value is a color code */\r\nexport const matColorParams = [\"color\", \"emissive\", \"specular\"];\r\n\r\n/**\r\n * @type { Array< [paramName: string, details: MatParamDetails] > }\r\n */\r\nconst matParamsEntries = Object.entries(matParamsDetails);\r\n\r\n/** default values of material parameters\r\n * @type {{ [paramName: string]: * }}\r\n */\r\nconst defaultMatParams = Object.fromEntries(\r\n    matParamsEntries.map(([paramName, details]) => [paramName, details.default])\r\n);\r\n\r\n/** list of parameters that need to set needsUpdate = true to be updated */\r\nexport const needsUpdateParams = [\r\n    \"gradientMap\",\r\n    \"flatShading\",\r\n    \"useTexture\",\r\n    \"matcap\",\r\n];\r\n\r\n/** default light setting\r\n * @type { Array <LightParam> }\r\n */\r\nexport const defaultLights = [\r\n    {\r\n        id: \"0\",\r\n        type: \"Ambient\",\r\n        color: \"#444444\",\r\n        enable: true,\r\n        intensity: 1,\r\n    },\r\n    {\r\n        id: \"1\",\r\n        type: \"Directional\",\r\n        color: \"#ffffff\",\r\n        enable: true,\r\n        position: [50, 0, 100],\r\n        intensity: 0.8,\r\n    },\r\n];\r\n\r\n/** ASCII sets used to create ASCII art */\r\nexport const asciiSet = [\r\n    \" .:-=+*#%@\",\r\n    \" .'`^\\\",:;Il!i~+_-?][}{1)(|/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$\",\r\n];\r\n\r\n/** used to initialize global state\r\n * @type {ApplicationState}\r\n */\r\nexport const defaultSettings = {\r\n    model: {\r\n        id: \"\",\r\n        texture: \"\",\r\n        eyeTexture: \"\",\r\n        eyeIdx: NaN,\r\n        mouthTexture: \"\",\r\n        mouthIdx: NaN,\r\n        weaponRight: \"\",\r\n        weaponLeft: \"\",\r\n    },\r\n    // @ts-ignore\r\n    material: {\r\n        type: \"Basic\",\r\n        ...defaultMatParams,\r\n    },\r\n    scene: {\r\n        rotateSpeed: 0,\r\n        background: \"#cccccc\",\r\n        initCameraPosition: null,\r\n    },\r\n    lights: defaultLights,\r\n    animation: {\r\n        code: \"\",\r\n        timeScale: 1,\r\n    },\r\n    chainMaker: { chain: null },\r\n    app: {\r\n        sidebarContent: \"settings\",\r\n        showSettings: true,\r\n        showAniControl: true,\r\n        antiAliasing: false,\r\n        pixelRatio: 1,\r\n        viewerType: \"\",\r\n    },\r\n    outline: {\r\n        enable: true,\r\n        size: 5,\r\n        color: \"#000000\",\r\n        opacity: 1,\r\n    },\r\n    capture: {\r\n        enable: false,\r\n        supportedCodecs: [],\r\n        codec: \"\",\r\n        format: \"\",\r\n    },\r\n    export: {\r\n        enable: false,\r\n        format: \"stl\",\r\n        binary: true,\r\n    },\r\n    ascii: {\r\n        enable: false,\r\n        charSet: asciiSet[1],\r\n        invert: false,\r\n        color: \"#00ff00\",\r\n        bgColor: \"#000000\",\r\n    },\r\n};\r\n\r\n/** map an init key to corresponding group and key in the global state\r\n * @type {{ [initKey: string]: {group: string, key: string, type: string} }}\r\n */\r\nexport const initKeyMap = {\r\n    id: { group: \"model\", key: \"id\", type: \"string\" },\r\n    modName: { group: \"model\", key: \"modName\", type: \"string\" },\r\n    tx: { group: \"model\", key: \"texture\", type: \"string\" },\r\n    et: { group: \"model\", key: \"eyeTexture\", type: \"string\" },\r\n    ei: { group: \"model\", key: \"eyeIdx\", type: \"int\" },\r\n    mt: { group: \"model\", key: \"mouthTexture\", type: \"string\" },\r\n    mi: { group: \"model\", key: \"mouthIdx\", type: \"int\" },\r\n    wr: { group: \"model\", key: \"weaponRight\", type: \"string\" },\r\n    wl: { group: \"model\", key: \"weaponLeft\", type: \"string\" },\r\n    bg: { group: \"scene\", key: \"background\", type: \"bg\" },\r\n    cam: { group: \"scene\", key: \"initCameraPosition\", type: \"xyz\" },\r\n    showAC: { group: \"app\", key: \"showAniControl\", type: \"boolean\" },\r\n    showSettings: { group: \"app\", key: \"showSettings\", type: \"boolean\" },\r\n    showOutline: { group: \"outline\", key: \"enable\", type: \"boolean\" },\r\n    AA: { group: \"app\", key: \"antiAliasing\", type: \"boolean\" },\r\n    rot: { group: \"scene\", key: \"rotateSpeed\", type: \"float\" },\r\n    ts: { group: \"animation\", key: \"timeScale\", type: \"float\" },\r\n    cc: { group: \"animation\", key: \"code\", type: \"string\" },\r\n};\r\n\r\nconst commonInitKeys = [\r\n    \"id\",\r\n    \"modName\",\r\n    \"bg\",\r\n    \"cam\",\r\n    \"showOutline\",\r\n    \"AA\",\r\n    \"rot\",\r\n];\r\n\r\nconst aniInitKeys = [\"ts\", \"cc\"];\r\n\r\n/** list of init keys corresponding to viewer type\r\n * @type {{ [viewerType: string]: Array<string> }}\r\n */\r\nexport const initKeys = {\r\n    adv: [\r\n        \"et\",\r\n        \"ei\",\r\n        \"mt\",\r\n        \"mi\",\r\n        \"wr\",\r\n        \"wl\",\r\n        ...commonInitKeys,\r\n        ...aniInitKeys,\r\n    ],\r\n    dragon: [\"ei\", \"mi\", ...commonInitKeys, ...aniInitKeys],\r\n    ani: [...commonInitKeys, ...aniInitKeys],\r\n    basic: [...commonInitKeys],\r\n};\r\n\r\n/** list of supported materials */\r\nexport const MATERIALS = [\r\n    \"Basic\",\r\n    \"Toon\",\r\n    \"Lambert\",\r\n    \"Phong\",\r\n    \"Standard\",\r\n    \"Matcap\",\r\n];\r\n\r\n/** list of materials not using lights */\r\nexport const NO_LIGHT_MATERIALS = [\"Basic\", \"Matcap\"];\r\n\r\n/** parameters that all material has */\r\nexport const matCommonParams = [\r\n    \"transparent\",\r\n    \"opacity\",\r\n    \"wireframe\",\r\n    \"useTexture\",\r\n    \"color\",\r\n];\r\n\r\n/** parameters specific to each type of materials\r\n * @type {{ [materialName: string]: Array<string> }}\r\n */\r\nexport const matExtraParams = {\r\n    Basic: [],\r\n    Toon: [\"emissive\", \"emissiveIntensity\", \"gradientMap\"],\r\n    Lambert: [\"emissive\", \"emissiveIntensity\"],\r\n    Phong: [\r\n        \"emissive\",\r\n        \"emissiveIntensity\",\r\n        \"specular\",\r\n        \"shininess\",\r\n        \"flatShading\",\r\n    ],\r\n    Standard: [\r\n        \"emissive\",\r\n        \"emissiveIntensity\",\r\n        \"metalness\",\r\n        \"roughness\",\r\n        \"flatShading\",\r\n    ],\r\n    Matcap: [\"flatShading\", \"matcap\"],\r\n};\r\n\r\nexport const spFaceTextures = {\r\n    c110300_01: \"ec110300_01\",\r\n};\r\n\r\n/** Set of ids of models incompatible with AdvViewer */\r\nexport const incompatibleModels = new Set([\r\n    \"c100007_01\",\r\n    \"c100007_05\",\r\n    \"c100007_09\",\r\n    \"c100034_01\",\r\n    \"c100035_01\",\r\n    \"c100036_01\",\r\n    \"c100037_01\",\r\n    \"c100041_01\",\r\n]);\r\n\r\nexport const specialBlades = new Set([\"w397004_01\"]);\r\n\r\n/**\r\n * @type {{[colorName: string]: ColorCode}}\r\n */\r\nexport const commonColors = {\r\n    green: \"#00ff00\",\r\n    black: \"#000000\",\r\n    grey: \"#cccccc\",\r\n    white: \"#ffffff\",\r\n};\r\n\r\nexport const CAM_PARAMS = {\r\n    angle: 45,\r\n    far: 100,\r\n    near: 0.01,\r\n};\r\n\r\nexport const aniModList = {\r\n    ts: { key: \"timeScale\", defaultValue: 1 },\r\n    r: { key: \"repetitions\", defaultValue: 1 },\r\n};\r\n\r\n/** list of video codecs to check for */\r\nexport const videoCodecs = [\r\n    \"video/mp4;codecs=h264\",\r\n    \"video/webm;codecs=h264\",\r\n    \"video/webm;codecs=vp9\",\r\n    \"video/webm;codecs=vp8\",\r\n    \"video/webm\",\r\n];\r\n","import Button from \"@material-ui/core/Button\";\r\n\r\nimport { aniModList, incompatibleModels, specialBlades } from \"./consts\";\r\n\r\n/** capitalize first letter of tring\r\n * @param {string} input\r\n */\r\nexport const capitalize = ([first, ...rest]) =>\r\n    `${first.toUpperCase()}${rest.join(\"\")}`;\r\n\r\n/** generate date time string */\r\nexport const getDateTimeString = () => {\r\n    const date = new Date();\r\n    const dateStr = date.toDateString().replace(/ /g, \"_\");\r\n    const timeStr = date\r\n        .toLocaleTimeString()\r\n        .replace(/:/g, \"-\")\r\n        .replace(/ /g, \"\");\r\n    return `${dateStr}_${timeStr}`;\r\n};\r\n\r\n/** get the default texture file of a model from id\r\n * @param {string} id - model id\r\n */\r\nexport const getDefaultTexture = id =>\r\n    id.match(/_[0-9]{2}/) ? id : `${id}_01`;\r\n\r\n/** create a new object whose entries with key listed in keys are copied from the input object\r\n * @param {{ }} object - object to filter\r\n * @param { string[] } keys - list of keys to filter\r\n * @return {{ }}\r\n */\r\nexport const filterObject = (object, keys) => {\r\n    const entries = Object.entries(object);\r\n    const filtered = entries.filter(([key, _]) => keys.includes(key));\r\n    return Object.fromEntries(filtered);\r\n};\r\n\r\n/** Get the difference between 2 object\r\n * @param {{ }} prev - previous value\r\n * @param {{ }} current - current value\r\n * @returns { Array<[updatedKey: string, value: *]> } array of updated key and value pairs\r\n */\r\nexport const getUpdated = (prev, current) => {\r\n    const updated = Object.entries(current).filter(\r\n        ([key, value]) => value !== prev[key]\r\n    );\r\n    return updated;\r\n};\r\n\r\n/** check if an object is empty\r\n * @param {{}} object\r\n */\r\nexport const isEmpty = object => !Object.keys(object).length;\r\n\r\n/** check if an ID is a blade\r\n * @param {string} modelId - id to check\r\n */\r\nexport const isBlade = modelId =>\r\n    specialBlades.has(modelId) || modelId.startsWith(\"w302\");\r\n\r\n/** check if an ID is a sheath\r\n * @param {string} modelId - id to check\r\n */\r\nexport const isSheath = modelId => isBlade(modelId) && modelId.endsWith(\"02\");\r\n\r\n/** check if model is compatible with AdvViewer\r\n * @param {string} modelId\r\n */\r\nexport const isCharaWithAni = modelId =>\r\n    modelId.startsWith(\"c\") &&\r\n    !modelId.endsWith(\"_h\") &&\r\n    !incompatibleModels.has(modelId);\r\n\r\n/** check if a model is a dragon\r\n * @param {string} modelId\r\n */\r\nexport const isDragon = modelId =>\r\n    modelId.startsWith(\"d\") || modelId === \"smith\";\r\n\r\n/** get the suitable viewer type base on ID\r\n * @param {string} modelId\r\n */\r\nexport const getViewerType = modelId => {\r\n    if (isDragon(modelId)) return \"dragon\";\r\n\r\n    if (modelId.startsWith(\"h\") || incompatibleModels.has(modelId))\r\n        return \"ani\";\r\n\r\n    if (isCharaWithAni(modelId)) return \"adv\";\r\n\r\n    return \"basic\";\r\n};\r\n\r\n/** get default eye and mouth index\r\n * @param {string} modelId\r\n */\r\nexport const getDefaultFace = modelId => (isDragon(modelId) ? 1 : 2);\r\n\r\n/** apply callback on each element of list or on list if list is not an array\r\n * @param {* | Array} list - list of objects to apply callback\r\n * @param {function} callback - callback to apply\r\n */\r\nexport const callbackOnEach = (list, callback) =>\r\n    [list].flat().forEach(child => callback(child));\r\n\r\n/** generate animation chain code from AnimationChain\r\n * @param {AnimationChain} chain\r\n */\r\nexport const generateChainCode = chain => {\r\n    const aniCode = chain.map(aniToCode);\r\n    return aniCode.join(\">\");\r\n};\r\n\r\n/** convert 1 animation chain item to single animation code\r\n * @param {AniListItem} ani\r\n */\r\nconst aniToCode = ani => {\r\n    const { aniName, faceChanges } = ani;\r\n    const modCode = generateAniModCode(ani);\r\n    const faceCode = generateFaceCode(faceChanges);\r\n    return `${aniName}${modCode}${faceCode}`;\r\n};\r\n\r\n/**  generate animation modifier code\r\n * @param {AniListItem} ani\r\n */\r\nconst generateAniModCode = ani => {\r\n    const modCodes = [];\r\n    Object.keys(aniModList).forEach(modKey => {\r\n        const { key, defaultValue } = aniModList[modKey];\r\n        if (ani[key] !== defaultValue) {\r\n            modCodes.push(`&${modKey}=${ani[key]}`);\r\n        }\r\n    });\r\n    return modCodes.join(\"\");\r\n};\r\n\r\n/** create face change code\r\n * @param {FaceChangeArray} faceChanges\r\n */\r\nconst generateFaceCode = faceChanges => {\r\n    if (!faceChanges) return \"\";\r\n\r\n    const faceCodes = [];\r\n    faceChanges.forEach(change => {\r\n        const { time, eyeIdx, mouthIdx } = change;\r\n        if (!time) return;\r\n\r\n        eyeIdx && faceCodes.push(`&e-${time}=${eyeIdx}`);\r\n\r\n        mouthIdx && faceCodes.push(`&m-${time}=${mouthIdx}`);\r\n    });\r\n    return faceCodes.join(\"\");\r\n};\r\n\r\n/**\r\n * @param {FilterState} filterState\r\n * @return {FilterConditions}\r\n */\r\nexport const collectFilter = filterState => {\r\n    const stateEntries = Object.entries(filterState);\r\n    /**\r\n     * @type {FilterConditions}\r\n     */\r\n    const filterConditions = stateEntries.map(([groupName, groupData]) => [\r\n        groupName,\r\n        Object.keys(groupData).filter(key => groupData[key]),\r\n    ]);\r\n    return filterConditions.filter(([, valueList]) => valueList.length);\r\n};\r\n\r\n/** Multiconditional filter\r\n * @param {ModelData[]} input\r\n * @param {FilterConditions} filterConditions\r\n */\r\nexport const multiCondFilter = (input, filterConditions) => {\r\n    return input.filter(el =>\r\n        filterConditions.every(([propName, valueList]) =>\r\n            valueList.includes(el[propName])\r\n        )\r\n    );\r\n};\r\n\r\n/** turn a list of animation data to buttons\r\n * @param {AnimationList} list\r\n * @param {*} handleSelect\r\n * @param {string} [groupName]\r\n */\r\nexport const listToAniButtons = (list, handleSelect, groupName = \"\") => {\r\n    if (!list) return;\r\n\r\n    const style = { maxWidth: \"13.5rem\" };\r\n    return list.map(({ name, code }) => (\r\n        <Button\r\n            variant=\"contained\"\r\n            key={name}\r\n            data-value={code}\r\n            data-name={`${groupName ? `${groupName} ` : \"\"}${name}`}\r\n            onClick={handleSelect}\r\n            style={style}\r\n        >\r\n            {name}\r\n        </Button>\r\n    ));\r\n};\r\n","import { defaultSettings } from \"helpers/consts\";\r\nimport { filterObject } from \"helpers/helpers\";\r\n\r\n/** reducer for settings\r\n * @param {ApplicationState} state\r\n * @param {ReducerAction} action\r\n * @return {ApplicationState} new state\r\n */\r\nexport const settingsReducer = (state, action) => {\r\n    const { type, key, value } = action;\r\n    switch (type) {\r\n        case \"toggle\":\r\n            const currentValue = state[key][value];\r\n            return {\r\n                ...state,\r\n                [key]: { ...state[key], [value]: !currentValue },\r\n            };\r\n\r\n        case \"reset\":\r\n            // value = array of keys in settings[key] to be reset, null -> reset all\r\n            const defaultSetting = defaultSettings[key];\r\n            const changes = value\r\n                ? filterObject(defaultSetting, value)\r\n                : { ...defaultSetting };\r\n\r\n            return { ...state, [key]: { ...state[key], ...changes } };\r\n\r\n        case \"update\":\r\n            // update state[key] with values from value\r\n            return { ...state, [key]: { ...state[key], ...value } };\r\n\r\n        case \"overwrite\":\r\n            return { ...state, [key]: value };\r\n\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n","import { createContext, useReducer, useContext } from \"react\";\r\nimport { settingsReducer } from \"reducer/settingsReducer\";\r\nimport { defaultSettings } from \"helpers/consts\";\r\n\r\n/**\r\n * @type {React.Context<ApplicationState>}\r\n */\r\nconst SettingsContext = createContext(null);\r\n\r\n/**\r\n * @type {React.Context< React.Dispatch<ReducerAction> >}\r\n */\r\nconst DispatchContext = createContext(null);\r\n\r\n/** used to initialize global state\r\n * @type {ApplicationState}\r\n */\r\nconst initSettings = {};\r\nObject.keys(defaultSettings).forEach(\r\n    key => (initSettings[key] = { ...defaultSettings[key] })\r\n);\r\ninitSettings.lights = defaultSettings.lights.map(light => ({\r\n    ...light,\r\n}));\r\n\r\nexport { initSettings };\r\n\r\nexport function SettingsProvider(props) {\r\n    const [settings, dispatch] = useReducer(settingsReducer, initSettings);\r\n\r\n    return (\r\n        <SettingsContext.Provider value={settings}>\r\n            <DispatchContext.Provider value={dispatch}>\r\n                {props.children}\r\n            </DispatchContext.Provider>\r\n        </SettingsContext.Provider>\r\n    );\r\n}\r\n\r\nexport function useSettings() {\r\n    const context = useContext(SettingsContext);\r\n    if (context === undefined) {\r\n        throw new Error(\"useSettings must be used within a SettingsProvider\");\r\n    }\r\n    return context;\r\n}\r\n\r\nexport function useDispatch() {\r\n    const context = useContext(DispatchContext);\r\n    if (context === undefined) {\r\n        throw new Error(\"useDispatch must be used within a DispatchProvider\");\r\n    }\r\n    return context;\r\n}\r\n","import { makeStyles } from \"@material-ui/core/styles\";\r\n\r\nconst useStyles = makeStyles(theme => ({\r\n    root: {\r\n        display: \"block\",\r\n        width: \"100vw\",\r\n        height: \"100vh\",\r\n    },\r\n    content: {\r\n        width: \"100vw\",\r\n        height: \"100vh\",\r\n        padding: 0,\r\n    },\r\n    openSidebarButton: {\r\n        position: \"absolute\",\r\n        top: 0,\r\n        left: 0,\r\n        margin: \"2rem\",\r\n        opacity: \"0.5\",\r\n        borderRadius: \"0.25rem\",\r\n        transition: \"0.5s all ease-in-out\",\r\n        backgroundColor: \"#cccccc\",\r\n        cursor: \"pointer\",\r\n        \"&:hover\": {\r\n            opacity: \"1\",\r\n        },\r\n    },\r\n    loadingMsg: {\r\n        position: \"absolute\",\r\n        zIndex: 9999,\r\n        width: \"100vw\",\r\n        height: \"100vh\",\r\n        display: \"flex\",\r\n        justifyContent: \"center\",\r\n        alignItems: \"center\",\r\n        color: \"white\",\r\n        fontSize: \"x-large\",\r\n        backgroundColor: \"rgba(0,0,0,0.5)\",\r\n    },\r\n}));\r\n\r\nexport default useStyles;\r\n","/** default control coordinates\r\n * @type {{ [key: string]: xyzCoordinate }}\r\n */\r\nexport const controlsPosition = {\r\n    c: [0, 0.5, 0],\r\n    d: [0, 1.5, 0],\r\n    w: [0, 0, 0],\r\n    b: [0, 1, 0],\r\n    e: [0, 0.5, 0],\r\n    h: [0, 1, 0],\r\n    o: [0, 0, 0],\r\n    r: [0, 3, 0],\r\n\r\n    d200017_01: [0, 1, 0],\r\n    d210001_01: [0, 1, 0],\r\n    d210002_01: [0, 1, 0],\r\n    d210003_01: [0, 1, 0],\r\n    d210004_01: [0, 1, 0],\r\n    d210005_01: [0, 1, 0],\r\n    d210020_01: [0, 2.5, 0],\r\n    d210038_01: [0, 1, 0],\r\n    d210039_01: [0, 1, 0],\r\n    d210040_01: [0, 1, 0],\r\n    d210041_01: [0, 1, 0],\r\n    d210042_01: [0, 1, 0],\r\n    d210048_01: [0, 2.5, 0],\r\n    d210052_01: [0, 2.5, 0],\r\n    d210054_01: [0, 2, 0],\r\n    d210072_01: [0, 1, 0],\r\n    d210076_01: [0, 2.5, 0],\r\n    d210077_01: [0, 2.5, 0],\r\n    d210078_01: [0, 6, 0],\r\n    d210079_01: [0, 2.5, 0],\r\n    d210081_01: [0, 2.5, 0],\r\n    d210082_01: [0, 2, 0],\r\n    d210087_01: [0, 2.5, 0],\r\n    d210093_01: [0, 1, 0],\r\n    d210094_01: [0, 2, 0],\r\n    d210095_01: [0, 1, 0],\r\n    d210102_01: [0, 2.5, 0],\r\n    d210103_01: [0, 2.5, 0],\r\n    d210104_01: [0, 1, 0],\r\n    d210109_01: [0, 1, 0],\r\n    d210111_01: [0, 0.5, 0],\r\n    d210112_01: [0, 2.5, 0],\r\n    d210113_01: [0, 1, 0],\r\n    d210114_01: [0, 6, 0],\r\n    d210115_01: [0, 2, 0],\r\n    d210116_01: [0, 2, 0],\r\n    d210117_01: [0, 2, 0],\r\n    d210118_01: [0, 1, 0],\r\n    d210123_01: [0, 3, 0],\r\n    d210125_01: [0, 2, 0],\r\n    d210126_01: [0, 2.5, 0],\r\n    d210127_01: [0, 0.5, 0],\r\n    d210128_01: [0, 0.5, 0], // Puppy\r\n    d210133_01: [0, 0.5, 0],\r\n    d210146_01: [0, 0.5, 0],\r\n    d210136_01: [0, 6, 0],\r\n\r\n    h0010001_02: [0, 3, 0],\r\n    h0120201: [0, 2, 0],\r\n    h0110401: [0, 3.5, 0],\r\n    h0080501: [0, 2, 0],\r\n    h0090501: [0, 2, 0],\r\n    h0100301: [0, 1.5, 0],\r\n    r0070401: [0, 20, 0],\r\n    r0070501: [0, 20, 0],\r\n    r0080401: [0, 2, 0],\r\n\r\n    smith: [0, 0.5, 0],\r\n};\r\n\r\nexport default controlsPosition;\r\n","import { lazy, Suspense, useCallback } from \"react\";\r\n\r\nimport { useSettings, useDispatch } from \"context/SettingsContext\";\r\nimport \"./styles/Display.css\";\r\n\r\nimport getTextColor from \"helpers/getTextColor\";\r\nimport cameraPositions from \"data/cameraPositions\";\r\nimport controlsPosition from \"data/controlsPositions\";\r\n\r\nconst AniControl = lazy(() => import(\"./AniControl\"));\r\nconst BasicViewer = lazy(() => import(\"components/viewers/BasicViewer\"));\r\nconst AniViewer = lazy(() => import(\"components/viewers/AniViewer\"));\r\nconst AdvViewer = lazy(() => import(\"components/viewers/AdvViewer\"));\r\nconst DragonViewer = lazy(() => import(\"components/viewers/DragonViewer\"));\r\n\r\nconst viewers = {\r\n    basic: BasicViewer,\r\n    ani: AniViewer,\r\n    adv: AdvViewer,\r\n    dragon: DragonViewer,\r\n};\r\n\r\n/**\r\n * @param {Object} props\r\n * @param {function} props.setLoadingMsg\r\n * @param {{width: number, height: number}} props.viewport\r\n */\r\nfunction Display(props) {\r\n    const { viewport } = props;\r\n\r\n    const settings = useSettings();\r\n    const {\r\n        model: { id: modelId },\r\n        scene: { rotateSpeed, background, initCameraPosition },\r\n        app: { showAniControl, antiAliasing, pixelRatio, viewerType },\r\n    } = settings;\r\n\r\n    const dispatch = useDispatch();\r\n\r\n    const toggleSetting = useCallback(\r\n        (key, value) => dispatch({ type: \"toggle\", key, value }),\r\n        [dispatch]\r\n    );\r\n    const onCaptureFinish = useCallback(\r\n        () => toggleSetting(\"capture\", \"enable\"),\r\n        [toggleSetting]\r\n    );\r\n    const onExportFinish = useCallback(\r\n        () => toggleSetting(\"export\", \"enable\"),\r\n        [toggleSetting]\r\n    );\r\n\r\n    const modelType = modelId[0];\r\n\r\n    const defaultCameraPosition =\r\n        cameraPositions[modelId] || cameraPositions[modelType];\r\n\r\n    const cameraPosition = initCameraPosition\r\n        ? initCameraPosition.map((n, i) =>\r\n              isNaN(n) ? defaultCameraPosition[i] : n\r\n          )\r\n        : defaultCameraPosition;\r\n\r\n    const controlPosition =\r\n        controlsPosition[modelId] || controlsPosition[modelType];\r\n\r\n    const ModelViewer = viewers[viewerType];\r\n\r\n    return (\r\n        <div className=\"Display\">\r\n            {showAniControl && (\r\n                <div\r\n                    className=\"Display-AniControl\"\r\n                    style={{ color: getTextColor(background) }}\r\n                >\r\n                    <Suspense fallback={null}>\r\n                        <AniControl value={settings.animation.timeScale} />\r\n                    </Suspense>\r\n                </div>\r\n            )}\r\n            <Suspense fallback={null}>\r\n                <ModelViewer\r\n                    setLoadingMsg={props.setLoadingMsg}\r\n                    capture={settings.capture}\r\n                    onCaptureFinish={onCaptureFinish}\r\n                    export={settings.export}\r\n                    onExportFinish={onExportFinish}\r\n                    model={settings.model}\r\n                    material={settings.material}\r\n                    outline={settings.outline}\r\n                    animation={settings.animation}\r\n                    lights={settings.lights}\r\n                    ascii={settings.ascii}\r\n                    antiAliasing={antiAliasing}\r\n                    pixelRatio={pixelRatio}\r\n                    background={background}\r\n                    viewport={viewport}\r\n                    cameraPosition={cameraPosition}\r\n                    controlsPosition={controlPosition}\r\n                    rotateSpeed={rotateSpeed}\r\n                />\r\n            </Suspense>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Display;\r\n","import { initKeyMap, DEFAULT_MODEL_ID } from \"../consts\";\r\nimport { chainCodeToList } from \"../viewerHelpers\";\r\nimport { getDefaultFace, getViewerType } from \"../helpers\";\r\nimport { getDefaultModelMod, getModelModByName } from \"./getModelMod\";\r\nimport { getDefaultAni } from \"./getDefaultAni\";\r\n\r\n/** turn string to the corresponding boolean if it's \"true\" or \"false\"\r\n * @param {string} str\r\n */\r\nconst str2bool = str => Boolean(str === \"true\");\r\n\r\n/** convert string to xyzCoordinate\r\n * @param {string} str\r\n * @return {xyzCoordinate}\r\n */\r\nconst str2xyz = str => {\r\n    const [x, y, z] = str.split(\",\");\r\n    /**\r\n     * @type {array[3]}\r\n     */\r\n    const coordinate = [x, y, z].map(parseFloat);\r\n    return coordinate;\r\n};\r\n\r\n/**\r\n * @param {string} str\r\n * @return {ColorCode | \"transparent\"}\r\n */\r\nconst str2bg = str => {\r\n    switch (str) {\r\n        case \"transparent\":\r\n            return str;\r\n        case \"camera\":\r\n            return \"#cccccc\";\r\n        default:\r\n            // @ts-ignore\r\n            return `#${str}`;\r\n    }\r\n};\r\n\r\n/** convert a string to the specified type\r\n * @param {string} str\r\n * @param {string} type\r\n */\r\nconst convertParamValue = (str, type) => {\r\n    if (type === \"string\") return str;\r\n    const converter = {\r\n        bg: str2bg,\r\n        xyz: str2xyz,\r\n        float: parseFloat,\r\n        int: parseInt,\r\n        boolean: str2bool,\r\n    };\r\n\r\n    return converter[type](str);\r\n};\r\n\r\n/** turn a string of the form 'keycode=value' to [keycode, value],\r\n * return empty array if empty input, or invalid keycode/value\r\n * @param {string} paramText\r\n * @return {[ [keycode: string, value: *]? ]}\r\n */\r\nconst extractParam = paramText => {\r\n    if (!paramText) return [];\r\n\r\n    const [keycode, ...valueParts] = paramText.split(\"=\");\r\n    if (!initKeyMap[keycode] || !valueParts[0]) return [];\r\n\r\n    const value = valueParts.join(\"=\");\r\n    const { type } = initKeyMap[keycode];\r\n\r\n    return [[keycode, convertParamValue(value, type)]];\r\n};\r\n\r\n/** turn a path into an array of keycode and value pair,\r\n * invalid strings will be filtered out\r\n * @param {string} path\r\n * @return {[keycode: string, value: *][]}\r\n */\r\nconst getParamsFromPath = path =>\r\n    path\r\n        .split(\"/\")\r\n        .reduce(\r\n            (output, paramText) => [...output, ...extractParam(paramText)],\r\n            []\r\n        );\r\n\r\n/** return a list of key value pairs corresponding to the specified group of the application state\r\n * @param { [keycode: string, value: *][] } params\r\n * @param {string} groupName\r\n * @return { [key: string, value: *][] }\r\n */\r\nconst filterParamsByGroup = (params, groupName) =>\r\n    params.reduce((output, [keycode, value]) => {\r\n        const { group, key } = initKeyMap[keycode];\r\n        if (group !== groupName) return output;\r\n\r\n        return [...output, [key, value]];\r\n    }, []);\r\n\r\n/** set model related parameters\r\n * @param {[keycode: string, value: *][]} params\r\n * @param {React.Dispatch<ReducerAction>} dispatch\r\n */\r\nconst setModelParams = async (params, dispatch) => {\r\n    const modelParams = filterParamsByGroup(params, \"model\");\r\n    const model = Object.fromEntries(modelParams);\r\n\r\n    // model.id ??= DEFAULT_MODEL_ID;\r\n    model.id = model.id ?? DEFAULT_MODEL_ID;\r\n    const modelId = model.id;\r\n\r\n    [\"mouth\", \"eye\"].forEach(part => {\r\n        // model[`${part}Texture`] ??= modelId;\r\n        // model[`${part}Idx`] ??= getDefaultFace(modelId);\r\n        model[`${part}Texture`] = model[`${part}Texture`] ?? modelId;\r\n        model[`${part}Idx`] = model[`${part}Idx`] ?? getDefaultFace(modelId);\r\n    });\r\n\r\n    dispatch({ type: \"update\", key: \"model\", value: model });\r\n    dispatch({\r\n        type: \"update\",\r\n        key: \"app\",\r\n        value: { viewerType: getViewerType(modelId) },\r\n    });\r\n\r\n    await setModelMod(model, dispatch);\r\n};\r\n\r\n/** set model mod from param init object\r\n * @param {Object} modelData\r\n */\r\nconst setModelMod = async (modelData, dispatch) => {\r\n    const modelId = modelData.id;\r\n\r\n    const defaultMod = await getDefaultModelMod(modelId);\r\n    if (!defaultMod) return;\r\n\r\n    const updateValue = {};\r\n    if (modelData.modName) {\r\n        const mod = await getModelModByName(modelId, modelData.modName);\r\n\r\n        updateValue.mod = mod.code;\r\n        updateValue.modName = mod.name;\r\n    } else {\r\n        updateValue.mod = defaultMod.code;\r\n        updateValue.modName = defaultMod.name;\r\n    }\r\n\r\n    dispatch({\r\n        type: \"update\",\r\n        key: \"model\",\r\n        value: updateValue,\r\n    });\r\n};\r\n\r\n/** set animation related parameters\r\n * @param {[keycode: string, value: *][]} params\r\n * @param {React.Dispatch<ReducerAction>} dispatch\r\n */\r\nconst setAniParams = async (params, dispatch) => {\r\n    const aniParams = filterParamsByGroup(params, \"animation\");\r\n\r\n    const animation = Object.fromEntries(aniParams);\r\n\r\n    const modelId =\r\n        params.find(([keycode]) => keycode === \"id\")?.[1] || DEFAULT_MODEL_ID;\r\n    // newValue.code ??= getDefaultAni(modelId);\r\n    animation.code = animation.code ?? (await getDefaultAni(modelId));\r\n    dispatch({ type: \"update\", key: \"animation\", value: animation });\r\n\r\n    const aniCode = animation.code;\r\n    dispatch({\r\n        type: \"update\",\r\n        key: \"chainMaker\",\r\n        value: { chain: chainCodeToList(aniCode, \"init\") },\r\n    });\r\n};\r\n\r\n/** set other parameters\r\n * @param {[keycode: string, value: *][]} params\r\n * @param {React.Dispatch<ReducerAction>} dispatch\r\n * @param {string} group - name of the parameter group\r\n */\r\nconst setOtherParams = (params, dispatch, group) => {\r\n    const paramList = filterParamsByGroup(params, group);\r\n    const newValue = Object.fromEntries(paramList);\r\n\r\n    dispatch({\r\n        type: \"update\",\r\n        key: group,\r\n        value: newValue,\r\n    });\r\n};\r\n\r\n/** update application state base on information from the URL\r\n * @param {string} path\r\n * @param {React.Dispatch<ReducerAction>} dispatch\r\n */\r\nexport const setParamsFromPath = async (path, dispatch) => {\r\n    const params = getParamsFromPath(path);\r\n\r\n    const definedGroups = new Set(\r\n        params.map(([keycode]) => initKeyMap[keycode].group)\r\n    );\r\n\r\n    definedGroups.delete(\"model\");\r\n    definedGroups.delete(\"animation\");\r\n\r\n    await setModelParams(params, dispatch);\r\n\r\n    const groups = [...definedGroups];\r\n    const groupSetPromise = groups.map(group =>\r\n        setOtherParams(params, dispatch, group)\r\n    );\r\n\r\n    await Promise.all([setAniParams(params, dispatch), ...groupSetPromise]);\r\n};\r\n\r\nexport default setParamsFromPath;\r\n","import {\r\n    lazy,\r\n    Suspense,\r\n    useState,\r\n    useRef,\r\n    useEffect,\r\n    useCallback,\r\n} from \"react\";\r\n\r\nimport useToggleState from \"hooks/useToggleState\";\r\n\r\nimport Menu from \"@material-ui/icons/Menu\";\r\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\r\nimport useStyles from \"./MainPageStyles\";\r\n\r\nimport Display from \"./Display\";\r\n\r\nimport { useSettings, useDispatch } from \"context/SettingsContext\";\r\nimport { getViewerType } from \"helpers/helpers\";\r\nimport { getDefaultAni } from \"helpers/async/getDefaultAni\";\r\n\r\nimport setParamsFromPath from \"helpers/async/setParamsFromPath\";\r\nimport { getDefaultModelMod } from \"helpers/async/getModelMod\";\r\n\r\nimport { chainCodeToList } from \"helpers/viewerHelpers\";\r\n\r\nconst Sidebar = lazy(() =>\r\n    import(/* webpackChunkName: \"Sidebar\" */ \"./Sidebar\")\r\n);\r\nconst Dock = lazy(() => import(/* webpackChunkName: \"Dock\" */ \"./Dock\"));\r\n\r\nfunction MainPage({ location }) {\r\n    const classes = useStyles();\r\n\r\n    const [sidebar, toggleSidebar] = useToggleState(true);\r\n    const [loadingMsg, setLoadingMsg] = useState(\"Loading...\");\r\n    const [initLoadDone, setInitLoadDone] = useState(false);\r\n    const [viewport, setViewport] = useState({\r\n        width: window.innerWidth,\r\n        height: window.innerHeight,\r\n    });\r\n\r\n    const [dockMode, setDockMode] = useState(\"\");\r\n    const dockHandle = useRef();\r\n\r\n    const {\r\n        model,\r\n        app: { showSettings, viewerType },\r\n    } = useSettings();\r\n    const dispatch = useDispatch();\r\n\r\n    const viewerRef = useRef();\r\n    const currentId = useRef(\"\");\r\n\r\n    const updateViewportSize = () => {\r\n        const width = viewerRef.current.clientWidth;\r\n        const height = viewerRef.current.clientHeight;\r\n        setViewport({ width, height });\r\n    };\r\n\r\n    const setDock = (mode, handleSelect) => {\r\n        setDockMode(mode);\r\n        dockHandle.current = handleSelect;\r\n    };\r\n\r\n    const closeDock = () => setDockMode(\"\");\r\n\r\n    const updateSetings = useCallback(\r\n        key => value => dispatch({ type: \"update\", key, value }),\r\n        [dispatch]\r\n    );\r\n\r\n    // load params from path\r\n    useEffect(() => {\r\n        (async function setParams() {\r\n            setLoadingMsg(\"Loading...\");\r\n            await setParamsFromPath(location.pathname, dispatch);\r\n            setLoadingMsg(\"\");\r\n            setInitLoadDone(true);\r\n        })();\r\n    }, [location.pathname, dispatch]);\r\n\r\n    // update settings when id changed\r\n    useEffect(() => {\r\n        const { id } = model;\r\n        if (!currentId.current) {\r\n            currentId.current = id;\r\n            return;\r\n        }\r\n\r\n        if (id === currentId.current) return;\r\n\r\n        const newViewerType = getViewerType(id);\r\n        const viewerChanged = newViewerType !== viewerType;\r\n        updateSetings(\"app\")({ viewerType: newViewerType });\r\n\r\n        const viewerChangedToAdv = newViewerType === \"adv\" && viewerChanged;\r\n        if (viewerChangedToAdv) {\r\n            updateSetings(\"model\")({ eyeIdx: 2, mouthIdx: 2 });\r\n        }\r\n\r\n        if (viewerChanged && newViewerType === \"dragon\") {\r\n            updateSetings(\"model\")({ eyeIdx: 1, mouthIdx: 1 });\r\n        }\r\n\r\n        const needResetAni =\r\n            [\"dragon\", \"ani\"].includes(newViewerType) || viewerChangedToAdv;\r\n\r\n        const resetAni = async () => {\r\n            const ani = await getDefaultAni(id);\r\n            updateSetings(\"animation\")({ code: ani });\r\n            updateSetings(\"chainMaker\")({\r\n                chain: chainCodeToList(ani, \"init\"),\r\n            });\r\n        };\r\n\r\n        const setModelMod = async () => {\r\n            const modelMod = await getDefaultModelMod(id);\r\n            if (modelMod) {\r\n                updateSetings(\"model\")({\r\n                    mod: modelMod?.code,\r\n                    modName: modelMod?.name,\r\n                });\r\n            }\r\n        };\r\n        Promise.all([setModelMod(), needResetAni && resetAni()]);\r\n\r\n        currentId.current = id;\r\n    }, [model, updateSetings, viewerType]);\r\n\r\n    // update viewport size when resized\r\n    useEffect(() => {\r\n        window.addEventListener(\"resize\", updateViewportSize);\r\n\r\n        return function () {\r\n            window.removeEventListener(\"resize\", updateViewportSize);\r\n        };\r\n    }, []);\r\n\r\n    return (\r\n        <>\r\n            {loadingMsg && (\r\n                <div className={classes.loadingMsg}>{loadingMsg}</div>\r\n            )}\r\n            {initLoadDone && (\r\n                <div className={classes.root}>\r\n                    {showSettings && (\r\n                        <Suspense fallback={null}>\r\n                            <CssBaseline />\r\n                            <button\r\n                                onClick={toggleSidebar}\r\n                                className={classes.openSidebarButton}\r\n                            >\r\n                                <Menu />\r\n                            </button>\r\n                            <Sidebar\r\n                                toggleSidebar={toggleSidebar}\r\n                                open={sidebar}\r\n                                setDock={setDock}\r\n                            />\r\n                        </Suspense>\r\n                    )}\r\n                    <main ref={viewerRef} className={classes.content}>\r\n                        <Display\r\n                            setLoadingMsg={setLoadingMsg}\r\n                            viewport={viewport}\r\n                        />\r\n                    </main>\r\n                    {dockMode && (\r\n                        <Suspense fallback={null}>\r\n                            <Dock\r\n                                mode={dockMode}\r\n                                handleSelect={dockHandle.current}\r\n                                close={closeDock}\r\n                            />\r\n                        </Suspense>\r\n                    )}\r\n                </div>\r\n            )}\r\n        </>\r\n    );\r\n}\r\n\r\nexport default MainPage;\r\n","import { SettingsProvider } from \"context/SettingsContext\";\r\n\r\nimport { Route, HashRouter } from \"react-router-dom\";\r\nimport MainPage from \"MainPage\";\r\n\r\nimport \"styles/App.css\";\r\n\r\nfunction App() {\r\n    return (\r\n        <SettingsProvider>\r\n            <HashRouter>\r\n                <Route render={routeProps => <MainPage {...routeProps} />} />\r\n            </HashRouter>\r\n        </SettingsProvider>\r\n    );\r\n}\r\n\r\nexport const fbxSource = process.env.PUBLIC_URL;\r\n\r\nexport default App;\r\n","/**\r\n * @type {{ [id:string]: xyCoordinate }}\r\n */\r\nconst textureOffsets = {\r\n    c110394_01: [0.05, -0.08], // Cecile\r\n    c100019_02: [0.05, -0.08], // Harle\r\n    c100018_07: [0.05, -0.08], // Leif\r\n    c110349_04: [0.05, -0.08], // Yukata Lathna\r\n    c100004_19: [0.05, -0.08], // Yukata Cleo\r\n    c110334_02: [0.05, -0.08], // Gala Audric\r\n    c100001_12: [0.05, -0.08], // Summer Prince\r\n    c100013_06: [0.05, -0.08], // Summer Leonidas\r\n    c100015_08: [0.05, -0.08], // Summer Chelle\r\n    c100017_01: [0.05, -0.08], // Emile\r\n    c110345_03: [0.08, 0.15], // Summer Mitsuhide\r\n    c110313_03: [0, -0.025], // Summer Ieyasu\r\n    c100005_08: [0.05, -0.08], // Summer Alex\r\n    c100002_07: [0.05, -0.08], // Summer Elisanne\r\n    c100010_10: [0.05, -0.08], // Summer Mym\r\n    c110352_03: [0.05, -0.08], // Faeblessed Tobias\r\n    c110392_01: [0.05, -0.08], // Nino\r\n    c110391_01: [0.05, -0.08], // Isaac\r\n    c100029_04: [0.05, -0.08], // Sharpshooter Sarisse\r\n    c100045_01: [0.05, -0.08], // Gala Mascula\r\n    c110064_02: [0.05, -0.08], // Armored Yachiyo\r\n    c110389_01: [0.05, -0.08], // Saiga\r\n    c110285_01: [0.05, -0.08], // Grimnir\r\n    c110388_01: [0.05, -0.08], // Vania\r\n    c110385_01: [0.05, -0.08], // Humanoid Mercury\r\n    c100003_10: [0.05, -0.08], // Child Ranzal\r\n    c110386_01: [0.043, 0.05], // Myriam\r\n    c110387_01: [0.05, -0.08], // Humanoid Midgardsormr\r\n    c100031_03: [0.05, -0.08], // Alberius\r\n    c100007_07: [0.05, -0.08], // Gala Notte\r\n    c110384_01: [0.05, -0.08], // Eirene\r\n    c110383_01: [0.05, -0.08], // Finni\r\n    c110382_01: [0.05, -0.08], // Faris\r\n    c110381_01: [0.05, -0.08], // Ryszarda\r\n    c110342_03: [0.05, -0.08], // Valentine's Chelsea\r\n    c110377_01: [0.043, -0.08], // Joker\r\n    c110378_01: [0.043, -0.08], // Panther\r\n    c110379_01: [0.075, -0.08], // Mona\r\n    c110380_01: [0.043, -0.2], // Sophie\r\n    c100015_05: [0.05, -0.08], // Gala Chelle\r\n    c100006_11: [0.043, -0.0625], // Kimono Luca\r\n    c110376_01: [0.043, -0.0625], // Yoshitsune\r\n    c110375_01: [0.043, -0.0625], // Seimei\r\n    c110374_01: [0.043, -0.0625], // Kuzunoha\r\n    c110307_02: [0.043, 0], // Dragonyule Victor\r\n    c110252_02: [0.043, -0.0625], // Dragonyule Lily\r\n    c110296_02: [0.043, -0.0625], // Forager Mitsuba\r\n    c100004_17: [0.043, -0.0625], // Forager Cleo\r\n    c110371_01: [0.043, -0.0625], // Pecorine\r\n    c110350_02: [0.043, -0.0625], // Formal Joachim\r\n    c110340_02: [0.043, -0.0625], // Formal Noelle\r\n    c110018_02: [0.043, -0.0625], // Opera Karina\r\n    c110370_01: [0.043, -0.0625], // Lapis\r\n    c100015_04: [0.05, -0.08], // Chelle\r\n    c110342_01: [0, -0.02], // Chelsea\r\n    c110267_01: [0.08, -0.03], // Hawk\r\n    c110050_02: [0.07, 0.13], // HBerserker\r\n    c110291_01: [0.07, 0.14], // Marth\r\n    c110354_01: [0.07, 0.01], // Mega Man\r\n    c110345_01: [0.08, 0.15], // Mitsuhide\r\n    c110266_01: [0.01, 0.03], // Naveed\r\n    c110365_01: [0.043, -0.0625], // Nevin\r\n    c110346_01: [0.07, 0.08], // Nobunaga\r\n    c110366_01: [0.043, -0.0625], // Pinon\r\n    c110299_02: [0.07, 0.08], // RXZ\r\n    c110360_01: [0.07, 0.14], // Tiki\r\n    c110307_01: [0.08, -0.03], // Victor\r\n    c110322_01: [0.043, 0.08], // Zhu Bajie\r\n    c110356_01: [0.07, 0.08], // Gauld\r\n    c110300_01: [0.07, -0.1], // Pipple\r\n    c110344_01: [0.07, -0.02], // Yuya\r\n    c110053_03: [0.043, -0.0625], // INefi\r\n    c110368_01: [0.043, -0.0625], // Meene\r\n    c110367_01: [0.043, -0.0625], // Ilia\r\n    c110003_02: [0.043, -0.0625], // Gun Joe\r\n    c110270_02: [0.043, -0.0625], // HMelsa\r\n    c110341_03: [0.043, -0.0625], // Hakasha\r\n};\r\n\r\nexport default textureOffsets;\r\n\r\n/**\r\n * @type {{ [faceNumber: string]: xyCoordinate }}\r\n */\r\nexport const idxOffsets = {\r\n    face1: [2, 1],\r\n    face2: [0, 0],\r\n    face3: [1, 0],\r\n    face4: [2, 0],\r\n    face5: [3, 0],\r\n    face6: [0, -1],\r\n    face7: [1, -1],\r\n    face8: [2, -1],\r\n    face9: [3, -1],\r\n};\r\n","/**\r\n * @param {string} modelId\r\n * @return {Promise<ModelMod | undefined>}\r\n */\r\nexport const getDefaultModelMod = async modelId => {\r\n    const { default: modelMod } = await import(\r\n        /* webpackChunkName: \"ModelMod\" */\r\n        \"data/modelMod\"\r\n    );\r\n    return modelMod[modelId]?.[0];\r\n};\r\n\r\n/**\r\n * @param {string} id\r\n * @param {string} modName\r\n * @return {Promise<ModelMod>}\r\n */\r\nexport const getModelModByName = async (id, modName) => {\r\n    const { default: modelMod } = await import(\r\n        /* webpackChunkName: \"ModelMod\" */\r\n        \"data/modelMod\"\r\n    );\r\n    const result = modelMod[id]?.find(\r\n        ({ name }) => name.replace(\" \", \"\") === modName\r\n    );\r\n\r\n    return result || { name: \"\", code: \"\" };\r\n};\r\n","/**\r\n * @type { Array<{ name: string, path: string }> }\r\n */\r\nconst matcapList = [\r\n    { name: \"Black Stone\", path: \"matcap_black_stone.jpg\" },\r\n    { name: \"Chrome 1\", path: \"matcap_chrome_1.jpg\" },\r\n    { name: \"Chrome 2\", path: \"matcap_chrome_2.jpg\" },\r\n    { name: \"Brown Clay\", path: \"matcap_clay_brown.jpg\" },\r\n    { name: \"Dark Brown Clay\", path: \"matcap_clay_dark_brown.jpg\" },\r\n    { name: \"Flesh Clay\", path: \"matcap_clay_flesh_6.jpg\" },\r\n    { name: \"Gray Clay\", path: \"matcap_clay_gray.jpg\" },\r\n    { name: \"Metal Putty\", path: \"matcap_metal_putty.jpg\" },\r\n    { name: \"Obsidian\", path: \"matcap_obsidian.jpg\" },\r\n    { name: \"Pearl\", path: \"matcap_pearl.jpg\" },\r\n    { name: \"Yellow Plastic\", path: \"matcap_plastic_yellow.jpg\" },\r\n    { name: \"Sci-fi Plastic\", path: \"matcap_scifi_plastic.jpg\" },\r\n    { name: \"Rim Lit\", path: \"matcap_rim_lit.jpg\" },\r\n    { name: \"Slick Mud\", path: \"matcap_slick_mud.jpg\" },\r\n    { name: \"Shiny Metal\", path: \"metal_shiny.jpg\" },\r\n];\r\n\r\nexport default matcapList;\r\n","import {\r\n    AmbientLight,\r\n    AnimationClip,\r\n    Bone,\r\n    BufferGeometry,\r\n    ClampToEdgeWrapping,\r\n    Color,\r\n    DirectionalLight,\r\n    EquirectangularReflectionMapping,\r\n    Euler,\r\n    FileLoader,\r\n    Float32BufferAttribute,\r\n    Group,\r\n    Line,\r\n    LineBasicMaterial,\r\n    Loader,\r\n    LoaderUtils,\r\n    MathUtils,\r\n    Matrix3,\r\n    Matrix4,\r\n    Mesh,\r\n    MeshLambertMaterial,\r\n    MeshPhongMaterial,\r\n    NumberKeyframeTrack,\r\n    Object3D,\r\n    OrthographicCamera,\r\n    PerspectiveCamera,\r\n    PointLight,\r\n    PropertyBinding,\r\n    Quaternion,\r\n    QuaternionKeyframeTrack,\r\n    RepeatWrapping,\r\n    Skeleton,\r\n    SkinnedMesh,\r\n    SpotLight,\r\n    Texture,\r\n    TextureLoader,\r\n    Uint16BufferAttribute,\r\n    Vector3,\r\n    Vector4,\r\n    VectorKeyframeTrack,\r\n    sRGBEncoding,\r\n} from \"three\";\r\nimport * as fflate from \"three/examples/jsm/libs/fflate.module.js\";\r\nimport { NURBSCurve } from \"three/examples/jsm/curves/NURBSCurve.js\";\r\n\r\n/**\r\n * Loader loads FBX file and generates Group representing FBX scene.\r\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\r\n * Versions lower than this may load but will probably have errors\r\n *\r\n * Needs Support:\r\n *  Morph normals / blend shape normals\r\n *\r\n * FBX format references:\r\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\r\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\r\n *\r\n * \tBinary format specification:\r\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\r\n */\r\n\r\nlet fbxTree;\r\nlet connections;\r\nlet sceneGraph;\r\n\r\nclass FBXLoader extends Loader {\r\n    load(url, onLoad, onProgress, onError) {\r\n        const scope = this;\r\n\r\n        const path =\r\n            scope.path === \"\" ? LoaderUtils.extractUrlBase(url) : scope.path;\r\n\r\n        const loader = new FileLoader(this.manager);\r\n        loader.setPath(scope.path);\r\n        loader.setResponseType(\"arraybuffer\");\r\n        loader.setRequestHeader(scope.requestHeader);\r\n        loader.setWithCredentials(scope.withCredentials);\r\n\r\n        loader.load(\r\n            url,\r\n            function (buffer) {\r\n                try {\r\n                    onLoad(scope.parse(buffer, path));\r\n                } catch (e) {\r\n                    if (onError) {\r\n                        onError(e);\r\n                    } else {\r\n                        console.error(e);\r\n                    }\r\n\r\n                    scope.manager.itemError(url);\r\n                }\r\n            },\r\n            onProgress,\r\n            onError\r\n        );\r\n    }\r\n\r\n    parse(FBXBuffer, path) {\r\n        if (isFbxFormatBinary(FBXBuffer)) {\r\n            fbxTree = new BinaryParser().parse(FBXBuffer);\r\n        } else {\r\n            const FBXText = convertArrayBufferToString(FBXBuffer);\r\n\r\n            if (!isFbxFormatASCII(FBXText)) {\r\n                throw new Error(\"THREE.FBXLoader: Unknown format.\");\r\n            }\r\n\r\n            if (getFbxVersion(FBXText) < 7000) {\r\n                throw new Error(\r\n                    \"THREE.FBXLoader: FBX version not supported, FileVersion: \" +\r\n                        getFbxVersion(FBXText)\r\n                );\r\n            }\r\n\r\n            fbxTree = new TextParser().parse(FBXText);\r\n        }\r\n\r\n        // console.log( fbxTree );\r\n\r\n        const textureLoader = new TextureLoader(this.manager)\r\n            .setPath(this.resourcePath || path)\r\n            .setCrossOrigin(this.crossOrigin);\r\n\r\n        return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);\r\n    }\r\n}\r\n\r\n// Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group\r\nclass FBXTreeParser {\r\n    constructor(textureLoader, manager) {\r\n        this.textureLoader = textureLoader;\r\n        this.manager = manager;\r\n    }\r\n\r\n    parse() {\r\n        connections = this.parseConnections();\r\n\r\n        const images = this.parseImages();\r\n        const textures = this.parseTextures(images);\r\n        const materials = this.parseMaterials(textures);\r\n        const deformers = this.parseDeformers();\r\n        const geometryMap = new GeometryParser().parse(deformers);\r\n\r\n        this.parseScene(deformers, geometryMap, materials);\r\n\r\n        return sceneGraph;\r\n    }\r\n\r\n    // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\r\n    // and details the connection type\r\n    parseConnections() {\r\n        const connectionMap = new Map();\r\n\r\n        if (\"Connections\" in fbxTree) {\r\n            const rawConnections = fbxTree.Connections.connections;\r\n\r\n            rawConnections.forEach(function (rawConnection) {\r\n                const fromID = rawConnection[0];\r\n                const toID = rawConnection[1];\r\n                const relationship = rawConnection[2];\r\n\r\n                if (!connectionMap.has(fromID)) {\r\n                    connectionMap.set(fromID, {\r\n                        parents: [],\r\n                        children: [],\r\n                    });\r\n                }\r\n\r\n                const parentRelationship = {\r\n                    ID: toID,\r\n                    relationship: relationship,\r\n                };\r\n                connectionMap.get(fromID).parents.push(parentRelationship);\r\n\r\n                if (!connectionMap.has(toID)) {\r\n                    connectionMap.set(toID, {\r\n                        parents: [],\r\n                        children: [],\r\n                    });\r\n                }\r\n\r\n                const childRelationship = {\r\n                    ID: fromID,\r\n                    relationship: relationship,\r\n                };\r\n                connectionMap.get(toID).children.push(childRelationship);\r\n            });\r\n        }\r\n\r\n        return connectionMap;\r\n    }\r\n\r\n    // Parse FBXTree.Objects.Video for embedded image data\r\n    // These images are connected to textures in FBXTree.Objects.Textures\r\n    // via FBXTree.Connections.\r\n    parseImages() {\r\n        const images = {};\r\n        const blobs = {};\r\n\r\n        if (\"Video\" in fbxTree.Objects) {\r\n            const videoNodes = fbxTree.Objects.Video;\r\n\r\n            for (const nodeID in videoNodes) {\r\n                const videoNode = videoNodes[nodeID];\r\n\r\n                const id = parseInt(nodeID);\r\n\r\n                images[id] = videoNode.RelativeFilename || videoNode.Filename;\r\n\r\n                // raw image data is in videoNode.Content\r\n                if (\"Content\" in videoNode) {\r\n                    const arrayBufferContent =\r\n                        videoNode.Content instanceof ArrayBuffer &&\r\n                        videoNode.Content.byteLength > 0;\r\n                    const base64Content =\r\n                        typeof videoNode.Content === \"string\" &&\r\n                        videoNode.Content !== \"\";\r\n\r\n                    if (arrayBufferContent || base64Content) {\r\n                        const image = this.parseImage(videoNodes[nodeID]);\r\n\r\n                        blobs[\r\n                            videoNode.RelativeFilename || videoNode.Filename\r\n                        ] = image;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const id in images) {\r\n            const filename = images[id];\r\n\r\n            if (blobs[filename] !== undefined) images[id] = blobs[filename];\r\n            else images[id] = images[id].split(\"\\\\\").pop();\r\n        }\r\n\r\n        return images;\r\n    }\r\n\r\n    // Parse embedded image data in FBXTree.Video.Content\r\n    parseImage(videoNode) {\r\n        const content = videoNode.Content;\r\n        const fileName = videoNode.RelativeFilename || videoNode.Filename;\r\n        const extension = fileName\r\n            .slice(fileName.lastIndexOf(\".\") + 1)\r\n            .toLowerCase();\r\n\r\n        let type;\r\n\r\n        switch (extension) {\r\n            case \"bmp\":\r\n                type = \"image/bmp\";\r\n                break;\r\n\r\n            case \"jpg\":\r\n            case \"jpeg\":\r\n                type = \"image/jpeg\";\r\n                break;\r\n\r\n            case \"png\":\r\n                type = \"image/png\";\r\n                break;\r\n\r\n            case \"tif\":\r\n                type = \"image/tiff\";\r\n                break;\r\n\r\n            case \"tga\":\r\n                if (this.manager.getHandler(\".tga\") === null) {\r\n                    console.warn(\r\n                        \"FBXLoader: TGA loader not found, skipping \",\r\n                        fileName\r\n                    );\r\n                }\r\n\r\n                type = \"image/tga\";\r\n                break;\r\n\r\n            default:\r\n                console.warn(\r\n                    'FBXLoader: Image type \"' +\r\n                        extension +\r\n                        '\" is not supported.'\r\n                );\r\n                return;\r\n        }\r\n\r\n        if (typeof content === \"string\") {\r\n            // ASCII format\r\n\r\n            return \"data:\" + type + \";base64,\" + content;\r\n        } else {\r\n            // Binary Format\r\n\r\n            const array = new Uint8Array(content);\r\n            return window.URL.createObjectURL(\r\n                new Blob([array], { type: type })\r\n            );\r\n        }\r\n    }\r\n\r\n    // Parse nodes in FBXTree.Objects.Texture\r\n    // These contain details such as UV scaling, cropping, rotation etc and are connected\r\n    // to images in FBXTree.Objects.Video\r\n    parseTextures(images) {\r\n        const textureMap = new Map();\r\n\r\n        if (\"Texture\" in fbxTree.Objects) {\r\n            const textureNodes = fbxTree.Objects.Texture;\r\n            for (const nodeID in textureNodes) {\r\n                const texture = this.parseTexture(textureNodes[nodeID], images);\r\n                textureMap.set(parseInt(nodeID), texture);\r\n            }\r\n        }\r\n\r\n        return textureMap;\r\n    }\r\n\r\n    // Parse individual node in FBXTree.Objects.Texture\r\n    parseTexture(textureNode, images) {\r\n        const texture = this.loadTexture(textureNode, images);\r\n\r\n        texture.ID = textureNode.id;\r\n\r\n        texture.name = textureNode.attrName;\r\n\r\n        const wrapModeU = textureNode.WrapModeU;\r\n        const wrapModeV = textureNode.WrapModeV;\r\n\r\n        const valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\r\n        const valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\r\n\r\n        // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\r\n        // 0: repeat(default), 1: clamp\r\n\r\n        texture.wrapS = valueU === 0 ? RepeatWrapping : ClampToEdgeWrapping;\r\n        texture.wrapT = valueV === 0 ? RepeatWrapping : ClampToEdgeWrapping;\r\n\r\n        if (\"Scaling\" in textureNode) {\r\n            const values = textureNode.Scaling.value;\r\n\r\n            texture.repeat.x = values[0];\r\n            texture.repeat.y = values[1];\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    // load a texture specified as a blob or data URI, or via an external URL using TextureLoader\r\n    loadTexture(textureNode, images) {\r\n        let fileName;\r\n\r\n        const currentPath = this.textureLoader.path;\r\n\r\n        const children = connections.get(textureNode.id).children;\r\n\r\n        if (\r\n            children !== undefined &&\r\n            children.length > 0 &&\r\n            images[children[0].ID] !== undefined\r\n        ) {\r\n            fileName = images[children[0].ID];\r\n\r\n            if (\r\n                fileName.indexOf(\"blob:\") === 0 ||\r\n                fileName.indexOf(\"data:\") === 0\r\n            ) {\r\n                this.textureLoader.setPath(undefined);\r\n            }\r\n        }\r\n\r\n        let texture;\r\n\r\n        const extension = textureNode.FileName.slice(-3).toLowerCase();\r\n\r\n        if (extension === \"tga\") {\r\n            const loader = this.manager.getHandler(\".tga\");\r\n\r\n            if (loader === null) {\r\n                console.warn(\r\n                    \"FBXLoader: TGA loader not found, creating placeholder texture for\",\r\n                    textureNode.RelativeFilename\r\n                );\r\n                texture = new Texture();\r\n            } else {\r\n                loader.setPath(this.textureLoader.path);\r\n                texture = loader.load(fileName);\r\n            }\r\n        } else if (extension === \"psd\") {\r\n            console.warn(\r\n                \"FBXLoader: PSD textures are not supported, creating placeholder texture for\",\r\n                textureNode.RelativeFilename\r\n            );\r\n            texture = new Texture();\r\n        } else {\r\n            texture = this.textureLoader.load(fileName);\r\n        }\r\n\r\n        this.textureLoader.setPath(currentPath);\r\n\r\n        return texture;\r\n    }\r\n\r\n    // Parse nodes in FBXTree.Objects.Material\r\n    parseMaterials(textureMap) {\r\n        const materialMap = new Map();\r\n\r\n        if (\"Material\" in fbxTree.Objects) {\r\n            const materialNodes = fbxTree.Objects.Material;\r\n\r\n            for (const nodeID in materialNodes) {\r\n                const material = this.parseMaterial(\r\n                    materialNodes[nodeID],\r\n                    textureMap\r\n                );\r\n\r\n                if (material !== null)\r\n                    materialMap.set(parseInt(nodeID), material);\r\n            }\r\n        }\r\n\r\n        return materialMap;\r\n    }\r\n\r\n    // Parse single node in FBXTree.Objects.Material\r\n    // Materials are connected to texture maps in FBXTree.Objects.Textures\r\n    // FBX format currently only supports Lambert and Phong shading models\r\n    parseMaterial(materialNode, textureMap) {\r\n        const ID = materialNode.id;\r\n        const name = materialNode.attrName;\r\n        let type = materialNode.ShadingModel;\r\n\r\n        // Case where FBX wraps shading model in property object.\r\n        if (typeof type === \"object\") {\r\n            type = type.value;\r\n        }\r\n\r\n        // Ignore unused materials which don't have any connections.\r\n        if (!connections.has(ID)) return null;\r\n\r\n        const parameters = this.parseParameters(materialNode, textureMap, ID);\r\n\r\n        let material;\r\n\r\n        switch (type.toLowerCase()) {\r\n            case \"phong\":\r\n                material = new MeshPhongMaterial();\r\n                break;\r\n            case \"lambert\":\r\n                material = new MeshLambertMaterial();\r\n                break;\r\n            default:\r\n                console.warn(\r\n                    'THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.',\r\n                    type\r\n                );\r\n                material = new MeshPhongMaterial();\r\n                break;\r\n        }\r\n\r\n        material.setValues(parameters);\r\n        material.name = name;\r\n\r\n        return material;\r\n    }\r\n\r\n    // Parse FBX material and return parameters suitable for a three.js material\r\n    // Also parse the texture map and return any textures associated with the material\r\n    parseParameters(materialNode, textureMap, ID) {\r\n        const parameters = {};\r\n\r\n        if (materialNode.BumpFactor) {\r\n            parameters.bumpScale = materialNode.BumpFactor.value;\r\n        }\r\n\r\n        if (materialNode.Diffuse) {\r\n            parameters.color = new Color().fromArray(\r\n                materialNode.Diffuse.value\r\n            );\r\n        } else if (\r\n            materialNode.DiffuseColor &&\r\n            (materialNode.DiffuseColor.type === \"Color\" ||\r\n                materialNode.DiffuseColor.type === \"ColorRGB\")\r\n        ) {\r\n            // The blender exporter exports diffuse here instead of in materialNode.Diffuse\r\n            parameters.color = new Color().fromArray(\r\n                materialNode.DiffuseColor.value\r\n            );\r\n        }\r\n\r\n        if (materialNode.DisplacementFactor) {\r\n            parameters.displacementScale =\r\n                materialNode.DisplacementFactor.value;\r\n        }\r\n\r\n        if (materialNode.Emissive) {\r\n            parameters.emissive = new Color().fromArray(\r\n                materialNode.Emissive.value\r\n            );\r\n        } else if (\r\n            materialNode.EmissiveColor &&\r\n            (materialNode.EmissiveColor.type === \"Color\" ||\r\n                materialNode.EmissiveColor.type === \"ColorRGB\")\r\n        ) {\r\n            // The blender exporter exports emissive color here instead of in materialNode.Emissive\r\n            parameters.emissive = new Color().fromArray(\r\n                materialNode.EmissiveColor.value\r\n            );\r\n        }\r\n\r\n        if (materialNode.EmissiveFactor) {\r\n            parameters.emissiveIntensity = parseFloat(\r\n                materialNode.EmissiveFactor.value\r\n            );\r\n        }\r\n\r\n        if (materialNode.Opacity) {\r\n            parameters.opacity = parseFloat(materialNode.Opacity.value);\r\n        }\r\n\r\n        if (parameters.opacity < 1.0) {\r\n            parameters.transparent = true;\r\n        }\r\n\r\n        if (materialNode.ReflectionFactor) {\r\n            parameters.reflectivity = materialNode.ReflectionFactor.value;\r\n        }\r\n\r\n        if (materialNode.Shininess) {\r\n            parameters.shininess = materialNode.Shininess.value;\r\n        }\r\n\r\n        if (materialNode.Specular) {\r\n            parameters.specular = new Color().fromArray(\r\n                materialNode.Specular.value\r\n            );\r\n        } else if (\r\n            materialNode.SpecularColor &&\r\n            materialNode.SpecularColor.type === \"Color\"\r\n        ) {\r\n            // The blender exporter exports specular color here instead of in materialNode.Specular\r\n            parameters.specular = new Color().fromArray(\r\n                materialNode.SpecularColor.value\r\n            );\r\n        }\r\n\r\n        const scope = this;\r\n        connections.get(ID).children.forEach(function (child) {\r\n            const type = child.relationship;\r\n\r\n            switch (type) {\r\n                case \"Bump\":\r\n                    parameters.bumpMap = scope.getTexture(textureMap, child.ID);\r\n                    break;\r\n\r\n                case \"Maya|TEX_ao_map\":\r\n                    parameters.aoMap = scope.getTexture(textureMap, child.ID);\r\n                    break;\r\n\r\n                case \"DiffuseColor\":\r\n                case \"Maya|TEX_color_map\":\r\n                    parameters.map = scope.getTexture(textureMap, child.ID);\r\n                    if (parameters.map !== undefined) {\r\n                        parameters.map.encoding = sRGBEncoding;\r\n                    }\r\n                    break;\r\n\r\n                case \"DisplacementColor\":\r\n                    parameters.displacementMap = scope.getTexture(\r\n                        textureMap,\r\n                        child.ID\r\n                    );\r\n                    break;\r\n\r\n                case \"EmissiveColor\":\r\n                    parameters.emissiveMap = scope.getTexture(\r\n                        textureMap,\r\n                        child.ID\r\n                    );\r\n                    if (parameters.emissiveMap !== undefined) {\r\n                        parameters.emissiveMap.encoding = sRGBEncoding;\r\n                    }\r\n                    break;\r\n\r\n                case \"NormalMap\":\r\n                case \"Maya|TEX_normal_map\":\r\n                    parameters.normalMap = scope.getTexture(\r\n                        textureMap,\r\n                        child.ID\r\n                    );\r\n                    break;\r\n\r\n                case \"ReflectionColor\":\r\n                    parameters.envMap = scope.getTexture(textureMap, child.ID);\r\n                    if (parameters.envMap !== undefined) {\r\n                        parameters.envMap.mapping =\r\n                            EquirectangularReflectionMapping;\r\n                        parameters.envMap.encoding = sRGBEncoding;\r\n                    }\r\n                    break;\r\n\r\n                case \"SpecularColor\":\r\n                    parameters.specularMap = scope.getTexture(\r\n                        textureMap,\r\n                        child.ID\r\n                    );\r\n                    if (parameters.specularMap !== undefined) {\r\n                        parameters.specularMap.encoding = sRGBEncoding;\r\n                    }\r\n                    break;\r\n\r\n                case \"TransparentColor\":\r\n                case \"TransparencyFactor\":\r\n                    parameters.alphaMap = scope.getTexture(\r\n                        textureMap,\r\n                        child.ID\r\n                    );\r\n                    parameters.transparent = true;\r\n                    break;\r\n\r\n                case \"AmbientColor\":\r\n                case \"ShininessExponent\": // AKA glossiness map\r\n                case \"SpecularFactor\": // AKA specularLevel\r\n                case \"VectorDisplacementColor\": // NOTE: Seems to be a copy of DisplacementColor\r\n                default:\r\n                    console.warn(\r\n                        \"THREE.FBXLoader: %s map is not supported in three.js, skipping texture.\",\r\n                        type\r\n                    );\r\n                    break;\r\n            }\r\n        });\r\n\r\n        return parameters;\r\n    }\r\n\r\n    // get a texture from the textureMap for use by a material.\r\n    getTexture(textureMap, id) {\r\n        // if the texture is a layered texture, just use the first layer and issue a warning\r\n        if (\r\n            \"LayeredTexture\" in fbxTree.Objects &&\r\n            id in fbxTree.Objects.LayeredTexture\r\n        ) {\r\n            console.warn(\r\n                \"THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.\"\r\n            );\r\n            id = connections.get(id).children[0].ID;\r\n        }\r\n\r\n        return textureMap.get(id);\r\n    }\r\n\r\n    // Parse nodes in FBXTree.Objects.Deformer\r\n    // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\r\n    // Generates map of Skeleton-like objects for use later when generating and binding skeletons.\r\n    parseDeformers() {\r\n        const skeletons = {};\r\n        const morphTargets = {};\r\n\r\n        if (\"Deformer\" in fbxTree.Objects) {\r\n            const DeformerNodes = fbxTree.Objects.Deformer;\r\n\r\n            for (const nodeID in DeformerNodes) {\r\n                const deformerNode = DeformerNodes[nodeID];\r\n\r\n                const relationships = connections.get(parseInt(nodeID));\r\n\r\n                if (deformerNode.attrType === \"Skin\") {\r\n                    const skeleton = this.parseSkeleton(\r\n                        relationships,\r\n                        DeformerNodes\r\n                    );\r\n                    skeleton.ID = nodeID;\r\n\r\n                    if (relationships.parents.length > 1)\r\n                        console.warn(\r\n                            \"THREE.FBXLoader: skeleton attached to more than one geometry is not supported.\"\r\n                        );\r\n                    skeleton.geometryID = relationships.parents[0].ID;\r\n\r\n                    skeletons[nodeID] = skeleton;\r\n                } else if (deformerNode.attrType === \"BlendShape\") {\r\n                    const morphTarget = {\r\n                        id: nodeID,\r\n                    };\r\n\r\n                    morphTarget.rawTargets = this.parseMorphTargets(\r\n                        relationships,\r\n                        DeformerNodes\r\n                    );\r\n                    morphTarget.id = nodeID;\r\n\r\n                    if (relationships.parents.length > 1)\r\n                        console.warn(\r\n                            \"THREE.FBXLoader: morph target attached to more than one geometry is not supported.\"\r\n                        );\r\n\r\n                    morphTargets[nodeID] = morphTarget;\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            skeletons: skeletons,\r\n            morphTargets: morphTargets,\r\n        };\r\n    }\r\n\r\n    // Parse single nodes in FBXTree.Objects.Deformer\r\n    // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\r\n    // Each skin node represents a skeleton and each cluster node represents a bone\r\n    parseSkeleton(relationships, deformerNodes) {\r\n        const rawBones = [];\r\n\r\n        relationships.children.forEach(function (child) {\r\n            const boneNode = deformerNodes[child.ID];\r\n\r\n            if (boneNode.attrType !== \"Cluster\") return;\r\n\r\n            const rawBone = {\r\n                ID: child.ID,\r\n                indices: [],\r\n                weights: [],\r\n                transformLink: new Matrix4().fromArray(\r\n                    boneNode.TransformLink.a\r\n                ),\r\n                // transform: new Matrix4().fromArray( boneNode.Transform.a ),\r\n                // linkMode: boneNode.Mode,\r\n            };\r\n\r\n            if (\"Indexes\" in boneNode) {\r\n                rawBone.indices = boneNode.Indexes.a;\r\n                rawBone.weights = boneNode.Weights.a;\r\n            }\r\n\r\n            rawBones.push(rawBone);\r\n        });\r\n\r\n        return {\r\n            rawBones: rawBones,\r\n            bones: [],\r\n        };\r\n    }\r\n\r\n    // The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\r\n    parseMorphTargets(relationships, deformerNodes) {\r\n        const rawMorphTargets = [];\r\n\r\n        for (let i = 0; i < relationships.children.length; i++) {\r\n            const child = relationships.children[i];\r\n\r\n            const morphTargetNode = deformerNodes[child.ID];\r\n\r\n            const rawMorphTarget = {\r\n                name: morphTargetNode.attrName,\r\n                initialWeight: morphTargetNode.DeformPercent,\r\n                id: morphTargetNode.id,\r\n                fullWeights: morphTargetNode.FullWeights.a,\r\n            };\r\n\r\n            if (morphTargetNode.attrType !== \"BlendShapeChannel\") return;\r\n\r\n            rawMorphTarget.geoID = connections\r\n                .get(parseInt(child.ID))\r\n                .children.filter(function (child) {\r\n                    return child.relationship === undefined;\r\n                })[0].ID;\r\n\r\n            rawMorphTargets.push(rawMorphTarget);\r\n        }\r\n\r\n        return rawMorphTargets;\r\n    }\r\n\r\n    // create the main Group() to be returned by the loader\r\n    parseScene(deformers, geometryMap, materialMap) {\r\n        sceneGraph = new Group();\r\n\r\n        const modelMap = this.parseModels(\r\n            deformers.skeletons,\r\n            geometryMap,\r\n            materialMap\r\n        );\r\n\r\n        const modelNodes = fbxTree.Objects.Model;\r\n\r\n        const scope = this;\r\n        modelMap.forEach(function (model) {\r\n            const modelNode = modelNodes[model.ID];\r\n            scope.setLookAtProperties(model, modelNode);\r\n\r\n            const parentConnections = connections.get(model.ID).parents;\r\n\r\n            parentConnections.forEach(function (connection) {\r\n                const parent = modelMap.get(connection.ID);\r\n                if (parent !== undefined) parent.add(model);\r\n            });\r\n\r\n            if (model.parent === null) {\r\n                sceneGraph.add(model);\r\n            }\r\n        });\r\n\r\n        this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);\r\n\r\n        this.createAmbientLight();\r\n\r\n        this.setupMorphMaterials();\r\n\r\n        sceneGraph.traverse(function (node) {\r\n            if (node.userData.transformData) {\r\n                if (node.parent) {\r\n                    node.userData.transformData.parentMatrix =\r\n                        node.parent.matrix;\r\n                    node.userData.transformData.parentMatrixWorld =\r\n                        node.parent.matrixWorld;\r\n                }\r\n\r\n                const transform = generateTransform(\r\n                    node.userData.transformData\r\n                );\r\n\r\n                node.applyMatrix4(transform);\r\n                node.updateWorldMatrix();\r\n            }\r\n        });\r\n\r\n        const animations = new AnimationParser().parse();\r\n\r\n        // if all the models where already combined in a single group, just return that\r\n        if (\r\n            sceneGraph.children.length === 1 &&\r\n            sceneGraph.children[0].isGroup\r\n        ) {\r\n            sceneGraph.children[0].animations = animations;\r\n            sceneGraph = sceneGraph.children[0];\r\n        }\r\n\r\n        sceneGraph.animations = animations;\r\n    }\r\n\r\n    // parse nodes in FBXTree.Objects.Model\r\n    parseModels(skeletons, geometryMap, materialMap) {\r\n        const modelMap = new Map();\r\n        const modelNodes = fbxTree.Objects.Model;\r\n\r\n        for (const nodeID in modelNodes) {\r\n            const id = parseInt(nodeID);\r\n            const node = modelNodes[nodeID];\r\n            const relationships = connections.get(id);\r\n\r\n            let model = this.buildSkeleton(\r\n                relationships,\r\n                skeletons,\r\n                id,\r\n                node.attrName\r\n            );\r\n\r\n            if (!model) {\r\n                switch (node.attrType) {\r\n                    case \"Camera\":\r\n                        model = this.createCamera(relationships);\r\n                        break;\r\n                    case \"Light\":\r\n                        model = this.createLight(relationships);\r\n                        break;\r\n                    case \"Mesh\":\r\n                        model = this.createMesh(\r\n                            relationships,\r\n                            geometryMap,\r\n                            materialMap\r\n                        );\r\n                        break;\r\n                    case \"NurbsCurve\":\r\n                        model = this.createCurve(relationships, geometryMap);\r\n                        break;\r\n                    case \"LimbNode\":\r\n                    case \"Root\":\r\n                        model = new Bone();\r\n                        break;\r\n                    case \"Null\":\r\n                    default:\r\n                        model = new Group();\r\n                        break;\r\n                }\r\n\r\n                model.name = node.attrName\r\n                    ? PropertyBinding.sanitizeNodeName(node.attrName)\r\n                    : \"\";\r\n\r\n                model.ID = id;\r\n            }\r\n\r\n            this.getTransformData(model, node);\r\n            modelMap.set(id, model);\r\n        }\r\n\r\n        return modelMap;\r\n    }\r\n\r\n    buildSkeleton(relationships, skeletons, id, name) {\r\n        let bone = null;\r\n\r\n        relationships.parents.forEach(function (parent) {\r\n            for (const ID in skeletons) {\r\n                const skeleton = skeletons[ID];\r\n\r\n                skeleton.rawBones.forEach(function (rawBone, i) {\r\n                    if (rawBone.ID === parent.ID) {\r\n                        const subBone = bone;\r\n                        bone = new Bone();\r\n\r\n                        bone.matrixWorld.copy(rawBone.transformLink);\r\n\r\n                        // set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\r\n\r\n                        bone.name = name\r\n                            ? PropertyBinding.sanitizeNodeName(name)\r\n                            : \"\";\r\n                        bone.ID = id;\r\n\r\n                        skeleton.bones[i] = bone;\r\n\r\n                        // In cases where a bone is shared between multiple meshes\r\n                        // duplicate the bone here and and it as a child of the first bone\r\n                        if (subBone !== null) {\r\n                            bone.add(subBone);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        return bone;\r\n    }\r\n\r\n    // create a PerspectiveCamera or OrthographicCamera\r\n    createCamera(relationships) {\r\n        let model;\r\n        let cameraAttribute;\r\n\r\n        relationships.children.forEach(function (child) {\r\n            const attr = fbxTree.Objects.NodeAttribute[child.ID];\r\n\r\n            if (attr !== undefined) {\r\n                cameraAttribute = attr;\r\n            }\r\n        });\r\n\r\n        if (cameraAttribute === undefined) {\r\n            model = new Object3D();\r\n        } else {\r\n            let type = 0;\r\n            if (\r\n                cameraAttribute.CameraProjectionType !== undefined &&\r\n                cameraAttribute.CameraProjectionType.value === 1\r\n            ) {\r\n                type = 1;\r\n            }\r\n\r\n            let nearClippingPlane = 1;\r\n            if (cameraAttribute.NearPlane !== undefined) {\r\n                nearClippingPlane = cameraAttribute.NearPlane.value / 1000;\r\n            }\r\n\r\n            let farClippingPlane = 1000;\r\n            if (cameraAttribute.FarPlane !== undefined) {\r\n                farClippingPlane = cameraAttribute.FarPlane.value / 1000;\r\n            }\r\n\r\n            let width = window.innerWidth;\r\n            let height = window.innerHeight;\r\n\r\n            if (\r\n                cameraAttribute.AspectWidth !== undefined &&\r\n                cameraAttribute.AspectHeight !== undefined\r\n            ) {\r\n                width = cameraAttribute.AspectWidth.value;\r\n                height = cameraAttribute.AspectHeight.value;\r\n            }\r\n\r\n            const aspect = width / height;\r\n\r\n            let fov = 45;\r\n            if (cameraAttribute.FieldOfView !== undefined) {\r\n                fov = cameraAttribute.FieldOfView.value;\r\n            }\r\n\r\n            const focalLength = cameraAttribute.FocalLength\r\n                ? cameraAttribute.FocalLength.value\r\n                : null;\r\n\r\n            switch (type) {\r\n                case 0: // Perspective\r\n                    model = new PerspectiveCamera(\r\n                        fov,\r\n                        aspect,\r\n                        nearClippingPlane,\r\n                        farClippingPlane\r\n                    );\r\n                    if (focalLength !== null) model.setFocalLength(focalLength);\r\n                    break;\r\n\r\n                case 1: // Orthographic\r\n                    model = new OrthographicCamera(\r\n                        -width / 2,\r\n                        width / 2,\r\n                        height / 2,\r\n                        -height / 2,\r\n                        nearClippingPlane,\r\n                        farClippingPlane\r\n                    );\r\n                    break;\r\n\r\n                default:\r\n                    console.warn(\r\n                        \"THREE.FBXLoader: Unknown camera type \" + type + \".\"\r\n                    );\r\n                    model = new Object3D();\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return model;\r\n    }\r\n\r\n    // Create a DirectionalLight, PointLight or SpotLight\r\n    createLight(relationships) {\r\n        let model;\r\n        let lightAttribute;\r\n\r\n        relationships.children.forEach(function (child) {\r\n            const attr = fbxTree.Objects.NodeAttribute[child.ID];\r\n\r\n            if (attr !== undefined) {\r\n                lightAttribute = attr;\r\n            }\r\n        });\r\n\r\n        if (lightAttribute === undefined) {\r\n            model = new Object3D();\r\n        } else {\r\n            let type;\r\n\r\n            // LightType can be undefined for Point lights\r\n            if (lightAttribute.LightType === undefined) {\r\n                type = 0;\r\n            } else {\r\n                type = lightAttribute.LightType.value;\r\n            }\r\n\r\n            let color = 0xffffff;\r\n\r\n            if (lightAttribute.Color !== undefined) {\r\n                color = new Color().fromArray(lightAttribute.Color.value);\r\n            }\r\n\r\n            let intensity =\r\n                lightAttribute.Intensity === undefined\r\n                    ? 1\r\n                    : lightAttribute.Intensity.value / 100;\r\n\r\n            // light disabled\r\n            if (\r\n                lightAttribute.CastLightOnObject !== undefined &&\r\n                lightAttribute.CastLightOnObject.value === 0\r\n            ) {\r\n                intensity = 0;\r\n            }\r\n\r\n            let distance = 0;\r\n            if (lightAttribute.FarAttenuationEnd !== undefined) {\r\n                if (\r\n                    lightAttribute.EnableFarAttenuation !== undefined &&\r\n                    lightAttribute.EnableFarAttenuation.value === 0\r\n                ) {\r\n                    distance = 0;\r\n                } else {\r\n                    distance = lightAttribute.FarAttenuationEnd.value;\r\n                }\r\n            }\r\n\r\n            // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\r\n            const decay = 1;\r\n\r\n            switch (type) {\r\n                case 0: // Point\r\n                    model = new PointLight(color, intensity, distance, decay);\r\n                    break;\r\n\r\n                case 1: // Directional\r\n                    model = new DirectionalLight(color, intensity);\r\n                    break;\r\n\r\n                case 2: // Spot\r\n                    let angle = Math.PI / 3;\r\n\r\n                    if (lightAttribute.InnerAngle !== undefined) {\r\n                        angle = MathUtils.degToRad(\r\n                            lightAttribute.InnerAngle.value\r\n                        );\r\n                    }\r\n\r\n                    let penumbra = 0;\r\n                    if (lightAttribute.OuterAngle !== undefined) {\r\n                        // TODO: this is not correct - FBX calculates outer and inner angle in degrees\r\n                        // with OuterAngle > InnerAngle && OuterAngle <= Math.PI\r\n                        // while three.js uses a penumbra between (0, 1) to attenuate the inner angle\r\n                        penumbra = MathUtils.degToRad(\r\n                            lightAttribute.OuterAngle.value\r\n                        );\r\n                        penumbra = Math.max(penumbra, 1);\r\n                    }\r\n\r\n                    model = new SpotLight(\r\n                        color,\r\n                        intensity,\r\n                        distance,\r\n                        angle,\r\n                        penumbra,\r\n                        decay\r\n                    );\r\n                    break;\r\n\r\n                default:\r\n                    console.warn(\r\n                        \"THREE.FBXLoader: Unknown light type \" +\r\n                            lightAttribute.LightType.value +\r\n                            \", defaulting to a PointLight.\"\r\n                    );\r\n                    model = new PointLight(color, intensity);\r\n                    break;\r\n            }\r\n\r\n            if (\r\n                lightAttribute.CastShadows !== undefined &&\r\n                lightAttribute.CastShadows.value === 1\r\n            ) {\r\n                model.castShadow = true;\r\n            }\r\n        }\r\n\r\n        return model;\r\n    }\r\n\r\n    createMesh(relationships, geometryMap, materialMap) {\r\n        let model;\r\n        let geometry = null;\r\n        let material = null;\r\n        const materials = [];\r\n\r\n        // get geometry and materials(s) from connections\r\n        relationships.children.forEach(function (child) {\r\n            if (geometryMap.has(child.ID)) {\r\n                geometry = geometryMap.get(child.ID);\r\n            }\r\n\r\n            if (materialMap.has(child.ID)) {\r\n                materials.push(materialMap.get(child.ID));\r\n            }\r\n        });\r\n\r\n        if (materials.length > 1) {\r\n            material = materials;\r\n        } else if (materials.length > 0) {\r\n            material = materials[0];\r\n        } else {\r\n            material = new MeshPhongMaterial({ color: 0xcccccc });\r\n            materials.push(material);\r\n        }\r\n\r\n        if (\"color\" in geometry.attributes) {\r\n            materials.forEach(function (material) {\r\n                material.vertexColors = true;\r\n            });\r\n        }\r\n\r\n        if (geometry.FBX_Deformer) {\r\n            model = new SkinnedMesh(geometry, material);\r\n            model.normalizeSkinWeights();\r\n        } else {\r\n            model = new Mesh(geometry, material);\r\n        }\r\n\r\n        return model;\r\n    }\r\n\r\n    createCurve(relationships, geometryMap) {\r\n        const geometry = relationships.children.reduce(function (geo, child) {\r\n            if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);\r\n\r\n            return geo;\r\n        }, null);\r\n\r\n        // FBX does not list materials for Nurbs lines, so we'll just put our own in here.\r\n        const material = new LineBasicMaterial({\r\n            color: 0x3300ff,\r\n            linewidth: 1,\r\n        });\r\n        return new Line(geometry, material);\r\n    }\r\n\r\n    // parse the model node for transform data\r\n    getTransformData(model, modelNode) {\r\n        const transformData = {};\r\n\r\n        if (\"InheritType\" in modelNode)\r\n            transformData.inheritType = parseInt(modelNode.InheritType.value);\r\n\r\n        if (\"RotationOrder\" in modelNode)\r\n            transformData.eulerOrder = getEulerOrder(\r\n                modelNode.RotationOrder.value\r\n            );\r\n        else transformData.eulerOrder = \"ZYX\";\r\n\r\n        if (\"Lcl_Translation\" in modelNode)\r\n            transformData.translation = modelNode.Lcl_Translation.value;\r\n\r\n        if (\"PreRotation\" in modelNode)\r\n            transformData.preRotation = modelNode.PreRotation.value;\r\n        if (\"Lcl_Rotation\" in modelNode)\r\n            transformData.rotation = modelNode.Lcl_Rotation.value;\r\n        if (\"PostRotation\" in modelNode)\r\n            transformData.postRotation = modelNode.PostRotation.value;\r\n\r\n        if (\"Lcl_Scaling\" in modelNode)\r\n            transformData.scale = modelNode.Lcl_Scaling.value;\r\n\r\n        if (\"ScalingOffset\" in modelNode)\r\n            transformData.scalingOffset = modelNode.ScalingOffset.value;\r\n        if (\"ScalingPivot\" in modelNode)\r\n            transformData.scalingPivot = modelNode.ScalingPivot.value;\r\n\r\n        if (\"RotationOffset\" in modelNode)\r\n            transformData.rotationOffset = modelNode.RotationOffset.value;\r\n        if (\"RotationPivot\" in modelNode)\r\n            transformData.rotationPivot = modelNode.RotationPivot.value;\r\n\r\n        model.userData.transformData = transformData;\r\n    }\r\n\r\n    setLookAtProperties(model, modelNode) {\r\n        if (\"LookAtProperty\" in modelNode) {\r\n            const children = connections.get(model.ID).children;\r\n\r\n            children.forEach(function (child) {\r\n                if (child.relationship === \"LookAtProperty\") {\r\n                    const lookAtTarget = fbxTree.Objects.Model[child.ID];\r\n\r\n                    if (\"Lcl_Translation\" in lookAtTarget) {\r\n                        const pos = lookAtTarget.Lcl_Translation.value;\r\n\r\n                        // DirectionalLight, SpotLight\r\n                        if (model.target !== undefined) {\r\n                            model.target.position.fromArray(pos);\r\n                            sceneGraph.add(model.target);\r\n                        } else {\r\n                            // Cameras and other Object3Ds\r\n\r\n                            model.lookAt(new Vector3().fromArray(pos));\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    bindSkeleton(skeletons, geometryMap, modelMap) {\r\n        const bindMatrices = this.parsePoseNodes();\r\n\r\n        for (const ID in skeletons) {\r\n            const skeleton = skeletons[ID];\r\n\r\n            const parents = connections.get(parseInt(skeleton.ID)).parents;\r\n\r\n            parents.forEach(function (parent) {\r\n                if (geometryMap.has(parent.ID)) {\r\n                    const geoID = parent.ID;\r\n                    const geoRelationships = connections.get(geoID);\r\n\r\n                    geoRelationships.parents.forEach(function (geoConnParent) {\r\n                        if (modelMap.has(geoConnParent.ID)) {\r\n                            const model = modelMap.get(geoConnParent.ID);\r\n\r\n                            model.bind(\r\n                                new Skeleton(skeleton.bones),\r\n                                bindMatrices[geoConnParent.ID]\r\n                            );\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    parsePoseNodes() {\r\n        const bindMatrices = {};\r\n\r\n        if (\"Pose\" in fbxTree.Objects) {\r\n            const BindPoseNode = fbxTree.Objects.Pose;\r\n\r\n            for (const nodeID in BindPoseNode) {\r\n                if (BindPoseNode[nodeID].attrType === \"BindPose\") {\r\n                    const poseNodes = BindPoseNode[nodeID].PoseNode;\r\n\r\n                    if (Array.isArray(poseNodes)) {\r\n                        poseNodes.forEach(function (poseNode) {\r\n                            bindMatrices[poseNode.Node] =\r\n                                new Matrix4().fromArray(poseNode.Matrix.a);\r\n                        });\r\n                    } else {\r\n                        bindMatrices[poseNodes.Node] = new Matrix4().fromArray(\r\n                            poseNodes.Matrix.a\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return bindMatrices;\r\n    }\r\n\r\n    // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\r\n    createAmbientLight() {\r\n        if (\r\n            \"GlobalSettings\" in fbxTree &&\r\n            \"AmbientColor\" in fbxTree.GlobalSettings\r\n        ) {\r\n            const ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\r\n            const r = ambientColor[0];\r\n            const g = ambientColor[1];\r\n            const b = ambientColor[2];\r\n\r\n            if (r !== 0 || g !== 0 || b !== 0) {\r\n                const color = new Color(r, g, b);\r\n                sceneGraph.add(new AmbientLight(color, 1));\r\n            }\r\n        }\r\n    }\r\n\r\n    setupMorphMaterials() {\r\n        const scope = this;\r\n        sceneGraph.traverse(function (child) {\r\n            if (child.isMesh) {\r\n                if (\r\n                    child.geometry.morphAttributes.position &&\r\n                    child.geometry.morphAttributes.position.length\r\n                ) {\r\n                    if (Array.isArray(child.material)) {\r\n                        child.material.forEach(function (material, i) {\r\n                            scope.setupMorphMaterial(child, material, i);\r\n                        });\r\n                    } else {\r\n                        scope.setupMorphMaterial(child, child.material);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    setupMorphMaterial(child, material, index) {\r\n        const uuid = child.uuid;\r\n        const matUuid = material.uuid;\r\n\r\n        // if a geometry has morph targets, it cannot share the material with other geometries\r\n        let sharedMat = false;\r\n\r\n        sceneGraph.traverse(function (node) {\r\n            if (node.isMesh) {\r\n                if (Array.isArray(node.material)) {\r\n                    node.material.forEach(function (mat) {\r\n                        if (mat.uuid === matUuid && node.uuid !== uuid)\r\n                            sharedMat = true;\r\n                    });\r\n                } else if (node.material.uuid === matUuid && node.uuid !== uuid)\r\n                    sharedMat = true;\r\n            }\r\n        });\r\n\r\n        if (sharedMat === true) {\r\n            const clonedMat = material.clone();\r\n            clonedMat.morphTargets = true;\r\n\r\n            if (index === undefined) child.material = clonedMat;\r\n            else child.material[index] = clonedMat;\r\n        } else material.morphTargets = true;\r\n    }\r\n}\r\n\r\n// parse Geometry data from FBXTree and return map of BufferGeometries\r\nclass GeometryParser {\r\n    // Parse nodes in FBXTree.Objects.Geometry\r\n    parse(deformers) {\r\n        const geometryMap = new Map();\r\n\r\n        if (\"Geometry\" in fbxTree.Objects) {\r\n            const geoNodes = fbxTree.Objects.Geometry;\r\n\r\n            for (const nodeID in geoNodes) {\r\n                const relationships = connections.get(parseInt(nodeID));\r\n                const geo = this.parseGeometry(\r\n                    relationships,\r\n                    geoNodes[nodeID],\r\n                    deformers\r\n                );\r\n\r\n                geometryMap.set(parseInt(nodeID), geo);\r\n            }\r\n        }\r\n\r\n        return geometryMap;\r\n    }\r\n\r\n    // Parse single node in FBXTree.Objects.Geometry\r\n    parseGeometry(relationships, geoNode, deformers) {\r\n        switch (geoNode.attrType) {\r\n            case \"Mesh\":\r\n                return this.parseMeshGeometry(\r\n                    relationships,\r\n                    geoNode,\r\n                    deformers\r\n                );\r\n                break;\r\n\r\n            case \"NurbsCurve\":\r\n                return this.parseNurbsGeometry(geoNode);\r\n                break;\r\n        }\r\n    }\r\n\r\n    // Parse single node mesh geometry in FBXTree.Objects.Geometry\r\n    parseMeshGeometry(relationships, geoNode, deformers) {\r\n        const skeletons = deformers.skeletons;\r\n        const morphTargets = [];\r\n\r\n        const modelNodes = relationships.parents.map(function (parent) {\r\n            return fbxTree.Objects.Model[parent.ID];\r\n        });\r\n\r\n        // don't create geometry if it is not associated with any models\r\n        if (modelNodes.length === 0) return;\r\n\r\n        const skeleton = relationships.children.reduce(function (\r\n            skeleton,\r\n            child\r\n        ) {\r\n            if (skeletons[child.ID] !== undefined)\r\n                skeleton = skeletons[child.ID];\r\n\r\n            return skeleton;\r\n        },\r\n        null);\r\n\r\n        relationships.children.forEach(function (child) {\r\n            if (deformers.morphTargets[child.ID] !== undefined) {\r\n                morphTargets.push(deformers.morphTargets[child.ID]);\r\n            }\r\n        });\r\n\r\n        // Assume one model and get the preRotation from that\r\n        // if there is more than one model associated with the geometry this may cause problems\r\n        const modelNode = modelNodes[0];\r\n\r\n        const transformData = {};\r\n\r\n        if (\"RotationOrder\" in modelNode)\r\n            transformData.eulerOrder = getEulerOrder(\r\n                modelNode.RotationOrder.value\r\n            );\r\n        if (\"InheritType\" in modelNode)\r\n            transformData.inheritType = parseInt(modelNode.InheritType.value);\r\n\r\n        if (\"GeometricTranslation\" in modelNode)\r\n            transformData.translation = modelNode.GeometricTranslation.value;\r\n        if (\"GeometricRotation\" in modelNode)\r\n            transformData.rotation = modelNode.GeometricRotation.value;\r\n        if (\"GeometricScaling\" in modelNode)\r\n            transformData.scale = modelNode.GeometricScaling.value;\r\n\r\n        const transform = generateTransform(transformData);\r\n\r\n        return this.genGeometry(geoNode, skeleton, morphTargets, transform);\r\n    }\r\n\r\n    // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry\r\n    genGeometry(geoNode, skeleton, morphTargets, preTransform) {\r\n        const geo = new BufferGeometry();\r\n        if (geoNode.attrName) geo.name = geoNode.attrName;\r\n\r\n        const geoInfo = this.parseGeoNode(geoNode, skeleton);\r\n        const buffers = this.genBuffers(geoInfo);\r\n\r\n        const positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);\r\n\r\n        positionAttribute.applyMatrix4(preTransform);\r\n\r\n        geo.setAttribute(\"position\", positionAttribute);\r\n\r\n        if (buffers.colors.length > 0) {\r\n            geo.setAttribute(\r\n                \"color\",\r\n                new Float32BufferAttribute(buffers.colors, 3)\r\n            );\r\n        }\r\n\r\n        if (skeleton) {\r\n            geo.setAttribute(\r\n                \"skinIndex\",\r\n                new Uint16BufferAttribute(buffers.weightsIndices, 4)\r\n            );\r\n\r\n            geo.setAttribute(\r\n                \"skinWeight\",\r\n                new Float32BufferAttribute(buffers.vertexWeights, 4)\r\n            );\r\n\r\n            // used later to bind the skeleton to the model\r\n            geo.FBX_Deformer = skeleton;\r\n        }\r\n\r\n        if (buffers.normal.length > 0) {\r\n            const normalMatrix = new Matrix3().getNormalMatrix(preTransform);\r\n\r\n            const normalAttribute = new Float32BufferAttribute(\r\n                buffers.normal,\r\n                3\r\n            );\r\n            normalAttribute.applyNormalMatrix(normalMatrix);\r\n\r\n            geo.setAttribute(\"normal\", normalAttribute);\r\n        }\r\n\r\n        buffers.uvs.forEach(function (uvBuffer, i) {\r\n            // subsequent uv buffers are called 'uv1', 'uv2', ...\r\n            let name = \"uv\" + (i + 1).toString();\r\n\r\n            // the first uv buffer is just called 'uv'\r\n            if (i === 0) {\r\n                name = \"uv\";\r\n            }\r\n\r\n            geo.setAttribute(\r\n                name,\r\n                new Float32BufferAttribute(buffers.uvs[i], 2)\r\n            );\r\n        });\r\n\r\n        if (geoInfo.material && geoInfo.material.mappingType !== \"AllSame\") {\r\n            // Convert the material indices of each vertex into rendering groups on the geometry.\r\n            let prevMaterialIndex = buffers.materialIndex[0];\r\n            let startIndex = 0;\r\n\r\n            buffers.materialIndex.forEach(function (currentIndex, i) {\r\n                if (currentIndex !== prevMaterialIndex) {\r\n                    geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\r\n\r\n                    prevMaterialIndex = currentIndex;\r\n                    startIndex = i;\r\n                }\r\n            });\r\n\r\n            // the loop above doesn't add the last group, do that here.\r\n            if (geo.groups.length > 0) {\r\n                const lastGroup = geo.groups[geo.groups.length - 1];\r\n                const lastIndex = lastGroup.start + lastGroup.count;\r\n\r\n                if (lastIndex !== buffers.materialIndex.length) {\r\n                    geo.addGroup(\r\n                        lastIndex,\r\n                        buffers.materialIndex.length - lastIndex,\r\n                        prevMaterialIndex\r\n                    );\r\n                }\r\n            }\r\n\r\n            // case where there are multiple materials but the whole geometry is only\r\n            // using one of them\r\n            if (geo.groups.length === 0) {\r\n                geo.addGroup(\r\n                    0,\r\n                    buffers.materialIndex.length,\r\n                    buffers.materialIndex[0]\r\n                );\r\n            }\r\n        }\r\n\r\n        this.addMorphTargets(geo, geoNode, morphTargets, preTransform);\r\n\r\n        return geo;\r\n    }\r\n\r\n    parseGeoNode(geoNode, skeleton) {\r\n        const geoInfo = {};\r\n\r\n        geoInfo.vertexPositions =\r\n            geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];\r\n        geoInfo.vertexIndices =\r\n            geoNode.PolygonVertexIndex !== undefined\r\n                ? geoNode.PolygonVertexIndex.a\r\n                : [];\r\n\r\n        if (geoNode.LayerElementColor) {\r\n            geoInfo.color = this.parseVertexColors(\r\n                geoNode.LayerElementColor[0]\r\n            );\r\n        }\r\n\r\n        if (geoNode.LayerElementMaterial) {\r\n            geoInfo.material = this.parseMaterialIndices(\r\n                geoNode.LayerElementMaterial[0]\r\n            );\r\n        }\r\n\r\n        if (geoNode.LayerElementNormal) {\r\n            geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);\r\n        }\r\n\r\n        if (geoNode.LayerElementUV) {\r\n            geoInfo.uv = [];\r\n\r\n            let i = 0;\r\n            while (geoNode.LayerElementUV[i]) {\r\n                if (geoNode.LayerElementUV[i].UV) {\r\n                    geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));\r\n                }\r\n\r\n                i++;\r\n            }\r\n        }\r\n\r\n        geoInfo.weightTable = {};\r\n\r\n        if (skeleton !== null) {\r\n            geoInfo.skeleton = skeleton;\r\n\r\n            skeleton.rawBones.forEach(function (rawBone, i) {\r\n                // loop over the bone's vertex indices and weights\r\n                rawBone.indices.forEach(function (index, j) {\r\n                    if (geoInfo.weightTable[index] === undefined)\r\n                        geoInfo.weightTable[index] = [];\r\n\r\n                    geoInfo.weightTable[index].push({\r\n                        id: i,\r\n                        weight: rawBone.weights[j],\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        return geoInfo;\r\n    }\r\n\r\n    genBuffers(geoInfo) {\r\n        const buffers = {\r\n            vertex: [],\r\n            normal: [],\r\n            colors: [],\r\n            uvs: [],\r\n            materialIndex: [],\r\n            vertexWeights: [],\r\n            weightsIndices: [],\r\n        };\r\n\r\n        let polygonIndex = 0;\r\n        let faceLength = 0;\r\n        let displayedWeightsWarning = false;\r\n\r\n        // these will hold data for a single face\r\n        let facePositionIndexes = [];\r\n        let faceNormals = [];\r\n        let faceColors = [];\r\n        let faceUVs = [];\r\n        let faceWeights = [];\r\n        let faceWeightIndices = [];\r\n\r\n        const scope = this;\r\n        geoInfo.vertexIndices.forEach(function (\r\n            vertexIndex,\r\n            polygonVertexIndex\r\n        ) {\r\n            let materialIndex;\r\n            let endOfFace = false;\r\n\r\n            // Face index and vertex index arrays are combined in a single array\r\n            // A cube with quad faces looks like this:\r\n            // PolygonVertexIndex: *24 {\r\n            //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\r\n            //  }\r\n            // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\r\n            // to find index of last vertex bit shift the index: ^ - 1\r\n            if (vertexIndex < 0) {\r\n                vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1\r\n                endOfFace = true;\r\n            }\r\n\r\n            let weightIndices = [];\r\n            let weights = [];\r\n\r\n            facePositionIndexes.push(\r\n                vertexIndex * 3,\r\n                vertexIndex * 3 + 1,\r\n                vertexIndex * 3 + 2\r\n            );\r\n\r\n            if (geoInfo.color) {\r\n                const data = getData(\r\n                    polygonVertexIndex,\r\n                    polygonIndex,\r\n                    vertexIndex,\r\n                    geoInfo.color\r\n                );\r\n\r\n                faceColors.push(data[0], data[1], data[2]);\r\n            }\r\n\r\n            if (geoInfo.skeleton) {\r\n                if (geoInfo.weightTable[vertexIndex] !== undefined) {\r\n                    geoInfo.weightTable[vertexIndex].forEach(function (wt) {\r\n                        weights.push(wt.weight);\r\n                        weightIndices.push(wt.id);\r\n                    });\r\n                }\r\n\r\n                if (weights.length > 4) {\r\n                    if (!displayedWeightsWarning) {\r\n                        console.warn(\r\n                            \"THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.\"\r\n                        );\r\n                        displayedWeightsWarning = true;\r\n                    }\r\n\r\n                    const wIndex = [0, 0, 0, 0];\r\n                    const Weight = [0, 0, 0, 0];\r\n\r\n                    weights.forEach(function (weight, weightIndex) {\r\n                        let currentWeight = weight;\r\n                        let currentIndex = weightIndices[weightIndex];\r\n\r\n                        Weight.forEach(function (\r\n                            comparedWeight,\r\n                            comparedWeightIndex,\r\n                            comparedWeightArray\r\n                        ) {\r\n                            if (currentWeight > comparedWeight) {\r\n                                comparedWeightArray[comparedWeightIndex] =\r\n                                    currentWeight;\r\n                                currentWeight = comparedWeight;\r\n\r\n                                const tmp = wIndex[comparedWeightIndex];\r\n                                wIndex[comparedWeightIndex] = currentIndex;\r\n                                currentIndex = tmp;\r\n                            }\r\n                        });\r\n                    });\r\n\r\n                    weightIndices = wIndex;\r\n                    weights = Weight;\r\n                }\r\n\r\n                // if the weight array is shorter than 4 pad with 0s\r\n                while (weights.length < 4) {\r\n                    weights.push(0);\r\n                    weightIndices.push(0);\r\n                }\r\n\r\n                for (let i = 0; i < 4; ++i) {\r\n                    faceWeights.push(weights[i]);\r\n                    faceWeightIndices.push(weightIndices[i]);\r\n                }\r\n            }\r\n\r\n            if (geoInfo.normal) {\r\n                const data = getData(\r\n                    polygonVertexIndex,\r\n                    polygonIndex,\r\n                    vertexIndex,\r\n                    geoInfo.normal\r\n                );\r\n\r\n                faceNormals.push(data[0], data[1], data[2]);\r\n            }\r\n\r\n            if (\r\n                geoInfo.material &&\r\n                geoInfo.material.mappingType !== \"AllSame\"\r\n            ) {\r\n                materialIndex = getData(\r\n                    polygonVertexIndex,\r\n                    polygonIndex,\r\n                    vertexIndex,\r\n                    geoInfo.material\r\n                )[0];\r\n            }\r\n\r\n            if (geoInfo.uv) {\r\n                geoInfo.uv.forEach(function (uv, i) {\r\n                    const data = getData(\r\n                        polygonVertexIndex,\r\n                        polygonIndex,\r\n                        vertexIndex,\r\n                        uv\r\n                    );\r\n\r\n                    if (faceUVs[i] === undefined) {\r\n                        faceUVs[i] = [];\r\n                    }\r\n\r\n                    faceUVs[i].push(data[0]);\r\n                    faceUVs[i].push(data[1]);\r\n                });\r\n            }\r\n\r\n            faceLength++;\r\n\r\n            if (endOfFace) {\r\n                scope.genFace(\r\n                    buffers,\r\n                    geoInfo,\r\n                    facePositionIndexes,\r\n                    materialIndex,\r\n                    faceNormals,\r\n                    faceColors,\r\n                    faceUVs,\r\n                    faceWeights,\r\n                    faceWeightIndices,\r\n                    faceLength\r\n                );\r\n\r\n                polygonIndex++;\r\n                faceLength = 0;\r\n\r\n                // reset arrays for the next face\r\n                facePositionIndexes = [];\r\n                faceNormals = [];\r\n                faceColors = [];\r\n                faceUVs = [];\r\n                faceWeights = [];\r\n                faceWeightIndices = [];\r\n            }\r\n        });\r\n\r\n        return buffers;\r\n    }\r\n\r\n    // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\r\n    genFace(\r\n        buffers,\r\n        geoInfo,\r\n        facePositionIndexes,\r\n        materialIndex,\r\n        faceNormals,\r\n        faceColors,\r\n        faceUVs,\r\n        faceWeights,\r\n        faceWeightIndices,\r\n        faceLength\r\n    ) {\r\n        for (let i = 2; i < faceLength; i++) {\r\n            buffers.vertex.push(\r\n                geoInfo.vertexPositions[facePositionIndexes[0]]\r\n            );\r\n            buffers.vertex.push(\r\n                geoInfo.vertexPositions[facePositionIndexes[1]]\r\n            );\r\n            buffers.vertex.push(\r\n                geoInfo.vertexPositions[facePositionIndexes[2]]\r\n            );\r\n\r\n            buffers.vertex.push(\r\n                geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]\r\n            );\r\n            buffers.vertex.push(\r\n                geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]\r\n            );\r\n            buffers.vertex.push(\r\n                geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]\r\n            );\r\n\r\n            buffers.vertex.push(\r\n                geoInfo.vertexPositions[facePositionIndexes[i * 3]]\r\n            );\r\n            buffers.vertex.push(\r\n                geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]\r\n            );\r\n            buffers.vertex.push(\r\n                geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]\r\n            );\r\n\r\n            if (geoInfo.skeleton) {\r\n                buffers.vertexWeights.push(faceWeights[0]);\r\n                buffers.vertexWeights.push(faceWeights[1]);\r\n                buffers.vertexWeights.push(faceWeights[2]);\r\n                buffers.vertexWeights.push(faceWeights[3]);\r\n\r\n                buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);\r\n                buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);\r\n                buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);\r\n                buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);\r\n\r\n                buffers.vertexWeights.push(faceWeights[i * 4]);\r\n                buffers.vertexWeights.push(faceWeights[i * 4 + 1]);\r\n                buffers.vertexWeights.push(faceWeights[i * 4 + 2]);\r\n                buffers.vertexWeights.push(faceWeights[i * 4 + 3]);\r\n\r\n                buffers.weightsIndices.push(faceWeightIndices[0]);\r\n                buffers.weightsIndices.push(faceWeightIndices[1]);\r\n                buffers.weightsIndices.push(faceWeightIndices[2]);\r\n                buffers.weightsIndices.push(faceWeightIndices[3]);\r\n\r\n                buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);\r\n                buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);\r\n                buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);\r\n                buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);\r\n\r\n                buffers.weightsIndices.push(faceWeightIndices[i * 4]);\r\n                buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);\r\n                buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);\r\n                buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);\r\n            }\r\n\r\n            if (geoInfo.color) {\r\n                buffers.colors.push(faceColors[0]);\r\n                buffers.colors.push(faceColors[1]);\r\n                buffers.colors.push(faceColors[2]);\r\n\r\n                buffers.colors.push(faceColors[(i - 1) * 3]);\r\n                buffers.colors.push(faceColors[(i - 1) * 3 + 1]);\r\n                buffers.colors.push(faceColors[(i - 1) * 3 + 2]);\r\n\r\n                buffers.colors.push(faceColors[i * 3]);\r\n                buffers.colors.push(faceColors[i * 3 + 1]);\r\n                buffers.colors.push(faceColors[i * 3 + 2]);\r\n            }\r\n\r\n            if (\r\n                geoInfo.material &&\r\n                geoInfo.material.mappingType !== \"AllSame\"\r\n            ) {\r\n                buffers.materialIndex.push(materialIndex);\r\n                buffers.materialIndex.push(materialIndex);\r\n                buffers.materialIndex.push(materialIndex);\r\n            }\r\n\r\n            if (geoInfo.normal) {\r\n                buffers.normal.push(faceNormals[0]);\r\n                buffers.normal.push(faceNormals[1]);\r\n                buffers.normal.push(faceNormals[2]);\r\n\r\n                buffers.normal.push(faceNormals[(i - 1) * 3]);\r\n                buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);\r\n                buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);\r\n\r\n                buffers.normal.push(faceNormals[i * 3]);\r\n                buffers.normal.push(faceNormals[i * 3 + 1]);\r\n                buffers.normal.push(faceNormals[i * 3 + 2]);\r\n            }\r\n\r\n            if (geoInfo.uv) {\r\n                geoInfo.uv.forEach(function (uv, j) {\r\n                    if (buffers.uvs[j] === undefined) buffers.uvs[j] = [];\r\n\r\n                    buffers.uvs[j].push(faceUVs[j][0]);\r\n                    buffers.uvs[j].push(faceUVs[j][1]);\r\n\r\n                    buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);\r\n                    buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);\r\n\r\n                    buffers.uvs[j].push(faceUVs[j][i * 2]);\r\n                    buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {\r\n        if (morphTargets.length === 0) return;\r\n\r\n        parentGeo.morphTargetsRelative = true;\r\n\r\n        parentGeo.morphAttributes.position = [];\r\n        // parentGeo.morphAttributes.normal = []; // not implemented\r\n\r\n        const scope = this;\r\n        morphTargets.forEach(function (morphTarget) {\r\n            morphTarget.rawTargets.forEach(function (rawTarget) {\r\n                const morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];\r\n\r\n                if (morphGeoNode !== undefined) {\r\n                    scope.genMorphGeometry(\r\n                        parentGeo,\r\n                        parentGeoNode,\r\n                        morphGeoNode,\r\n                        preTransform,\r\n                        rawTarget.name\r\n                    );\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    // a morph geometry node is similar to a standard  node, and the node is also contained\r\n    // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\r\n    // and a special attribute Index defining which vertices of the original geometry are affected\r\n    // Normal and position attributes only have data for the vertices that are affected by the morph\r\n    genMorphGeometry(\r\n        parentGeo,\r\n        parentGeoNode,\r\n        morphGeoNode,\r\n        preTransform,\r\n        name\r\n    ) {\r\n        const vertexIndices =\r\n            parentGeoNode.PolygonVertexIndex !== undefined\r\n                ? parentGeoNode.PolygonVertexIndex.a\r\n                : [];\r\n\r\n        const morphPositionsSparse =\r\n            morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];\r\n        const indices =\r\n            morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];\r\n\r\n        const length = parentGeo.attributes.position.count * 3;\r\n        const morphPositions = new Float32Array(length);\r\n\r\n        for (let i = 0; i < indices.length; i++) {\r\n            const morphIndex = indices[i] * 3;\r\n\r\n            morphPositions[morphIndex] = morphPositionsSparse[i * 3];\r\n            morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];\r\n            morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];\r\n        }\r\n\r\n        // TODO: add morph normal support\r\n        const morphGeoInfo = {\r\n            vertexIndices: vertexIndices,\r\n            vertexPositions: morphPositions,\r\n        };\r\n\r\n        const morphBuffers = this.genBuffers(morphGeoInfo);\r\n\r\n        const positionAttribute = new Float32BufferAttribute(\r\n            morphBuffers.vertex,\r\n            3\r\n        );\r\n        positionAttribute.name = name || morphGeoNode.attrName;\r\n\r\n        positionAttribute.applyMatrix4(preTransform);\r\n\r\n        parentGeo.morphAttributes.position.push(positionAttribute);\r\n    }\r\n\r\n    // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\r\n    parseNormals(NormalNode) {\r\n        const mappingType = NormalNode.MappingInformationType;\r\n        const referenceType = NormalNode.ReferenceInformationType;\r\n        const buffer = NormalNode.Normals.a;\r\n        let indexBuffer = [];\r\n        if (referenceType === \"IndexToDirect\") {\r\n            if (\"NormalIndex\" in NormalNode) {\r\n                indexBuffer = NormalNode.NormalIndex.a;\r\n            } else if (\"NormalsIndex\" in NormalNode) {\r\n                indexBuffer = NormalNode.NormalsIndex.a;\r\n            }\r\n        }\r\n\r\n        return {\r\n            dataSize: 3,\r\n            buffer: buffer,\r\n            indices: indexBuffer,\r\n            mappingType: mappingType,\r\n            referenceType: referenceType,\r\n        };\r\n    }\r\n\r\n    // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\r\n    parseUVs(UVNode) {\r\n        const mappingType = UVNode.MappingInformationType;\r\n        const referenceType = UVNode.ReferenceInformationType;\r\n        const buffer = UVNode.UV.a;\r\n        let indexBuffer = [];\r\n        if (referenceType === \"IndexToDirect\") {\r\n            indexBuffer = UVNode.UVIndex.a;\r\n        }\r\n\r\n        return {\r\n            dataSize: 2,\r\n            buffer: buffer,\r\n            indices: indexBuffer,\r\n            mappingType: mappingType,\r\n            referenceType: referenceType,\r\n        };\r\n    }\r\n\r\n    // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\r\n    parseVertexColors(ColorNode) {\r\n        const mappingType = ColorNode.MappingInformationType;\r\n        const referenceType = ColorNode.ReferenceInformationType;\r\n        const buffer = ColorNode.Colors.a;\r\n        let indexBuffer = [];\r\n        if (referenceType === \"IndexToDirect\") {\r\n            indexBuffer = ColorNode.ColorIndex.a;\r\n        }\r\n\r\n        return {\r\n            dataSize: 4,\r\n            buffer: buffer,\r\n            indices: indexBuffer,\r\n            mappingType: mappingType,\r\n            referenceType: referenceType,\r\n        };\r\n    }\r\n\r\n    // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\r\n    parseMaterialIndices(MaterialNode) {\r\n        const mappingType = MaterialNode.MappingInformationType;\r\n        const referenceType = MaterialNode.ReferenceInformationType;\r\n\r\n        if (mappingType === \"NoMappingInformation\") {\r\n            return {\r\n                dataSize: 1,\r\n                buffer: [0],\r\n                indices: [0],\r\n                mappingType: \"AllSame\",\r\n                referenceType: referenceType,\r\n            };\r\n        }\r\n\r\n        const materialIndexBuffer = MaterialNode.Materials.a;\r\n\r\n        // Since materials are stored as indices, there's a bit of a mismatch between FBX and what\r\n        // we expect.So we create an intermediate buffer that points to the index in the buffer,\r\n        // for conforming with the other functions we've written for other data.\r\n        const materialIndices = [];\r\n\r\n        for (let i = 0; i < materialIndexBuffer.length; ++i) {\r\n            materialIndices.push(i);\r\n        }\r\n\r\n        return {\r\n            dataSize: 1,\r\n            buffer: materialIndexBuffer,\r\n            indices: materialIndices,\r\n            mappingType: mappingType,\r\n            referenceType: referenceType,\r\n        };\r\n    }\r\n\r\n    // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\r\n    parseNurbsGeometry(geoNode) {\r\n        if (NURBSCurve === undefined) {\r\n            console.error(\r\n                \"THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.\"\r\n            );\r\n            return new BufferGeometry();\r\n        }\r\n\r\n        const order = parseInt(geoNode.Order);\r\n\r\n        if (isNaN(order)) {\r\n            console.error(\r\n                \"THREE.FBXLoader: Invalid Order %s given for geometry ID: %s\",\r\n                geoNode.Order,\r\n                geoNode.id\r\n            );\r\n            return new BufferGeometry();\r\n        }\r\n\r\n        const degree = order - 1;\r\n\r\n        const knots = geoNode.KnotVector.a;\r\n        const controlPoints = [];\r\n        const pointsValues = geoNode.Points.a;\r\n\r\n        for (let i = 0, l = pointsValues.length; i < l; i += 4) {\r\n            controlPoints.push(new Vector4().fromArray(pointsValues, i));\r\n        }\r\n\r\n        let startKnot, endKnot;\r\n\r\n        if (geoNode.Form === \"Closed\") {\r\n            controlPoints.push(controlPoints[0]);\r\n        } else if (geoNode.Form === \"Periodic\") {\r\n            startKnot = degree;\r\n            endKnot = knots.length - 1 - startKnot;\r\n\r\n            for (let i = 0; i < degree; ++i) {\r\n                controlPoints.push(controlPoints[i]);\r\n            }\r\n        }\r\n\r\n        const curve = new NURBSCurve(\r\n            degree,\r\n            knots,\r\n            controlPoints,\r\n            startKnot,\r\n            endKnot\r\n        );\r\n        const points = curve.getPoints(controlPoints.length * 12);\r\n\r\n        return new BufferGeometry().setFromPoints(points);\r\n    }\r\n}\r\n\r\n// parse animation data from FBXTree\r\nclass AnimationParser {\r\n    // take raw animation clips and turn them into three.js animation clips\r\n    parse() {\r\n        const animationClips = [];\r\n\r\n        const rawClips = this.parseClips();\r\n\r\n        if (rawClips !== undefined) {\r\n            for (const key in rawClips) {\r\n                const rawClip = rawClips[key];\r\n\r\n                const clip = this.addClip(rawClip);\r\n\r\n                animationClips.push(clip);\r\n            }\r\n        }\r\n\r\n        return animationClips;\r\n    }\r\n\r\n    parseClips() {\r\n        // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\r\n        // if this is undefined we can safely assume there are no animations\r\n        if (fbxTree.Objects.AnimationCurve === undefined) return undefined;\r\n\r\n        const curveNodesMap = this.parseAnimationCurveNodes();\r\n\r\n        this.parseAnimationCurves(curveNodesMap);\r\n\r\n        const layersMap = this.parseAnimationLayers(curveNodesMap);\r\n        const rawClips = this.parseAnimStacks(layersMap);\r\n\r\n        return rawClips;\r\n    }\r\n\r\n    // parse nodes in FBXTree.Objects.AnimationCurveNode\r\n    // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\r\n    // and is referenced by an AnimationLayer\r\n    parseAnimationCurveNodes() {\r\n        const rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\r\n\r\n        const curveNodesMap = new Map();\r\n\r\n        for (const nodeID in rawCurveNodes) {\r\n            const rawCurveNode = rawCurveNodes[nodeID];\r\n\r\n            if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {\r\n                const curveNode = {\r\n                    id: rawCurveNode.id,\r\n                    attr: rawCurveNode.attrName,\r\n                    curves: {},\r\n                };\r\n\r\n                curveNodesMap.set(curveNode.id, curveNode);\r\n            }\r\n        }\r\n\r\n        return curveNodesMap;\r\n    }\r\n\r\n    // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\r\n    // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\r\n    // axis ( e.g. times and values of x rotation)\r\n    parseAnimationCurves(curveNodesMap) {\r\n        const rawCurves = fbxTree.Objects.AnimationCurve;\r\n\r\n        // TODO: Many values are identical up to roundoff error, but won't be optimised\r\n        // e.g. position times: [0, 0.4, 0. 8]\r\n        // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\r\n        // clearly, this should be optimised to\r\n        // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\r\n        // this shows up in nearly every FBX file, and generally time array is length > 100\r\n\r\n        for (const nodeID in rawCurves) {\r\n            const animationCurve = {\r\n                id: rawCurves[nodeID].id,\r\n                times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\r\n                values: rawCurves[nodeID].KeyValueFloat.a,\r\n            };\r\n\r\n            const relationships = connections.get(animationCurve.id);\r\n\r\n            if (relationships !== undefined) {\r\n                const animationCurveID = relationships.parents[0].ID;\r\n                const animationCurveRelationship =\r\n                    relationships.parents[0].relationship;\r\n\r\n                if (animationCurveRelationship.match(/X/)) {\r\n                    curveNodesMap.get(animationCurveID).curves[\"x\"] =\r\n                        animationCurve;\r\n                } else if (animationCurveRelationship.match(/Y/)) {\r\n                    curveNodesMap.get(animationCurveID).curves[\"y\"] =\r\n                        animationCurve;\r\n                } else if (animationCurveRelationship.match(/Z/)) {\r\n                    curveNodesMap.get(animationCurveID).curves[\"z\"] =\r\n                        animationCurve;\r\n                } else if (\r\n                    animationCurveRelationship.match(/d|DeformPercent/) &&\r\n                    curveNodesMap.has(animationCurveID)\r\n                ) {\r\n                    curveNodesMap.get(animationCurveID).curves[\"morph\"] =\r\n                        animationCurve;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\r\n    // to various AnimationCurveNodes and is referenced by an AnimationStack node\r\n    // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\r\n    parseAnimationLayers(curveNodesMap) {\r\n        const rawLayers = fbxTree.Objects.AnimationLayer;\r\n\r\n        const layersMap = new Map();\r\n\r\n        for (const nodeID in rawLayers) {\r\n            const layerCurveNodes = [];\r\n\r\n            const connection = connections.get(parseInt(nodeID));\r\n\r\n            if (connection !== undefined) {\r\n                // all the animationCurveNodes used in the layer\r\n                const children = connection.children;\r\n\r\n                children.forEach(function (child, i) {\r\n                    if (curveNodesMap.has(child.ID)) {\r\n                        const curveNode = curveNodesMap.get(child.ID);\r\n\r\n                        // check that the curves are defined for at least one axis, otherwise ignore the curveNode\r\n                        if (\r\n                            curveNode.curves.x !== undefined ||\r\n                            curveNode.curves.y !== undefined ||\r\n                            curveNode.curves.z !== undefined\r\n                        ) {\r\n                            if (layerCurveNodes[i] === undefined) {\r\n                                const modelID = connections\r\n                                    .get(child.ID)\r\n                                    .parents.filter(function (parent) {\r\n                                        return (\r\n                                            parent.relationship !== undefined\r\n                                        );\r\n                                    })[0].ID;\r\n\r\n                                if (modelID !== undefined) {\r\n                                    const rawModel =\r\n                                        fbxTree.Objects.Model[\r\n                                            modelID.toString()\r\n                                        ];\r\n\r\n                                    if (rawModel === undefined) {\r\n                                        console.warn(\r\n                                            \"THREE.FBXLoader: Encountered a unused curve.\",\r\n                                            child\r\n                                        );\r\n                                        return;\r\n                                    }\r\n\r\n                                    const node = {\r\n                                        modelName: rawModel.attrName\r\n                                            ? PropertyBinding.sanitizeNodeName(\r\n                                                  rawModel.attrName\r\n                                              )\r\n                                            : \"\",\r\n                                        ID: rawModel.id,\r\n                                        initialPosition: [0, 0, 0],\r\n                                        initialRotation: [0, 0, 0],\r\n                                        initialScale: [1, 1, 1],\r\n                                    };\r\n\r\n                                    sceneGraph.traverse(function (child) {\r\n                                        if (child.ID === rawModel.id) {\r\n                                            node.transform = child.matrix;\r\n\r\n                                            if (child.userData.transformData)\r\n                                                node.eulerOrder =\r\n                                                    child.userData.transformData.eulerOrder;\r\n                                        }\r\n                                    });\r\n\r\n                                    if (!node.transform)\r\n                                        node.transform = new Matrix4();\r\n\r\n                                    // if the animated model is pre rotated, we'll have to apply the pre rotations to every\r\n                                    // animation value as well\r\n                                    if (\"PreRotation\" in rawModel)\r\n                                        node.preRotation =\r\n                                            rawModel.PreRotation.value;\r\n                                    if (\"PostRotation\" in rawModel)\r\n                                        node.postRotation =\r\n                                            rawModel.PostRotation.value;\r\n\r\n                                    layerCurveNodes[i] = node;\r\n                                }\r\n                            }\r\n\r\n                            if (layerCurveNodes[i])\r\n                                layerCurveNodes[i][curveNode.attr] = curveNode;\r\n                        } else if (curveNode.curves.morph !== undefined) {\r\n                            if (layerCurveNodes[i] === undefined) {\r\n                                const deformerID = connections\r\n                                    .get(child.ID)\r\n                                    .parents.filter(function (parent) {\r\n                                        return (\r\n                                            parent.relationship !== undefined\r\n                                        );\r\n                                    })[0].ID;\r\n\r\n                                const morpherID =\r\n                                    connections.get(deformerID).parents[0].ID;\r\n                                const geoID =\r\n                                    connections.get(morpherID).parents[0].ID;\r\n\r\n                                // assuming geometry is not used in more than one model\r\n                                const modelID =\r\n                                    connections.get(geoID).parents[0].ID;\r\n\r\n                                const rawModel = fbxTree.Objects.Model[modelID];\r\n\r\n                                const node = {\r\n                                    modelName: rawModel.attrName\r\n                                        ? PropertyBinding.sanitizeNodeName(\r\n                                              rawModel.attrName\r\n                                          )\r\n                                        : \"\",\r\n                                    morphName:\r\n                                        fbxTree.Objects.Deformer[deformerID]\r\n                                            .attrName,\r\n                                };\r\n\r\n                                layerCurveNodes[i] = node;\r\n                            }\r\n\r\n                            layerCurveNodes[i][curveNode.attr] = curveNode;\r\n                        }\r\n                    }\r\n                });\r\n\r\n                layersMap.set(parseInt(nodeID), layerCurveNodes);\r\n            }\r\n        }\r\n\r\n        return layersMap;\r\n    }\r\n\r\n    // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\r\n    // hierarchy. Each Stack node will be used to create a AnimationClip\r\n    parseAnimStacks(layersMap) {\r\n        const rawStacks = fbxTree.Objects.AnimationStack;\r\n\r\n        // connect the stacks (clips) up to the layers\r\n        const rawClips = {};\r\n\r\n        for (const nodeID in rawStacks) {\r\n            const children = connections.get(parseInt(nodeID)).children;\r\n\r\n            if (children.length > 1) {\r\n                // it seems like stacks will always be associated with a single layer. But just in case there are files\r\n                // where there are multiple layers per stack, we'll display a warning\r\n                console.warn(\r\n                    \"THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.\"\r\n                );\r\n            }\r\n\r\n            const layer = layersMap.get(children[0].ID);\r\n\r\n            rawClips[nodeID] = {\r\n                name: rawStacks[nodeID].attrName,\r\n                layer: layer,\r\n            };\r\n        }\r\n\r\n        return rawClips;\r\n    }\r\n\r\n    addClip(rawClip) {\r\n        let tracks = [];\r\n\r\n        const scope = this;\r\n        rawClip.layer.forEach(function (rawTracks) {\r\n            tracks = tracks.concat(scope.generateTracks(rawTracks));\r\n        });\r\n\r\n        return new AnimationClip(rawClip.name, -1, tracks);\r\n    }\r\n\r\n    generateTracks(rawTracks) {\r\n        const tracks = [];\r\n\r\n        let initialPosition = new Vector3();\r\n        let initialRotation = new Quaternion();\r\n        let initialScale = new Vector3();\r\n\r\n        if (rawTracks.transform)\r\n            rawTracks.transform.decompose(\r\n                initialPosition,\r\n                initialRotation,\r\n                initialScale\r\n            );\r\n\r\n        initialPosition = initialPosition.toArray();\r\n        initialRotation = new Euler()\r\n            .setFromQuaternion(initialRotation, rawTracks.eulerOrder)\r\n            .toArray();\r\n        initialScale = initialScale.toArray();\r\n\r\n        if (\r\n            rawTracks.T !== undefined &&\r\n            Object.keys(rawTracks.T.curves).length > 0\r\n        ) {\r\n            const positionTrack = this.generateVectorTrack(\r\n                rawTracks.modelName,\r\n                rawTracks.T.curves,\r\n                initialPosition,\r\n                \"position\"\r\n            );\r\n            if (positionTrack !== undefined) tracks.push(positionTrack);\r\n        }\r\n\r\n        if (\r\n            rawTracks.R !== undefined &&\r\n            Object.keys(rawTracks.R.curves).length > 0\r\n        ) {\r\n            const rotationTrack = this.generateRotationTrack(\r\n                rawTracks.modelName,\r\n                rawTracks.R.curves,\r\n                initialRotation,\r\n                rawTracks.preRotation,\r\n                rawTracks.postRotation,\r\n                rawTracks.eulerOrder\r\n            );\r\n            if (rotationTrack !== undefined) tracks.push(rotationTrack);\r\n        }\r\n\r\n        if (\r\n            rawTracks.S !== undefined &&\r\n            Object.keys(rawTracks.S.curves).length > 0\r\n        ) {\r\n            const scaleTrack = this.generateVectorTrack(\r\n                rawTracks.modelName,\r\n                rawTracks.S.curves,\r\n                initialScale,\r\n                \"scale\"\r\n            );\r\n            if (scaleTrack !== undefined) tracks.push(scaleTrack);\r\n        }\r\n\r\n        if (rawTracks.DeformPercent !== undefined) {\r\n            const morphTrack = this.generateMorphTrack(rawTracks);\r\n            if (morphTrack !== undefined) tracks.push(morphTrack);\r\n        }\r\n\r\n        return tracks;\r\n    }\r\n\r\n    generateVectorTrack(modelName, curves, initialValue, type) {\r\n        const times = this.getTimesForAllAxes(curves);\r\n        const values = this.getKeyframeTrackValues(times, curves, initialValue);\r\n\r\n        return new VectorKeyframeTrack(modelName + \".\" + type, times, values);\r\n    }\r\n\r\n    generateRotationTrack(\r\n        modelName,\r\n        curves,\r\n        initialValue,\r\n        preRotation,\r\n        postRotation,\r\n        eulerOrder\r\n    ) {\r\n        if (curves.x !== undefined) {\r\n            this.interpolateRotations(curves.x);\r\n            curves.x.values = curves.x.values.map(MathUtils.degToRad);\r\n        }\r\n\r\n        if (curves.y !== undefined) {\r\n            this.interpolateRotations(curves.y);\r\n            curves.y.values = curves.y.values.map(MathUtils.degToRad);\r\n        }\r\n\r\n        if (curves.z !== undefined) {\r\n            this.interpolateRotations(curves.z);\r\n            curves.z.values = curves.z.values.map(MathUtils.degToRad);\r\n        }\r\n\r\n        const times = this.getTimesForAllAxes(curves);\r\n        const values = this.getKeyframeTrackValues(times, curves, initialValue);\r\n\r\n        if (preRotation !== undefined) {\r\n            preRotation = preRotation.map(MathUtils.degToRad);\r\n            preRotation.push(eulerOrder);\r\n\r\n            preRotation = new Euler().fromArray(preRotation);\r\n            preRotation = new Quaternion().setFromEuler(preRotation);\r\n        }\r\n\r\n        if (postRotation !== undefined) {\r\n            postRotation = postRotation.map(MathUtils.degToRad);\r\n            postRotation.push(eulerOrder);\r\n\r\n            postRotation = new Euler().fromArray(postRotation);\r\n            postRotation = new Quaternion().setFromEuler(postRotation).invert();\r\n        }\r\n\r\n        const quaternion = new Quaternion();\r\n        const euler = new Euler();\r\n\r\n        const quaternionValues = [];\r\n\r\n        for (let i = 0; i < values.length; i += 3) {\r\n            euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);\r\n\r\n            quaternion.setFromEuler(euler);\r\n\r\n            if (preRotation !== undefined) quaternion.premultiply(preRotation);\r\n            if (postRotation !== undefined) quaternion.multiply(postRotation);\r\n\r\n            quaternion.toArray(quaternionValues, (i / 3) * 4);\r\n        }\r\n\r\n        return new QuaternionKeyframeTrack(\r\n            modelName + \".quaternion\",\r\n            times,\r\n            quaternionValues\r\n        );\r\n    }\r\n\r\n    generateMorphTrack(rawTracks) {\r\n        const curves = rawTracks.DeformPercent.curves.morph;\r\n        const values = curves.values.map(function (val) {\r\n            return val / 100;\r\n        });\r\n\r\n        const morphNum = sceneGraph.getObjectByName(rawTracks.modelName)\r\n            .morphTargetDictionary[rawTracks.morphName];\r\n\r\n        return new NumberKeyframeTrack(\r\n            rawTracks.modelName + \".morphTargetInfluences[\" + morphNum + \"]\",\r\n            curves.times,\r\n            values\r\n        );\r\n    }\r\n\r\n    // For all animated objects, times are defined separately for each axis\r\n    // Here we'll combine the times into one sorted array without duplicates\r\n    getTimesForAllAxes(curves) {\r\n        let times = [];\r\n\r\n        // first join together the times for each axis, if defined\r\n        if (curves.x !== undefined) times = times.concat(curves.x.times);\r\n        if (curves.y !== undefined) times = times.concat(curves.y.times);\r\n        if (curves.z !== undefined) times = times.concat(curves.z.times);\r\n\r\n        // then sort them\r\n        times = times.sort(function (a, b) {\r\n            return a - b;\r\n        });\r\n\r\n        // and remove duplicates\r\n        if (times.length > 1) {\r\n            let targetIndex = 1;\r\n            let lastValue = times[0];\r\n            for (let i = 1; i < times.length; i++) {\r\n                const currentValue = times[i];\r\n                if (currentValue !== lastValue) {\r\n                    times[targetIndex] = currentValue;\r\n                    lastValue = currentValue;\r\n                    targetIndex++;\r\n                }\r\n            }\r\n\r\n            times = times.slice(0, targetIndex);\r\n        }\r\n\r\n        return times;\r\n    }\r\n\r\n    getKeyframeTrackValues(times, curves, initialValue) {\r\n        const prevValue = initialValue;\r\n\r\n        const values = [];\r\n\r\n        let xIndex = -1;\r\n        let yIndex = -1;\r\n        let zIndex = -1;\r\n\r\n        times.forEach(function (time) {\r\n            if (curves.x) xIndex = curves.x.times.indexOf(time);\r\n            if (curves.y) yIndex = curves.y.times.indexOf(time);\r\n            if (curves.z) zIndex = curves.z.times.indexOf(time);\r\n\r\n            // if there is an x value defined for this frame, use that\r\n            if (xIndex !== -1) {\r\n                const xValue = curves.x.values[xIndex];\r\n                values.push(xValue);\r\n                prevValue[0] = xValue;\r\n            } else {\r\n                // otherwise use the x value from the previous frame\r\n                values.push(prevValue[0]);\r\n            }\r\n\r\n            if (yIndex !== -1) {\r\n                const yValue = curves.y.values[yIndex];\r\n                values.push(yValue);\r\n                prevValue[1] = yValue;\r\n            } else {\r\n                values.push(prevValue[1]);\r\n            }\r\n\r\n            if (zIndex !== -1) {\r\n                const zValue = curves.z.values[zIndex];\r\n                values.push(zValue);\r\n                prevValue[2] = zValue;\r\n            } else {\r\n                values.push(prevValue[2]);\r\n            }\r\n        });\r\n\r\n        return values;\r\n    }\r\n\r\n    // Rotations are defined as Euler angles which can have values  of any size\r\n    // These will be converted to quaternions which don't support values greater than\r\n    // PI, so we'll interpolate large rotations\r\n    interpolateRotations(curve) {\r\n        for (let i = 1; i < curve.values.length; i++) {\r\n            const initialValue = curve.values[i - 1];\r\n            const valuesSpan = curve.values[i] - initialValue;\r\n\r\n            const absoluteSpan = Math.abs(valuesSpan);\r\n\r\n            if (absoluteSpan >= 180) {\r\n                const numSubIntervals = absoluteSpan / 180;\r\n\r\n                const step = valuesSpan / numSubIntervals;\r\n                let nextValue = initialValue + step;\r\n\r\n                const initialTime = curve.times[i - 1];\r\n                const timeSpan = curve.times[i] - initialTime;\r\n                const interval = timeSpan / numSubIntervals;\r\n                let nextTime = initialTime + interval;\r\n\r\n                const interpolatedTimes = [];\r\n                const interpolatedValues = [];\r\n\r\n                while (nextTime < curve.times[i]) {\r\n                    interpolatedTimes.push(nextTime);\r\n                    nextTime += interval;\r\n\r\n                    interpolatedValues.push(nextValue);\r\n                    nextValue += step;\r\n                }\r\n\r\n                curve.times = inject(curve.times, i, interpolatedTimes);\r\n                curve.values = inject(curve.values, i, interpolatedValues);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// parse an FBX file in ASCII format\r\nclass TextParser {\r\n    getPrevNode() {\r\n        return this.nodeStack[this.currentIndent - 2];\r\n    }\r\n\r\n    getCurrentNode() {\r\n        return this.nodeStack[this.currentIndent - 1];\r\n    }\r\n\r\n    getCurrentProp() {\r\n        return this.currentProp;\r\n    }\r\n\r\n    pushStack(node) {\r\n        this.nodeStack.push(node);\r\n        this.currentIndent += 1;\r\n    }\r\n\r\n    popStack() {\r\n        this.nodeStack.pop();\r\n        this.currentIndent -= 1;\r\n    }\r\n\r\n    setCurrentProp(val, name) {\r\n        this.currentProp = val;\r\n        this.currentPropName = name;\r\n    }\r\n\r\n    parse(text) {\r\n        this.currentIndent = 0;\r\n\r\n        this.allNodes = new FBXTree();\r\n        this.nodeStack = [];\r\n        this.currentProp = [];\r\n        this.currentPropName = \"\";\r\n\r\n        const scope = this;\r\n\r\n        const split = text.split(/[\\r\\n]+/);\r\n\r\n        split.forEach(function (line, i) {\r\n            const matchComment = line.match(/^[\\s\\t]*;/);\r\n            const matchEmpty = line.match(/^[\\s\\t]*$/);\r\n\r\n            if (matchComment || matchEmpty) return;\r\n\r\n            const matchBeginning = line.match(\r\n                \"^\\\\t{\" + scope.currentIndent + \"}(\\\\w+):(.*){\",\r\n                \"\"\r\n            );\r\n            const matchProperty = line.match(\r\n                \"^\\\\t{\" + scope.currentIndent + \"}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)\"\r\n            );\r\n            const matchEnd = line.match(\r\n                \"^\\\\t{\" + (scope.currentIndent - 1) + \"}}\"\r\n            );\r\n\r\n            if (matchBeginning) {\r\n                scope.parseNodeBegin(line, matchBeginning);\r\n            } else if (matchProperty) {\r\n                scope.parseNodeProperty(line, matchProperty, split[++i]);\r\n            } else if (matchEnd) {\r\n                scope.popStack();\r\n            } else if (line.match(/^[^\\s\\t}]/)) {\r\n                // large arrays are split over multiple lines terminated with a ',' character\r\n                // if this is encountered the line needs to be joined to the previous line\r\n                scope.parseNodePropertyContinued(line);\r\n            }\r\n        });\r\n\r\n        return this.allNodes;\r\n    }\r\n\r\n    parseNodeBegin(line, property) {\r\n        const nodeName = property[1].trim().replace(/^\"/, \"\").replace(/\"$/, \"\");\r\n\r\n        const nodeAttrs = property[2].split(\",\").map(function (attr) {\r\n            return attr.trim().replace(/^\"/, \"\").replace(/\"$/, \"\");\r\n        });\r\n\r\n        const node = { name: nodeName };\r\n        const attrs = this.parseNodeAttr(nodeAttrs);\r\n\r\n        const currentNode = this.getCurrentNode();\r\n\r\n        // a top node\r\n        if (this.currentIndent === 0) {\r\n            this.allNodes.add(nodeName, node);\r\n        } else {\r\n            // a subnode\r\n\r\n            // if the subnode already exists, append it\r\n            if (nodeName in currentNode) {\r\n                // special case Pose needs PoseNodes as an array\r\n                if (nodeName === \"PoseNode\") {\r\n                    currentNode.PoseNode.push(node);\r\n                } else if (currentNode[nodeName].id !== undefined) {\r\n                    currentNode[nodeName] = {};\r\n                    currentNode[nodeName][currentNode[nodeName].id] =\r\n                        currentNode[nodeName];\r\n                }\r\n\r\n                if (attrs.id !== \"\") currentNode[nodeName][attrs.id] = node;\r\n            } else if (typeof attrs.id === \"number\") {\r\n                currentNode[nodeName] = {};\r\n                currentNode[nodeName][attrs.id] = node;\r\n            } else if (nodeName !== \"Properties70\") {\r\n                if (nodeName === \"PoseNode\") currentNode[nodeName] = [node];\r\n                else currentNode[nodeName] = node;\r\n            }\r\n        }\r\n\r\n        if (typeof attrs.id === \"number\") node.id = attrs.id;\r\n        if (attrs.name !== \"\") node.attrName = attrs.name;\r\n        if (attrs.type !== \"\") node.attrType = attrs.type;\r\n\r\n        this.pushStack(node);\r\n    }\r\n\r\n    parseNodeAttr(attrs) {\r\n        let id = attrs[0];\r\n\r\n        if (attrs[0] !== \"\") {\r\n            id = parseInt(attrs[0]);\r\n\r\n            if (isNaN(id)) {\r\n                id = attrs[0];\r\n            }\r\n        }\r\n\r\n        let name = \"\",\r\n            type = \"\";\r\n\r\n        if (attrs.length > 1) {\r\n            name = attrs[1].replace(/^(\\w+)::/, \"\");\r\n            type = attrs[2];\r\n        }\r\n\r\n        return { id: id, name: name, type: type };\r\n    }\r\n\r\n    parseNodeProperty(line, property, contentLine) {\r\n        let propName = property[1].replace(/^\"/, \"\").replace(/\"$/, \"\").trim();\r\n        let propValue = property[2].replace(/^\"/, \"\").replace(/\"$/, \"\").trim();\r\n\r\n        // for special case: base64 image data follows \"Content: ,\" line\r\n        //\tContent: ,\r\n        //\t \"/9j/4RDaRXhpZgAATU0A...\"\r\n        if (propName === \"Content\" && propValue === \",\") {\r\n            propValue = contentLine.replace(/\"/g, \"\").replace(/,$/, \"\").trim();\r\n        }\r\n\r\n        const currentNode = this.getCurrentNode();\r\n        const parentName = currentNode.name;\r\n\r\n        if (parentName === \"Properties70\") {\r\n            this.parseNodeSpecialProperty(line, propName, propValue);\r\n            return;\r\n        }\r\n\r\n        // Connections\r\n        if (propName === \"C\") {\r\n            const connProps = propValue.split(\",\").slice(1);\r\n            const from = parseInt(connProps[0]);\r\n            const to = parseInt(connProps[1]);\r\n\r\n            let rest = propValue.split(\",\").slice(3);\r\n\r\n            rest = rest.map(function (elem) {\r\n                return elem.trim().replace(/^\"/, \"\");\r\n            });\r\n\r\n            propName = \"connections\";\r\n            propValue = [from, to];\r\n            append(propValue, rest);\r\n\r\n            if (currentNode[propName] === undefined) {\r\n                currentNode[propName] = [];\r\n            }\r\n        }\r\n\r\n        // Node\r\n        if (propName === \"Node\") currentNode.id = propValue;\r\n\r\n        // connections\r\n        if (propName in currentNode && Array.isArray(currentNode[propName])) {\r\n            currentNode[propName].push(propValue);\r\n        } else {\r\n            if (propName !== \"a\") currentNode[propName] = propValue;\r\n            else currentNode.a = propValue;\r\n        }\r\n\r\n        this.setCurrentProp(currentNode, propName);\r\n\r\n        // convert string to array, unless it ends in ',' in which case more will be added to it\r\n        if (propName === \"a\" && propValue.slice(-1) !== \",\") {\r\n            currentNode.a = parseNumberArray(propValue);\r\n        }\r\n    }\r\n\r\n    parseNodePropertyContinued(line) {\r\n        const currentNode = this.getCurrentNode();\r\n\r\n        currentNode.a += line;\r\n\r\n        // if the line doesn't end in ',' we have reached the end of the property value\r\n        // so convert the string to an array\r\n        if (line.slice(-1) !== \",\") {\r\n            currentNode.a = parseNumberArray(currentNode.a);\r\n        }\r\n    }\r\n\r\n    // parse \"Property70\"\r\n    parseNodeSpecialProperty(line, propName, propValue) {\r\n        // split this\r\n        // P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\r\n        // into array like below\r\n        // [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\r\n        const props = propValue.split('\",').map(function (prop) {\r\n            return prop.trim().replace(/^\\\"/, \"\").replace(/\\s/, \"_\");\r\n        });\r\n\r\n        const innerPropName = props[0];\r\n        const innerPropType1 = props[1];\r\n        const innerPropType2 = props[2];\r\n        const innerPropFlag = props[3];\r\n        let innerPropValue = props[4];\r\n\r\n        // cast values where needed, otherwise leave as strings\r\n        switch (innerPropType1) {\r\n            case \"int\":\r\n            case \"enum\":\r\n            case \"bool\":\r\n            case \"ULongLong\":\r\n            case \"double\":\r\n            case \"Number\":\r\n            case \"FieldOfView\":\r\n                innerPropValue = parseFloat(innerPropValue);\r\n                break;\r\n\r\n            case \"Color\":\r\n            case \"ColorRGB\":\r\n            case \"Vector3D\":\r\n            case \"Lcl_Translation\":\r\n            case \"Lcl_Rotation\":\r\n            case \"Lcl_Scaling\":\r\n                innerPropValue = parseNumberArray(innerPropValue);\r\n                break;\r\n        }\r\n\r\n        // CAUTION: these props must append to parent's parent\r\n        this.getPrevNode()[innerPropName] = {\r\n            type: innerPropType1,\r\n            type2: innerPropType2,\r\n            flag: innerPropFlag,\r\n            value: innerPropValue,\r\n        };\r\n\r\n        this.setCurrentProp(this.getPrevNode(), innerPropName);\r\n    }\r\n}\r\n\r\n// Parse an FBX file in Binary format\r\nclass BinaryParser {\r\n    parse(buffer) {\r\n        const reader = new BinaryReader(buffer);\r\n        reader.skip(23); // skip magic 23 bytes\r\n\r\n        const version = reader.getUint32();\r\n\r\n        if (version < 6400) {\r\n            throw new Error(\r\n                \"THREE.FBXLoader: FBX version not supported, FileVersion: \" +\r\n                    version\r\n            );\r\n        }\r\n\r\n        const allNodes = new FBXTree();\r\n\r\n        while (!this.endOfContent(reader)) {\r\n            const node = this.parseNode(reader, version);\r\n            if (node !== null) allNodes.add(node.name, node);\r\n        }\r\n\r\n        return allNodes;\r\n    }\r\n\r\n    // Check if reader has reached the end of content.\r\n    endOfContent(reader) {\r\n        // footer size: 160bytes + 16-byte alignment padding\r\n        // - 16bytes: magic\r\n        // - padding til 16-byte alignment (at least 1byte?)\r\n        //\t(seems like some exporters embed fixed 15 or 16bytes?)\r\n        // - 4bytes: magic\r\n        // - 4bytes: version\r\n        // - 120bytes: zero\r\n        // - 16bytes: magic\r\n        if (reader.size() % 16 === 0) {\r\n            return ((reader.getOffset() + 160 + 16) & ~0xf) >= reader.size();\r\n        } else {\r\n            return reader.getOffset() + 160 + 16 >= reader.size();\r\n        }\r\n    }\r\n\r\n    // recursively parse nodes until the end of the file is reached\r\n    parseNode(reader, version) {\r\n        const node = {};\r\n\r\n        // The first three data sizes depends on version.\r\n        const endOffset =\r\n            version >= 7500 ? reader.getUint64() : reader.getUint32();\r\n        const numProperties =\r\n            version >= 7500 ? reader.getUint64() : reader.getUint32();\r\n\r\n        version >= 7500 ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used\r\n\r\n        const nameLen = reader.getUint8();\r\n        const name = reader.getString(nameLen);\r\n\r\n        // Regards this node as NULL-record if endOffset is zero\r\n        if (endOffset === 0) return null;\r\n\r\n        const propertyList = [];\r\n\r\n        for (let i = 0; i < numProperties; i++) {\r\n            propertyList.push(this.parseProperty(reader));\r\n        }\r\n\r\n        // Regards the first three elements in propertyList as id, attrName, and attrType\r\n        const id = propertyList.length > 0 ? propertyList[0] : \"\";\r\n        const attrName = propertyList.length > 1 ? propertyList[1] : \"\";\r\n        const attrType = propertyList.length > 2 ? propertyList[2] : \"\";\r\n\r\n        // check if this node represents just a single property\r\n        // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\r\n        node.singleProperty =\r\n            numProperties === 1 && reader.getOffset() === endOffset\r\n                ? true\r\n                : false;\r\n\r\n        while (endOffset > reader.getOffset()) {\r\n            const subNode = this.parseNode(reader, version);\r\n\r\n            if (subNode !== null) this.parseSubNode(name, node, subNode);\r\n        }\r\n\r\n        node.propertyList = propertyList; // raw property list used by parent\r\n\r\n        if (typeof id === \"number\") node.id = id;\r\n        if (attrName !== \"\") node.attrName = attrName;\r\n        if (attrType !== \"\") node.attrType = attrType;\r\n        if (name !== \"\") node.name = name;\r\n\r\n        return node;\r\n    }\r\n\r\n    parseSubNode(name, node, subNode) {\r\n        // special case: child node is single property\r\n        if (subNode.singleProperty === true) {\r\n            const value = subNode.propertyList[0];\r\n\r\n            if (Array.isArray(value)) {\r\n                node[subNode.name] = subNode;\r\n\r\n                subNode.a = value;\r\n            } else {\r\n                node[subNode.name] = value;\r\n            }\r\n        } else if (name === \"Connections\" && subNode.name === \"C\") {\r\n            const array = [];\r\n\r\n            subNode.propertyList.forEach(function (property, i) {\r\n                // first Connection is FBX type (OO, OP, etc.). We'll discard these\r\n                if (i !== 0) array.push(property);\r\n            });\r\n\r\n            if (node.connections === undefined) {\r\n                node.connections = [];\r\n            }\r\n\r\n            node.connections.push(array);\r\n        } else if (subNode.name === \"Properties70\") {\r\n            const keys = Object.keys(subNode);\r\n\r\n            keys.forEach(function (key) {\r\n                node[key] = subNode[key];\r\n            });\r\n        } else if (name === \"Properties70\" && subNode.name === \"P\") {\r\n            let innerPropName = subNode.propertyList[0];\r\n            let innerPropType1 = subNode.propertyList[1];\r\n            const innerPropType2 = subNode.propertyList[2];\r\n            const innerPropFlag = subNode.propertyList[3];\r\n            let innerPropValue;\r\n\r\n            if (innerPropName.indexOf(\"Lcl \") === 0)\r\n                innerPropName = innerPropName.replace(\"Lcl \", \"Lcl_\");\r\n            if (innerPropType1.indexOf(\"Lcl \") === 0)\r\n                innerPropType1 = innerPropType1.replace(\"Lcl \", \"Lcl_\");\r\n\r\n            if (\r\n                innerPropType1 === \"Color\" ||\r\n                innerPropType1 === \"ColorRGB\" ||\r\n                innerPropType1 === \"Vector\" ||\r\n                innerPropType1 === \"Vector3D\" ||\r\n                innerPropType1.indexOf(\"Lcl_\") === 0\r\n            ) {\r\n                innerPropValue = [\r\n                    subNode.propertyList[4],\r\n                    subNode.propertyList[5],\r\n                    subNode.propertyList[6],\r\n                ];\r\n            } else {\r\n                innerPropValue = subNode.propertyList[4];\r\n            }\r\n\r\n            // this will be copied to parent, see above\r\n            node[innerPropName] = {\r\n                type: innerPropType1,\r\n                type2: innerPropType2,\r\n                flag: innerPropFlag,\r\n                value: innerPropValue,\r\n            };\r\n        } else if (node[subNode.name] === undefined) {\r\n            if (typeof subNode.id === \"number\") {\r\n                node[subNode.name] = {};\r\n                node[subNode.name][subNode.id] = subNode;\r\n            } else {\r\n                node[subNode.name] = subNode;\r\n            }\r\n        } else {\r\n            if (subNode.name === \"PoseNode\") {\r\n                if (!Array.isArray(node[subNode.name])) {\r\n                    node[subNode.name] = [node[subNode.name]];\r\n                }\r\n\r\n                node[subNode.name].push(subNode);\r\n            } else if (node[subNode.name][subNode.id] === undefined) {\r\n                node[subNode.name][subNode.id] = subNode;\r\n            }\r\n        }\r\n    }\r\n\r\n    parseProperty(reader) {\r\n        const type = reader.getString(1);\r\n        let length;\r\n\r\n        switch (type) {\r\n            case \"C\":\r\n                return reader.getBoolean();\r\n\r\n            case \"D\":\r\n                return reader.getFloat64();\r\n\r\n            case \"F\":\r\n                return reader.getFloat32();\r\n\r\n            case \"I\":\r\n                return reader.getInt32();\r\n\r\n            case \"L\":\r\n                return reader.getInt64();\r\n\r\n            case \"R\":\r\n                length = reader.getUint32();\r\n                return reader.getArrayBuffer(length);\r\n\r\n            case \"S\":\r\n                length = reader.getUint32();\r\n                return reader.getString(length);\r\n\r\n            case \"Y\":\r\n                return reader.getInt16();\r\n\r\n            case \"b\":\r\n            case \"c\":\r\n            case \"d\":\r\n            case \"f\":\r\n            case \"i\":\r\n            case \"l\":\r\n                const arrayLength = reader.getUint32();\r\n                const encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\r\n                const compressedLength = reader.getUint32();\r\n\r\n                if (encoding === 0) {\r\n                    switch (type) {\r\n                        case \"b\":\r\n                        case \"c\":\r\n                            return reader.getBooleanArray(arrayLength);\r\n\r\n                        case \"d\":\r\n                            return reader.getFloat64Array(arrayLength);\r\n\r\n                        case \"f\":\r\n                            return reader.getFloat32Array(arrayLength);\r\n\r\n                        case \"i\":\r\n                            return reader.getInt32Array(arrayLength);\r\n\r\n                        case \"l\":\r\n                            return reader.getInt64Array(arrayLength);\r\n                    }\r\n                }\r\n\r\n                if (typeof fflate === \"undefined\") {\r\n                    console.error(\r\n                        \"THREE.FBXLoader: External library fflate.min.js required.\"\r\n                    );\r\n                }\r\n\r\n                const data = fflate.unzlibSync(\r\n                    new Uint8Array(reader.getArrayBuffer(compressedLength))\r\n                ); // eslint-disable-line no-undef\r\n                const reader2 = new BinaryReader(data.buffer);\r\n\r\n                switch (type) {\r\n                    case \"b\":\r\n                    case \"c\":\r\n                        return reader2.getBooleanArray(arrayLength);\r\n\r\n                    case \"d\":\r\n                        return reader2.getFloat64Array(arrayLength);\r\n\r\n                    case \"f\":\r\n                        return reader2.getFloat32Array(arrayLength);\r\n\r\n                    case \"i\":\r\n                        return reader2.getInt32Array(arrayLength);\r\n\r\n                    case \"l\":\r\n                        return reader2.getInt64Array(arrayLength);\r\n                }\r\n\r\n            default:\r\n                throw new Error(\r\n                    \"THREE.FBXLoader: Unknown property type \" + type\r\n                );\r\n        }\r\n    }\r\n}\r\n\r\nclass BinaryReader {\r\n    constructor(buffer, littleEndian) {\r\n        this.dv = new DataView(buffer);\r\n        this.offset = 0;\r\n        this.littleEndian = littleEndian !== undefined ? littleEndian : true;\r\n    }\r\n\r\n    getOffset() {\r\n        return this.offset;\r\n    }\r\n\r\n    size() {\r\n        return this.dv.buffer.byteLength;\r\n    }\r\n\r\n    skip(length) {\r\n        this.offset += length;\r\n    }\r\n\r\n    // seems like true/false representation depends on exporter.\r\n    // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\r\n    // then sees LSB.\r\n    getBoolean() {\r\n        return (this.getUint8() & 1) === 1;\r\n    }\r\n\r\n    getBooleanArray(size) {\r\n        const a = [];\r\n\r\n        for (let i = 0; i < size; i++) {\r\n            a.push(this.getBoolean());\r\n        }\r\n\r\n        return a;\r\n    }\r\n\r\n    getUint8() {\r\n        const value = this.dv.getUint8(this.offset);\r\n        this.offset += 1;\r\n        return value;\r\n    }\r\n\r\n    getInt16() {\r\n        const value = this.dv.getInt16(this.offset, this.littleEndian);\r\n        this.offset += 2;\r\n        return value;\r\n    }\r\n\r\n    getInt32() {\r\n        const value = this.dv.getInt32(this.offset, this.littleEndian);\r\n        this.offset += 4;\r\n        return value;\r\n    }\r\n\r\n    getInt32Array(size) {\r\n        const a = [];\r\n\r\n        for (let i = 0; i < size; i++) {\r\n            a.push(this.getInt32());\r\n        }\r\n\r\n        return a;\r\n    }\r\n\r\n    getUint32() {\r\n        const value = this.dv.getUint32(this.offset, this.littleEndian);\r\n        this.offset += 4;\r\n        return value;\r\n    }\r\n\r\n    // JavaScript doesn't support 64-bit integer so calculate this here\r\n    // 1 << 32 will return 1 so using multiply operation instead here.\r\n    // There's a possibility that this method returns wrong value if the value\r\n    // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\r\n    // TODO: safely handle 64-bit integer\r\n    getInt64() {\r\n        let low, high;\r\n\r\n        if (this.littleEndian) {\r\n            low = this.getUint32();\r\n            high = this.getUint32();\r\n        } else {\r\n            high = this.getUint32();\r\n            low = this.getUint32();\r\n        }\r\n\r\n        // calculate negative value\r\n        if (high & 0x80000000) {\r\n            high = ~high & 0xffffffff;\r\n            low = ~low & 0xffffffff;\r\n\r\n            if (low === 0xffffffff) high = (high + 1) & 0xffffffff;\r\n\r\n            low = (low + 1) & 0xffffffff;\r\n\r\n            return -(high * 0x100000000 + low);\r\n        }\r\n\r\n        return high * 0x100000000 + low;\r\n    }\r\n\r\n    getInt64Array(size) {\r\n        const a = [];\r\n\r\n        for (let i = 0; i < size; i++) {\r\n            a.push(this.getInt64());\r\n        }\r\n\r\n        return a;\r\n    }\r\n\r\n    // Note: see getInt64() comment\r\n    getUint64() {\r\n        let low, high;\r\n\r\n        if (this.littleEndian) {\r\n            low = this.getUint32();\r\n            high = this.getUint32();\r\n        } else {\r\n            high = this.getUint32();\r\n            low = this.getUint32();\r\n        }\r\n\r\n        return high * 0x100000000 + low;\r\n    }\r\n\r\n    getFloat32() {\r\n        const value = this.dv.getFloat32(this.offset, this.littleEndian);\r\n        this.offset += 4;\r\n        return value;\r\n    }\r\n\r\n    getFloat32Array(size) {\r\n        const a = [];\r\n\r\n        for (let i = 0; i < size; i++) {\r\n            a.push(this.getFloat32());\r\n        }\r\n\r\n        return a;\r\n    }\r\n\r\n    getFloat64() {\r\n        const value = this.dv.getFloat64(this.offset, this.littleEndian);\r\n        this.offset += 8;\r\n        return value;\r\n    }\r\n\r\n    getFloat64Array(size) {\r\n        const a = [];\r\n\r\n        for (let i = 0; i < size; i++) {\r\n            a.push(this.getFloat64());\r\n        }\r\n\r\n        return a;\r\n    }\r\n\r\n    getArrayBuffer(size) {\r\n        const value = this.dv.buffer.slice(this.offset, this.offset + size);\r\n        this.offset += size;\r\n        return value;\r\n    }\r\n\r\n    getString(size) {\r\n        // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\r\n        let a = [];\r\n\r\n        for (let i = 0; i < size; i++) {\r\n            a[i] = this.getUint8();\r\n        }\r\n\r\n        const nullByte = a.indexOf(0);\r\n        if (nullByte >= 0) a = a.slice(0, nullByte);\r\n\r\n        return LoaderUtils.decodeText(new Uint8Array(a));\r\n    }\r\n}\r\n\r\n// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\r\n// and BinaryParser( FBX Binary format)\r\nclass FBXTree {\r\n    add(key, val) {\r\n        this[key] = val;\r\n    }\r\n}\r\n\r\n// ************** UTILITY FUNCTIONS **************\r\n\r\nfunction isFbxFormatBinary(buffer) {\r\n    const CORRECT = \"Kaydara\\u0020FBX\\u0020Binary\\u0020\\u0020\\0\";\r\n\r\n    return (\r\n        buffer.byteLength >= CORRECT.length &&\r\n        CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length)\r\n    );\r\n}\r\n\r\nfunction isFbxFormatASCII(text) {\r\n    const CORRECT = [\r\n        \"K\",\r\n        \"a\",\r\n        \"y\",\r\n        \"d\",\r\n        \"a\",\r\n        \"r\",\r\n        \"a\",\r\n        \"\\\\\",\r\n        \"F\",\r\n        \"B\",\r\n        \"X\",\r\n        \"\\\\\",\r\n        \"B\",\r\n        \"i\",\r\n        \"n\",\r\n        \"a\",\r\n        \"r\",\r\n        \"y\",\r\n        \"\\\\\",\r\n        \"\\\\\",\r\n    ];\r\n\r\n    let cursor = 0;\r\n\r\n    function read(offset) {\r\n        const result = text[offset - 1];\r\n        text = text.slice(cursor + offset);\r\n        cursor++;\r\n        return result;\r\n    }\r\n\r\n    for (let i = 0; i < CORRECT.length; ++i) {\r\n        const num = read(1);\r\n        if (num === CORRECT[i]) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction getFbxVersion(text) {\r\n    const versionRegExp = /FBXVersion: (\\d+)/;\r\n    const match = text.match(versionRegExp);\r\n\r\n    if (match) {\r\n        const version = parseInt(match[1]);\r\n        return version;\r\n    }\r\n\r\n    throw new Error(\r\n        \"THREE.FBXLoader: Cannot find the version number for the file given.\"\r\n    );\r\n}\r\n\r\n// Converts FBX ticks into real time seconds.\r\nfunction convertFBXTimeToSeconds(time) {\r\n    return time / 46186158000;\r\n}\r\n\r\nconst dataArray = [];\r\n\r\n// extracts the data from the correct position in the FBX array based on indexing type\r\nfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\r\n    let index;\r\n\r\n    switch (infoObject.mappingType) {\r\n        case \"ByPolygonVertex\":\r\n            index = polygonVertexIndex;\r\n            break;\r\n        case \"ByPolygon\":\r\n            index = polygonIndex;\r\n            break;\r\n        case \"ByVertice\":\r\n            index = vertexIndex;\r\n            break;\r\n        case \"AllSame\":\r\n            index = infoObject.indices[0];\r\n            break;\r\n        default:\r\n            console.warn(\r\n                \"THREE.FBXLoader: unknown attribute mapping type \" +\r\n                    infoObject.mappingType\r\n            );\r\n    }\r\n\r\n    if (infoObject.referenceType === \"IndexToDirect\")\r\n        index = infoObject.indices[index];\r\n\r\n    const from = index * infoObject.dataSize;\r\n    const to = from + infoObject.dataSize;\r\n\r\n    return slice(dataArray, infoObject.buffer, from, to);\r\n}\r\n\r\nconst tempEuler = new Euler();\r\nconst tempVec = new Vector3();\r\n\r\n// generate transformation from FBX transform data\r\n// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\r\n// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\r\nfunction generateTransform(transformData) {\r\n    const lTranslationM = new Matrix4();\r\n    const lPreRotationM = new Matrix4();\r\n    const lRotationM = new Matrix4();\r\n    const lPostRotationM = new Matrix4();\r\n\r\n    const lScalingM = new Matrix4();\r\n    const lScalingPivotM = new Matrix4();\r\n    const lScalingOffsetM = new Matrix4();\r\n    const lRotationOffsetM = new Matrix4();\r\n    const lRotationPivotM = new Matrix4();\r\n\r\n    const lParentGX = new Matrix4();\r\n    const lParentLX = new Matrix4();\r\n    const lGlobalT = new Matrix4();\r\n\r\n    const inheritType = transformData.inheritType\r\n        ? transformData.inheritType\r\n        : 0;\r\n\r\n    if (transformData.translation)\r\n        lTranslationM.setPosition(tempVec.fromArray(transformData.translation));\r\n\r\n    if (transformData.preRotation) {\r\n        const array = transformData.preRotation.map(MathUtils.degToRad);\r\n        array.push(transformData.eulerOrder);\r\n        lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\r\n    }\r\n\r\n    if (transformData.rotation) {\r\n        const array = transformData.rotation.map(MathUtils.degToRad);\r\n        array.push(transformData.eulerOrder);\r\n        lRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\r\n    }\r\n\r\n    if (transformData.postRotation) {\r\n        const array = transformData.postRotation.map(MathUtils.degToRad);\r\n        array.push(transformData.eulerOrder);\r\n        lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\r\n        lPostRotationM.invert();\r\n    }\r\n\r\n    if (transformData.scale)\r\n        lScalingM.scale(tempVec.fromArray(transformData.scale));\r\n\r\n    // Pivots and offsets\r\n    if (transformData.scalingOffset)\r\n        lScalingOffsetM.setPosition(\r\n            tempVec.fromArray(transformData.scalingOffset)\r\n        );\r\n    if (transformData.scalingPivot)\r\n        lScalingPivotM.setPosition(\r\n            tempVec.fromArray(transformData.scalingPivot)\r\n        );\r\n    if (transformData.rotationOffset)\r\n        lRotationOffsetM.setPosition(\r\n            tempVec.fromArray(transformData.rotationOffset)\r\n        );\r\n    if (transformData.rotationPivot)\r\n        lRotationPivotM.setPosition(\r\n            tempVec.fromArray(transformData.rotationPivot)\r\n        );\r\n\r\n    // parent transform\r\n    if (transformData.parentMatrixWorld) {\r\n        lParentLX.copy(transformData.parentMatrix);\r\n        lParentGX.copy(transformData.parentMatrixWorld);\r\n    }\r\n\r\n    const lLRM = lPreRotationM\r\n        .clone()\r\n        .multiply(lRotationM)\r\n        .multiply(lPostRotationM);\r\n    // Global Rotation\r\n    const lParentGRM = new Matrix4();\r\n    lParentGRM.extractRotation(lParentGX);\r\n\r\n    // Global Shear*Scaling\r\n    const lParentTM = new Matrix4();\r\n    lParentTM.copyPosition(lParentGX);\r\n\r\n    const lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);\r\n    const lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);\r\n    const lLSM = lScalingM;\r\n\r\n    const lGlobalRS = new Matrix4();\r\n\r\n    if (inheritType === 0) {\r\n        lGlobalRS\r\n            .copy(lParentGRM)\r\n            .multiply(lLRM)\r\n            .multiply(lParentGSM)\r\n            .multiply(lLSM);\r\n    } else if (inheritType === 1) {\r\n        lGlobalRS\r\n            .copy(lParentGRM)\r\n            .multiply(lParentGSM)\r\n            .multiply(lLRM)\r\n            .multiply(lLSM);\r\n    } else {\r\n        const lParentLSM = new Matrix4().scale(\r\n            new Vector3().setFromMatrixScale(lParentLX)\r\n        );\r\n        const lParentLSM_inv = lParentLSM.clone().invert();\r\n        const lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);\r\n\r\n        lGlobalRS\r\n            .copy(lParentGRM)\r\n            .multiply(lLRM)\r\n            .multiply(lParentGSM_noLocal)\r\n            .multiply(lLSM);\r\n    }\r\n\r\n    const lRotationPivotM_inv = lRotationPivotM.clone().invert();\r\n    const lScalingPivotM_inv = lScalingPivotM.clone().invert();\r\n    // Calculate the local transform matrix\r\n    let lTransform = lTranslationM\r\n        .clone()\r\n        .multiply(lRotationOffsetM)\r\n        .multiply(lRotationPivotM)\r\n        .multiply(lPreRotationM)\r\n        .multiply(lRotationM)\r\n        .multiply(lPostRotationM)\r\n        .multiply(lRotationPivotM_inv)\r\n        .multiply(lScalingOffsetM)\r\n        .multiply(lScalingPivotM)\r\n        .multiply(lScalingM)\r\n        .multiply(lScalingPivotM_inv);\r\n\r\n    const lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(\r\n        lTransform\r\n    );\r\n\r\n    const lGlobalTranslation = lParentGX\r\n        .clone()\r\n        .multiply(lLocalTWithAllPivotAndOffsetInfo);\r\n    lGlobalT.copyPosition(lGlobalTranslation);\r\n\r\n    lTransform = lGlobalT.clone().multiply(lGlobalRS);\r\n\r\n    // from global to local\r\n    lTransform.premultiply(lParentGX.invert());\r\n\r\n    return lTransform;\r\n}\r\n\r\n// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\r\n// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\r\nfunction getEulerOrder(order) {\r\n    order = order || 0;\r\n\r\n    const enums = [\r\n        \"ZYX\", // -> XYZ extrinsic\r\n        \"YZX\", // -> XZY extrinsic\r\n        \"XZY\", // -> YZX extrinsic\r\n        \"ZXY\", // -> YXZ extrinsic\r\n        \"YXZ\", // -> ZXY extrinsic\r\n        \"XYZ\", // -> ZYX extrinsic\r\n        //'SphericXYZ', // not possible to support\r\n    ];\r\n\r\n    if (order === 6) {\r\n        console.warn(\r\n            \"THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.\"\r\n        );\r\n        return enums[0];\r\n    }\r\n\r\n    return enums[order];\r\n}\r\n\r\n// Parses comma separated list of numbers and returns them an array.\r\n// Used internally by the TextParser\r\nfunction parseNumberArray(value) {\r\n    const array = value.split(\",\").map(function (val) {\r\n        return parseFloat(val);\r\n    });\r\n\r\n    return array;\r\n}\r\n\r\nfunction convertArrayBufferToString(buffer, from, to) {\r\n    if (from === undefined) from = 0;\r\n    if (to === undefined) to = buffer.byteLength;\r\n\r\n    return LoaderUtils.decodeText(new Uint8Array(buffer, from, to));\r\n}\r\n\r\nfunction append(a, b) {\r\n    for (let i = 0, j = a.length, l = b.length; i < l; i++, j++) {\r\n        a[j] = b[i];\r\n    }\r\n}\r\n\r\nfunction slice(a, b, from, to) {\r\n    for (let i = from, j = 0; i < to; i++, j++) {\r\n        a[j] = b[i];\r\n    }\r\n\r\n    return a;\r\n}\r\n\r\n// inject array a2 into array a1 at index\r\nfunction inject(a1, index, a2) {\r\n    return a1.slice(0, index).concat(a2).concat(a1.slice(index));\r\n}\r\n\r\nexport { FBXLoader };\r\n","import * as THREE from \"three\";\r\nimport { fbxSource } from \"App\";\r\nimport { nanoid } from \"nanoid\";\r\n\r\nimport textureOffsets, { idxOffsets } from \"data/face_offset\";\r\nimport matcapList from \"data/matcapList\";\r\n\r\nimport { FBXLoader } from \"./FBXLoader\";\r\n// import { FBXLoader } from \"three/examples/jsm/loaders/FBXLoader\";\r\nimport { callbackOnEach, getUpdated } from \"helpers/helpers\";\r\nimport {\r\n    matCommonParams,\r\n    matExtraParams,\r\n    matColorParams,\r\n    needsUpdateParams,\r\n    matcapDir,\r\n} from \"helpers/consts\";\r\n\r\n/** load a 3D model\r\n * @param {string} url\r\n * @return { ?Promise<THREE.Group>}\r\n */\r\nexport const loadModel = url => {\r\n    return (\r\n        url &&\r\n        new Promise(resolve => {\r\n            new FBXLoader().load(url, resolve);\r\n        })\r\n    );\r\n};\r\n\r\n/** Load a texture\r\n * @param {string} url\r\n * @return {Promise<THREE.Texture>}\r\n */\r\nexport const loadTexture = url => {\r\n    return (\r\n        url &&\r\n        new Promise(resolve => {\r\n            new THREE.TextureLoader().load(url, resolve);\r\n        })\r\n    );\r\n};\r\n\r\n/**\r\n * @param {string} name\r\n */\r\nconst getMatcapPath = name => {\r\n    const matcap = matcapList.find(e => e.name === name);\r\n    return matcap?.path ? `${matcapDir}/${matcap.path}` : null;\r\n};\r\n\r\n/** load matcap texture\r\n * @param {string} name\r\n * @return {null | Promise< THREE.Texture >}\r\n */\r\nexport const loadMatcap = name => {\r\n    const path = getMatcapPath(name);\r\n    return path ? loadTexture(path) : null;\r\n};\r\n\r\n/** get the path to the animation file\r\n * @param {string} name\r\n */\r\nconst getAniPath = name => `${fbxSource}/animations/${name}.json`;\r\n\r\n/** load a single animation\r\n * @param {AniListItem} aniListItem\r\n * @return {Promise<THREE.AnimationClip>}\r\n */\r\nconst loadSingleAni = ({ aniName }) => {\r\n    const path = getAniPath(aniName);\r\n    return new Promise(resolve =>\r\n        fetch(path)\r\n            .then(response => response.json())\r\n            .then(json => THREE.AnimationClip.parse(json))\r\n            .then(resolve)\r\n    );\r\n};\r\n\r\n/** Load all animations in a list of animation\r\n * @param {AniList} aniList\r\n */\r\nexport const loadAnimations = aniList =>\r\n    Promise.all(aniList.map(loadSingleAni));\r\n\r\n/** get all meshes of a 3D object\r\n * @param {THREE.Group} object\r\n * @param {Boolean} getOutline - whether to include outline meshes\r\n * @returns {Array}\r\n */\r\nexport const getMeshes = (object, getOutline = false) => {\r\n    if (!object) return [];\r\n\r\n    const meshes = [];\r\n    object.traverse(child => {\r\n        // @ts-ignore\r\n        if (!child.isMesh) return;\r\n        if (!getOutline && child.name === \"outline\") return;\r\n\r\n        meshes.unshift(child);\r\n    });\r\n    return meshes;\r\n};\r\n\r\n/** get all materials of a 3D object\r\n * @param {THREE.Group} object\r\n */\r\nexport const getMaterial = object => {\r\n    if (!object) return [];\r\n\r\n    const meshes = getMeshes(object);\r\n    const materials = meshes.flatMap(mesh => mesh.material);\r\n    return materials;\r\n};\r\n\r\n/** get the path to the model's fbx file\r\n * @param {string} id\r\n */\r\nexport const getModelPath = id => `${fbxSource}/fbx/${id}/${id}.fbx`;\r\n\r\n/** get the path to the model's texture file\r\n * @param {string} id\r\n */\r\nexport const getTexturePath = id => `${fbxSource}/fbx/${id}/${id}.png`;\r\n\r\n/** get weapon data from weapon code\r\n * @param {string} code\r\n * @return {AdvWeaponData}\r\n */\r\nexport const analyzeWeaponCode = code => {\r\n    if (!code) return null;\r\n\r\n    const flipped = code.endsWith(\"b\");\r\n    const weaponCode = code.substring(0, code.length - 1);\r\n    const modelPath = getModelPath(weaponCode);\r\n    const texturePath = getTexturePath(weaponCode);\r\n\r\n    return { modelPath, texturePath, flipped };\r\n};\r\n\r\n/** dispose a 3D object */\r\nexport const dispose3dObject = object => {\r\n    if (!object) return;\r\n\r\n    const disposedList = new Set();\r\n\r\n    const notDisposed = object => !disposedList.has(object.uuid);\r\n\r\n    const needToDispose = object => object && notDisposed(object);\r\n\r\n    const disposeObject = object => {\r\n        disposedList.add(object.uuid);\r\n        object.dispose();\r\n    };\r\n\r\n    const dispose = object => {\r\n        if (needToDispose(object)) disposeObject(object);\r\n    };\r\n\r\n    const disposeMaterial = object => {\r\n        callbackOnEach(object.material, mat => {\r\n            dispose(mat.map);\r\n            dispose(mat.userData.backupMap);\r\n            dispose(mat);\r\n        });\r\n    };\r\n\r\n    const disposeMesh = mesh => {\r\n        disposeMaterial(mesh);\r\n        dispose(mesh.geometry);\r\n    };\r\n\r\n    const meshes = getMeshes(object, true);\r\n    meshes.forEach(disposeMesh);\r\n};\r\n\r\n/** get list of parameter names relevant to a material type\r\n * @param {string} matType\r\n */\r\nexport const getParamsList = matType => [\r\n    ...matCommonParams,\r\n    ...matExtraParams[matType],\r\n];\r\n\r\n/** Hide all eye and mouth that's not mEye_01 or mMouth_01 */\r\nexport const initDragonFace = model => {\r\n    const nameRegex = /m[A-Z].*_[0-9]/m;\r\n    model.traverse(child => {\r\n        if (!child.isMesh) return;\r\n\r\n        const { name } = child;\r\n        if (nameRegex.test(name)) {\r\n            child.visible = name.includes(\"01\");\r\n        }\r\n    });\r\n};\r\n\r\n/** get all eye meshes of a dragon model */\r\nexport const getDragonEye = model => {\r\n    const eyes = [];\r\n    const nameRegex = /mEye_[0-9]/m;\r\n    model.traverse(child => {\r\n        if (!child.isMesh) return;\r\n\r\n        const { name } = child;\r\n        if (nameRegex.test(name)) {\r\n            eyes.push(child);\r\n        }\r\n    });\r\n    return eyes;\r\n};\r\n\r\n/** get all mouth meshes of a dragon model */\r\nexport const getDragonMouth = model => {\r\n    const mouths = [];\r\n    const nameRegex = /mMouth_[0-9]/m;\r\n    model.traverse(child => {\r\n        if (!child.isMesh) return;\r\n\r\n        const { name } = child;\r\n        if (nameRegex.test(name)) {\r\n            mouths.push(child);\r\n        }\r\n    });\r\n    return mouths;\r\n};\r\n\r\n/** make all effect meshes of the model invisible\r\n * @param {THREE.Group} model\r\n */\r\nexport const removeEffects = model => {\r\n    const meshes = getMeshes(model);\r\n    meshes.forEach(mesh => (mesh.visible = !mesh.name.includes(\"Eff\")));\r\n};\r\n\r\n/** set frustumCulled = false for all children of a model */\r\nexport const disableFrustumCulling = model => {\r\n    model.traverse(child => {\r\n        if (!child.isMesh) return;\r\n\r\n        child.frustumCulled = false;\r\n    });\r\n};\r\n\r\n/** create a new material\r\n * @param {string} materialType - type of material to create\r\n * @param {Object} params\r\n * @param {THREE.Texture} params.map - texture for new material\r\n * @return {THREE.Material}\r\n */\r\nconst createNewMaterial = (materialType, params) => {\r\n    const matType = `Mesh${materialType}Material`;\r\n    return new THREE[matType](params);\r\n};\r\n\r\n/** change material and optionally the texture of a 3D object\r\n * @param {THREE.Group} target - object to apply change to\r\n * @param {object} params - parameters\r\n * @param {string} params.materialType - type of material to change to\r\n * @param {string} [params.texturePath] - path to texture file\r\n * @param {boolean} [params.forced] - force material change\r\n */\r\nexport const changeMaterial = (\r\n    target,\r\n    { materialType, texturePath = \"\", forced = false }\r\n) => {\r\n    if (!target) return;\r\n\r\n    const meshes = getMeshes(target);\r\n    meshes.forEach(mesh => {\r\n        const materials = [mesh.material].flat();\r\n        const matIsArray = Array.isArray(mesh.material);\r\n\r\n        if (!forced && !texturePath) {\r\n            const checkParam = `isMesh${materialType}Material`;\r\n            const needToChange = materials.some(mat => !mat[checkParam]);\r\n            if (!needToChange) return;\r\n        }\r\n\r\n        materials.forEach((mat, i) => {\r\n            /**\r\n             * @type {THREE.Texture}\r\n             */\r\n            const texture = texturePath\r\n                ? new THREE.TextureLoader().load(texturePath)\r\n                : materials[i].map;\r\n\r\n            if (texturePath) texture.encoding = THREE.sRGBEncoding;\r\n\r\n            const initParams = {\r\n                map: texture,\r\n            };\r\n            const newMaterial = createNewMaterial(materialType, initParams);\r\n            newMaterial.name = mat.name;\r\n            if (mat.userData.backupMap) {\r\n                newMaterial.userData.backupMap = mat.userData.backupMap;\r\n            }\r\n\r\n            if (texturePath) {\r\n                mat.map?.dispose?.();\r\n                mat.userData.backupMap?.dispose?.();\r\n            }\r\n            mat.dispose();\r\n\r\n            if (matIsArray) {\r\n                mesh.material[i] = newMaterial;\r\n            } else {\r\n                mesh.material = newMaterial;\r\n            }\r\n        });\r\n    });\r\n};\r\n\r\n/** Add outline to object and return reference to outlines\r\n * @param {THREE.Group} object\r\n * @param {OutlineParams} params\r\n */\r\nexport const createOutline = async (object, params) => {\r\n    if (!object) return;\r\n\r\n    const outlines = [];\r\n    const outlineMaterial = await createOutlineMaterial(params);\r\n\r\n    /** if a mesh's name includes any word in this list, skip */\r\n    const skipList = [\"Eff\", \"Extension\"];\r\n    const meshes = getMeshes(object);\r\n    meshes.forEach(mesh => {\r\n        const { name } = mesh;\r\n        if (skipList.some(word => name.includes(word))) return;\r\n\r\n        const outline = mesh.clone();\r\n\r\n        replaceMaterial(outline, outlineMaterial);\r\n        outline.visible = params.enable;\r\n        outline.name = \"outline\";\r\n\r\n        if (mesh.isSkinnedMesh) {\r\n            outline.bind(mesh.skeleton, mesh.bindMatrix);\r\n        }\r\n        mesh.add(outline);\r\n        outlines.push(outline);\r\n    });\r\n    return outlines;\r\n};\r\n\r\n/**\r\n * @param {string} url\r\n * @return {Promise<string>}\r\n */\r\nconst loadRawText = async url =>\r\n    new Promise(resolve => {\r\n        fetch(url)\r\n            .then(response => response.text())\r\n            .then(resolve);\r\n    });\r\n\r\n/**\r\n * @param {string} dir - shader directory\r\n * @param {string} name - shader name\r\n * @return {Promise<[ vertexShader: string, fragmentShader: string ]>}\r\n */\r\nconst loadShaderFiles = async (dir, name) => {\r\n    const filePaths = [`${dir}/${name}.vert`, `${dir}/${name}.frag`];\r\n\r\n    // @ts-ignore\r\n    return Promise.all(filePaths.map(loadRawText));\r\n};\r\n\r\n/**\r\n * @param {string} name - name of the shader\r\n * @return {Promise<[ vertexShader: string, fragmentShader: string ]>}\r\n */\r\nconst loadShader = async name => {\r\n    const shaderDir = `${process.env.PUBLIC_URL}/shaders/${name}`;\r\n\r\n    return loadShaderFiles(shaderDir, name);\r\n};\r\n\r\n/** create outline material\r\n * @param {OutlineParams} params\r\n */\r\nconst createOutlineMaterial = async ({ size, color, opacity }) => {\r\n    const uniforms = {\r\n        size: { value: size },\r\n        color: { value: new THREE.Color(color) },\r\n        opacity: { value: opacity },\r\n    };\r\n\r\n    const [vertexShader, fragmentShader] = await loadShader(\"outline\");\r\n\r\n    const outlineMaterial = new THREE.ShaderMaterial({\r\n        side: THREE.BackSide,\r\n        transparent: true,\r\n        depthFunc: THREE.LessDepth,\r\n        vertexShader,\r\n        fragmentShader,\r\n        uniforms,\r\n    });\r\n\r\n    return outlineMaterial;\r\n};\r\n\r\n/** apply settings to an outline mesh\r\n * @param {THREE.Mesh} outline\r\n * @param {Map<string, *>} settings\r\n */\r\nexport const applyOutlineSettings = (outline, settings) => {\r\n    if (!outline || !settings) return;\r\n\r\n    const { material } = outline;\r\n    settings.forEach((value, key) => {\r\n        switch (key) {\r\n            case \"enable\":\r\n                outline.visible = value;\r\n                break;\r\n            case \"color\":\r\n                callbackOnEach(\r\n                    material,\r\n                    mat => (mat.uniforms.color.value = new THREE.Color(value))\r\n                );\r\n                break;\r\n            default:\r\n                callbackOnEach(\r\n                    material,\r\n                    mat => (mat.uniforms[key].value = value)\r\n                );\r\n        }\r\n    });\r\n};\r\n\r\n/** replace material of an object */\r\nconst replaceMaterial = (object, newMaterial) => {\r\n    const { material } = object;\r\n    // dispose old material\r\n    callbackOnEach(material, mat => {\r\n        mat.map?.dispose?.();\r\n        mat.userData.backupMap?.dispose?.();\r\n        mat.dispose();\r\n    });\r\n    // apply new material\r\n    const matIsArray = Array.isArray(object.material);\r\n    object.material = matIsArray\r\n        ? new Array(object.material.length).fill(newMaterial)\r\n        : newMaterial;\r\n};\r\n\r\n/** calculate the difference between 2 face texture files\r\n * @param {string} currentTexture\r\n * @param {string} prevTexture\r\n * @return {xyCoordinate}\r\n */\r\nexport const calculateTextureOffset = (currentTexture, prevTexture) => {\r\n    const offset = { x: 0, y: 0 };\r\n    if (currentTexture !== prevTexture) {\r\n        const [prevOffsetX, prevOffsetY] = textureOffsets[prevTexture] || [\r\n            0, 0,\r\n        ];\r\n        const [currentOffsetX, currentOffsetY] = textureOffsets[\r\n            currentTexture\r\n        ] || [0, 0];\r\n\r\n        offset.x = currentOffsetX - prevOffsetX;\r\n        offset.y = currentOffsetY - prevOffsetY;\r\n    }\r\n    return [offset.x, offset.y];\r\n};\r\n\r\n/** calculate the difference between 2 face index\r\n * @param {number} currentIdx\r\n * @param {number} prevIdx\r\n * @return {xyCoordinate}\r\n */\r\nexport const calculateIdxOffset = (currentIdx, prevIdx) => {\r\n    const offset = { x: 0, y: 0 };\r\n    if (currentIdx !== prevIdx) {\r\n        const [prevOffsetX, prevOffsetY] = idxOffsets[`face${prevIdx}`];\r\n        const [currentOffsetX, currentOffsetY] =\r\n            idxOffsets[`face${currentIdx}`];\r\n\r\n        offset.x = currentOffsetX - prevOffsetX;\r\n        offset.y = currentOffsetY - prevOffsetY;\r\n    }\r\n    return [offset.x, offset.y];\r\n};\r\n\r\n/** generate offset applying functions\r\n * @param {string} part - part to apply offset\r\n */\r\nconst applyOffset = part => (target, offset) => {\r\n    const [offsetX, offsetY] = offset;\r\n    target.traverse(child => {\r\n        if (!child.isMesh) return;\r\n\r\n        const targetGroup = child.geometry.groups?.find(\r\n            group => child.material[group.materialIndex]?.name === `mt${part}CH`\r\n        );\r\n        if (!targetGroup) return;\r\n\r\n        const { start, count } = targetGroup;\r\n        const end = start + count;\r\n        const uv = child.geometry.attributes.uv;\r\n        for (let i = start; i < end; i++) {\r\n            const u = uv.getX(i) + 0.25 * offsetX;\r\n            const v = uv.getY(i) + 0.25 * offsetY;\r\n            uv.setXY(i, u, v);\r\n        }\r\n        uv.needsUpdate = true;\r\n    });\r\n};\r\n\r\nexport const applyEyeOffset = applyOffset(\"Eye\");\r\nexport const applyMouthOffset = applyOffset(\"Mouth\");\r\n// export const applyBodyOffset = applyOffset(\"BodyAll\");\r\n\r\n/** generate texture applying functions\r\n * @param {string} part - part to apply offset\r\n */\r\nconst applyTexture =\r\n    part =>\r\n    (target, { materialType, textureId }) => {\r\n        const texturePath = getTexturePath(textureId);\r\n        const texture = new THREE.TextureLoader().load(texturePath);\r\n        texture.encoding = THREE.sRGBEncoding;\r\n\r\n        const materialParams = {\r\n            map: texture,\r\n        };\r\n        const newMaterial = createNewMaterial(materialType, materialParams);\r\n        target.traverse(child => {\r\n            if (child.name !== \"mBodyAll\" || child.geometry.groups.length !== 3)\r\n                return;\r\n\r\n            const targetGroup = child.geometry.groups.find(\r\n                group =>\r\n                    child.material[group.materialIndex].name === `mt${part}CH`\r\n            );\r\n            if (!targetGroup) return;\r\n\r\n            const { materialIndex } = targetGroup;\r\n            const oldMaterial = child.material[materialIndex];\r\n            newMaterial.name = oldMaterial.name;\r\n\r\n            child.material[materialIndex] = newMaterial;\r\n        });\r\n    };\r\n\r\nexport const applyEyeTexture = applyTexture(\"Eye\");\r\nexport const applyMouthTexture = applyTexture(\"Mouth\");\r\n// export const applyBodyTexture = applyTexture(\"BodyAll\");\r\n\r\n/** get animation modifiers from a list of modifiers\r\n * @param {Array<string>} modList\r\n * @return {AniModifier} object containing values to modify animation\r\n */\r\nconst getAniModifiers = modList => {\r\n    /**\r\n     * @type {FaceChangeArray}\r\n     */\r\n    const faceChanges = [];\r\n    let timeScale = 1,\r\n        repetitions = 1;\r\n\r\n    modList.forEach(mod => {\r\n        const [key, value] = mod.split(\"=\");\r\n        if (key === \"ts\") {\r\n            timeScale = parseFloat(value);\r\n        }\r\n        if (key === \"r\") {\r\n            repetitions = parseInt(value);\r\n        }\r\n        if (key.includes(\"-\")) {\r\n            const [part, time] = key.split(\"-\");\r\n            const faceMod = { time: parseFloat(time) };\r\n            const indexName = `${part === \"e\" ? \"eye\" : \"mouth\"}Idx`;\r\n            faceMod[indexName] = value;\r\n            faceChanges.push(faceMod);\r\n        }\r\n    });\r\n\r\n    return {\r\n        timeScale,\r\n        repetitions,\r\n        faceChanges: processFaceChanges(faceChanges),\r\n    };\r\n};\r\n\r\n/** get animation data from single animation code\r\n * @param {string} code - single animation code\r\n * @return {AniListItem}\r\n */\r\nconst getAniData = code => {\r\n    const [aniName, ...modList] = code.split(\"&\");\r\n    const modifiers = getAniModifiers(modList);\r\n    return { aniName, ...modifiers };\r\n};\r\n\r\n/** turn chain animation code to a list of animation name and modifiers\r\n * @param {string} code\r\n * @return {AniList}\r\n */\r\nexport const analyzeChainCode = code => {\r\n    if (!code) return [];\r\n\r\n    const aniCodes = code.split(\">\");\r\n    const aniList = aniCodes.map(getAniData);\r\n\r\n    return aniList;\r\n};\r\n\r\n/** simplify and sort a face change array\r\n * @param {FaceChangeArray} faceChanges\r\n * @return {FaceChangeArray} simplified and sorted face change array\r\n */\r\nexport const processFaceChanges = faceChanges => {\r\n    if (!faceChanges.length) return faceChanges;\r\n\r\n    const sorted = faceChanges.sort((a, b) => a.time - b.time);\r\n    const timeStamps = new Set(faceChanges.map(change => change.time));\r\n    if (faceChanges.length === timeStamps.size) {\r\n        sorted.forEach(change => {\r\n            change.id = nanoid();\r\n        });\r\n        return sorted;\r\n    }\r\n\r\n    /**\r\n     * @type {FaceChangeArray}\r\n     */\r\n    const simplified = [];\r\n    timeStamps.forEach(time => {\r\n        let output = { time, id: nanoid(), eyeIdx: NaN, mouthIdx: NaN };\r\n        const changes = sorted.filter(change => change.time === time);\r\n        changes.forEach(change => (output = Object.assign(output, change)));\r\n        simplified.push(output);\r\n    });\r\n    return simplified;\r\n};\r\n\r\n/** extend face change array if repetitions > 1\r\n * @param {FaceChangeArray} faceChanges - face change array\r\n * @param {number} repetitions - number of repetitions\r\n * @return {FaceChangeArray} extended face change array\r\n */\r\nexport const getFaceChangesQueue = (faceChanges, repetitions) => {\r\n    if (!faceChanges) return [];\r\n    if (repetitions === 1) return [...faceChanges];\r\n    // [0, 100, 200,...]\r\n    const timeOffset = new Array(repetitions).fill().map((_, i) => i * 100);\r\n\r\n    /** offset the time of the whole face change array\r\n     * @param {number} offset\r\n     * @return {FaceChangeArray} offsetted array\r\n     */\r\n    const offsetFaceChanges = offset =>\r\n        faceChanges.map(({ time, id, ...others }) => ({\r\n            ...others,\r\n            time: time + offset,\r\n        }));\r\n\r\n    return timeOffset.flatMap(offsetFaceChanges);\r\n};\r\n\r\n/** convert animation chain code to AnimationChain\r\n * @param {string} code - animation chain code\r\n * @param {string} name - animation name\r\n * @return {AnimationChain}\r\n */\r\nexport const chainCodeToList = (code, name) => {\r\n    const aniList = analyzeChainCode(code);\r\n    const length = aniList.length;\r\n    const output = aniList.map((ani, i) => {\r\n        const { aniName, timeScale, repetitions, faceChanges } = ani;\r\n        const partName = name.concat(length > 1 ? `#${i + 1}` : \"\");\r\n        /**\r\n         * @type {AniChainItem}\r\n         */\r\n        const listItem = {\r\n            name: partName,\r\n            id: nanoid(),\r\n            aniName,\r\n            timeScale,\r\n            repetitions,\r\n            faceChanges,\r\n        };\r\n        return listItem;\r\n    });\r\n    return output;\r\n};\r\n\r\n/** create gradient map for toon material\r\n * @param {number} nTones - number of tones\r\n */\r\nexport const createGradientMap = nTones => {\r\n    const colors = new Uint8Array(nTones).map((_, i) => (i * 256) / nTones);\r\n    const map = new THREE.DataTexture(colors, nTones, 1, THREE.LuminanceFormat);\r\n    map.minFilter = THREE.NearestFilter;\r\n    map.magFilter = THREE.NearestFilter;\r\n    map.generateMipmaps = false;\r\n\r\n    return map;\r\n};\r\n\r\n/** apply a parameter change to all material of input array\r\n * @param {Array} materials - array of materials\r\n * @param {[paramName: string, value:*]} param parameters to apply\r\n */\r\nexport const applyMaterialParam = (materials, param) => {\r\n    const [key, value] = param;\r\n    let handler;\r\n    const needsUpdate = needsUpdateParams.includes(key);\r\n\r\n    switch (key) {\r\n        case \"gradientMap\":\r\n            const nTones = parseInt(value);\r\n            const newMap = nTones ? createGradientMap(nTones) : null;\r\n            handler = mat => (mat.gradientMap = newMap);\r\n            break;\r\n        case \"useTexture\":\r\n            handler = value\r\n                ? mat => {\r\n                      mat.map = mat.userData.backupMap;\r\n                      mat.userData.backupMap = null;\r\n                  }\r\n                : mat => {\r\n                      if (mat.map) mat.userData.backupMap = mat.map;\r\n                      mat.map = null;\r\n                  };\r\n            break;\r\n        case \"matcap\":\r\n            const matcapPromise = loadMatcap(value);\r\n            handler = mat => {\r\n                matcapPromise.then(matcap => {\r\n                    mat.matcap = matcap;\r\n                    mat.needsUpdate = true;\r\n                });\r\n            };\r\n            break;\r\n        default:\r\n            const isColor = matColorParams.includes(key);\r\n            handler = mat =>\r\n                (mat[key] = isColor ? new THREE.Color(value) : value);\r\n    }\r\n\r\n    materials.forEach(mat => {\r\n        handler(mat);\r\n        mat.needsUpdate = needsUpdate;\r\n    });\r\n};\r\n\r\n/** update model's material parameters\r\n * @param {THREE.Group} model\r\n * @param {{ prevParams?: {}, params: {} }} data\r\n */\r\nexport const updateMatParams = (model, { prevParams = {}, params }) => {\r\n    const materials = getMaterial(model);\r\n    const updated = getUpdated(prevParams, params);\r\n    updated.forEach(update => applyMaterialParam(materials, update));\r\n};\r\n\r\n/** create light from params\r\n * @param {LightParam} params\r\n * @return {THREE.Light}\r\n */\r\nexport const createLight = params => {\r\n    const { type, color, intensity, ...others } = params;\r\n\r\n    const constructor = `${type}Light`;\r\n    const light = new THREE[constructor](color, intensity);\r\n\r\n    for (const [key, value] of Object.entries(others)) {\r\n        if (key === \"position\") {\r\n            const setValue = value.map(v => v || 0);\r\n            light.position.set(...setValue);\r\n            continue;\r\n        }\r\n        light[key] = value;\r\n    }\r\n\r\n    return light;\r\n};\r\n\r\n/** replace model's old texture with a new texture from provided path\r\n * @param {THREE.Group} target - object to replace texture\r\n * @param {Object} params\r\n * @param {string} params.oldTexture - name of texture to be replaced\r\n * @param {string} params.texturePath - path to new texture file\r\n */\r\nexport const replaceTexture = async (target, { oldTexture, texturePath }) => {\r\n    const newTexture = await loadTexture(texturePath);\r\n    newTexture.encoding = THREE.sRGBEncoding;\r\n\r\n    const material = getMaterial(target);\r\n    material.forEach(mat => {\r\n        const textureName = mat.map?.name;\r\n        if (textureName?.includes(oldTexture)) {\r\n            mat.map?.dispose?.();\r\n            mat.map = newTexture;\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * @param {string} modCode\r\n */\r\nconst analyzeModelModCode = modCode => {\r\n    const output = {};\r\n    const cmds = modCode.split(\";\").map(str => str.trim());\r\n\r\n    cmds.forEach(cmd => {\r\n        const [opcode, ...args] = cmd.split(\" \");\r\n        const outArgs = args.join(\"\").split(\",\");\r\n        output[opcode] = outArgs;\r\n    });\r\n\r\n    return output;\r\n};\r\n\r\n/** apply modifier code to a 3D model\r\n * @param {THREE.Group} target - model to apply\r\n * @param {string} modCode - code to apply\r\n */\r\nexport const applyMod = (target, modCode) => {\r\n    if (!modCode) return;\r\n\r\n    const meshes = getMeshes(target);\r\n    const { show, hide } = analyzeModelModCode(modCode);\r\n\r\n    meshes.forEach(mesh => {\r\n        if (hide?.includes(mesh.name)) {\r\n            mesh.visible = false;\r\n            const outline = mesh.children?.find?.(\r\n                ({ name }) => name === \"outline\"\r\n            );\r\n            outline && (outline.visible = false);\r\n        }\r\n        if (show?.includes(mesh.name)) {\r\n            mesh.visible = true;\r\n            const outline = mesh.children?.find?.(\r\n                ({ name }) => name === \"outline\"\r\n            );\r\n            outline && (outline.visible = true);\r\n        }\r\n    });\r\n};\r\n\r\n/** log the updated values to console\r\n * @param {{ }} prev - previous state\r\n * @param {{ }} current - current state\r\n */\r\nexport const logUpdate = (prev, current) => {\r\n    const updated = getUpdated(prev, current);\r\n    updated.forEach(([key, value]) => {\r\n        const oldValue = prev[key];\r\n        const subkeys = Object.keys(value);\r\n\r\n        const isSingleValue = subkeys.length === 0 || typeof value === \"string\";\r\n        if (isSingleValue) {\r\n            console.log(\r\n                `${key}: ${JSON.stringify(oldValue)} to ${JSON.stringify(\r\n                    value\r\n                )}`\r\n            );\r\n            return;\r\n        }\r\n        subkeys.forEach(subkey => {\r\n            if (oldValue[subkey] === value[subkey]) return;\r\n\r\n            console.log(\r\n                `${key}.${subkey}: ${JSON.stringify(\r\n                    oldValue[subkey]\r\n                )} to ${JSON.stringify(value[subkey])}`\r\n            );\r\n        });\r\n    });\r\n};\r\n","import { isDragon, isCharaWithAni } from \"../helpers\";\r\nimport { DEFAULT_ADV_ANI, incompatibleModels } from \"../consts\";\r\n\r\n/** get the default animation code base on model ID\r\n * @param {string} modelId\r\n * @return {Promise<string | undefined>}\r\n */\r\nexport const getDefaultAni = async modelId => {\r\n    if (isDragon(modelId)) return getDefaultDragonAni(modelId);\r\n\r\n    if (modelId.startsWith(\"h\") || incompatibleModels.has(modelId))\r\n        return getDefaultEnemyAni(modelId);\r\n\r\n    if (isCharaWithAni(modelId)) return DEFAULT_ADV_ANI;\r\n\r\n    return \"\";\r\n};\r\n\r\n/**\r\n * @param {string} modelId\r\n * @return {Promise<string | undefined>}\r\n */\r\nconst getDefaultDragonAni = async modelId => {\r\n    const { default: dragonAni } = await import(\r\n        /* webpackChunkName: \"aniDragon\" */\r\n        \"data/aniDragon\"\r\n    );\r\n\r\n    return dragonAni[modelId]?.[0].code;\r\n};\r\n\r\n/**\r\n * @param {string} modelId\r\n * @return {Promise<string | undefined>}\r\n */\r\nconst getDefaultEnemyAni = async modelId => {\r\n    const { default: enemyAni } = await import(\r\n        /* webpackChunkName: \"aniEnemies\" */\r\n        \"data/aniEnemies\"\r\n    );\r\n\r\n    return enemyAni[modelId]?.[0].code;\r\n};\r\n\r\nexport default getDefaultAni;\r\n","/** default camera coordinates\r\n * @type {{ [key: string]: xyzCoordinate }}\r\n */\r\nexport const cameraPositions = {\r\n    c: [0, 0.5, 1.5],\r\n    d: [0, 1.5, 6],\r\n    w: [2, 0, 0],\r\n    b: [1, 0.5, 6],\r\n    e: [1, 1, 4],\r\n    h: [0, 1, 4],\r\n    o: [0, 0.5, 8],\r\n    r: [3, 3, 20],\r\n\r\n    c100034_01: [0, 0.5, 1.75],\r\n    c110379_01: [0, 0.75, 2],\r\n    d200017_01: [0, 1, 4],\r\n    d210001_01: [0, 1, 4],\r\n    d210002_01: [0, 1, 4],\r\n    d210003_01: [0, 1, 4],\r\n    d210004_01: [0, 1, 4],\r\n    d210005_01: [0, 1, 4],\r\n    d210020_01: [0, 2, 6],\r\n    d210038_01: [0, 1, 4],\r\n    d210039_01: [0, 1, 4],\r\n    d210040_01: [0, 1, 4],\r\n    d210041_01: [0, 1, 4],\r\n    d210042_01: [0, 1, 4],\r\n    d210048_01: [0, 2, 8],\r\n    d210052_01: [0, 2, 8],\r\n    d210054_01: [0, 1.5, 6],\r\n    d210072_01: [0, 1, 4],\r\n    d210076_01: [0, 2, 6],\r\n    d210077_01: [0, 2, 6],\r\n    d210078_01: [0, 6, 20],\r\n    d210079_01: [0, 2, 6],\r\n    d210081_01: [0, 2, 6],\r\n    d210082_01: [0, 1.5, 4],\r\n    d210087_01: [0, 2, 6],\r\n    d210093_01: [0, 1, 3],\r\n    d210094_01: [0, 1.5, 6],\r\n    d210095_01: [0, 1, 4],\r\n    d210102_01: [0, 2, 6],\r\n    d210103_01: [0, 4, 8],\r\n    d210104_01: [0, 1, 4],\r\n    d210109_01: [0, 1, 4],\r\n    d210111_01: [0, 0.5, 1.5],\r\n    d210112_01: [0, 4, 8],\r\n    d210113_01: [0, 1, 4],\r\n    d210114_01: [0, 6, 20],\r\n    d210115_01: [0, 2, 4],\r\n    d210116_01: [0, 2, 6],\r\n    d210117_01: [0, 2, 6],\r\n    d210118_01: [0, 1, 2],\r\n    d210123_01: [0, 3, 9],\r\n    d210125_01: [0, 1.5, 5],\r\n    d210126_01: [0, 2, 8],\r\n    d210127_01: [0, 0.5, 1.5],\r\n    d210128_01: [0, 0.5, 1.5], // Puppy\r\n    d210133_01: [0, 0.5, 1.5],\r\n    d210146_01: [0, 0.5, 1.5],\r\n    d210136_01: [0, 6, 20],\r\n    d210142_01: [0, 2, 4],\r\n    d210147_01: [0, 1.5, 6.5],\r\n    d210152_01: [0, 1.5, 4],\r\n\r\n    h0010001: [6, 0.5, 8],\r\n    h0010001_02: [2, 0, 0],\r\n    h0040101: [1, 0.5, 4],\r\n    h0080501: [0, 2, 5],\r\n    h0090501: [0, 2, 5],\r\n    h0100301: [0, 1.5, 4],\r\n    h0110401: [0, 3.5, 12],\r\n    h0120201: [0, 2, 5],\r\n    r0070401: [30, 30, 100],\r\n    r0070501: [30, 30, 100],\r\n    r0080401: [1, 2, 5],\r\n\r\n    smith: [1, 1, 2],\r\n};\r\n\r\nexport default cameraPositions;\r\n","import { useState, useCallback } from \"react\";\r\n\r\n/** custom hook for a boolean state\r\n * @param {Boolean} initVal - initial value, default is false\r\n * @return {[state: Boolean, toggleFunction: Function]}\r\n */\r\nfunction useToggleState(initVal = false) {\r\n    const [state, setState] = useState(initVal);\r\n    const toggleState = useCallback(() => {\r\n        setState(state => !state);\r\n    }, [setState]);\r\n    return [state, toggleState];\r\n}\r\n\r\nexport default useToggleState;\r\n","/** convert hex color code to rgb triplet\r\n * @param {ColorCode} hex\r\n * @return {RGBTriplet}\r\n */\r\nconst hexToRgb = hex => {\r\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n    return result\r\n        ? {\r\n              r: parseInt(result[1], 16),\r\n              g: parseInt(result[2], 16),\r\n              b: parseInt(result[3], 16),\r\n          }\r\n        : null;\r\n};\r\n\r\n/**\r\n * @param {RGBTriplet} color\r\n */\r\nconst getBrightness = ({ r, g, b }) => (r * 299 + g * 587 + b * 114) / 1000;\r\n\r\n/** get the suitable text color for a given background color\r\n * @param {ColorCode | 'camera'} background\r\n */\r\nexport const getTextColor = background => {\r\n    if (background === \"camera\") return \"#ffffff\";\r\n\r\n    const rgb = hexToRgb(background);\r\n    return getBrightness(rgb) > 128 ? \"#000000\" : \"#ffffff\";\r\n};\r\n\r\nexport default getTextColor;\r\n"],"sourceRoot":""}