{"version":3,"sources":["helpers/downloadBlob.js","components/viewers/AniViewer.js","components/viewers/AdvViewer.js"],"names":["downloadBlob","blob","fileName","url","URL","createObjectURL","a","document","createElement","style","display","href","download","body","appendChild","click","window","revokeObjectURL","removeChild","AniViewer","afterMainModelLoad","saveMainModelInitState","addAnimation","afterMainModelUpdate","updateModel","prev","current","updateMainModel","model","updateAnimation","animation","otherUpdate","capture","enable","captureAnimation","models","main","userData","initPos","position","clone","initRot","rotation","resetFace","props","eyeIdx","mouthIdx","beforeAddAni","aniCode","code","timeScale","disableInput","mainModel","aniList","analyzeChainCode","nAni","length","mixer","THREE","_aniIdx","addEventListener","playNextAni","aniSettings","loadAnimations","animations","aniIdx","enableInput","removeAnimation","stopAllAction","copy","mediaRecorder","stop","toggleCapture","newIdx","chunks","videoStream","canvas","captureStream","codec","MediaRecorder","mimeType","ondataavailable","event","push","data","onstop","format","superBuffer","Blob","type","beforeCaptureAnimation","start","everyAnimate","dt","update","faceChanges","time","faceChangeTime","shift","this","ani","action","clipAction","currentAniSettings","repetitions","currentClipDuration","duration","setLoop","getFaceChangesQueue","map","change","setTime","play","BasicViewer","SIDES","AdvViewer","initFace","addWeapons","beforeMainModelUpdate","detachAllWeapons","attachAllWeapons","prevModel","id","updateFace","updateWeapons","modelId","_eyeIdx","_mouthIdx","DEFAULT_FACE_IDX","defaultFaceParams","mouthTexture","eyeTexture","getWeaponInfo","initWeaponLoad","weaponRight","weaponLeft","Object","assign","initAllWeapons","newInfo","analyzeWeaponCode","modelInfo","modelPath","loadWeaponR","loadModel","loadWeaponL","Promise","all","materialType","matType","forEach","side","key","weapon","weaponInfo","texturePath","flipped","changeMaterial","y","Math","PI","outlineParams","outline","outlines","createOutline","attachWeapon","boneName","traverse","child","name","includes","children","add","detachWeapon","parent","remove","updateEyeTexture","currentTexture","prevTexture","applyEyeTexture","textureId","offset","calculateTextureOffset","applyEyeOffset","updateMouthTexture","applyMouthTexture","applyMouthOffset","updateFaceTexture","eyeUpdated","mouthUpdated","applyNewModelMat","updateFaceOffset","dispose3dObject","oldIdx","calculateIdxOffset"],"mappings":"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","file":"static/js/58.725a4003.chunk.js","sourcesContent":["/**\r\n * download a blob as the given file name\r\n * @param {Blob} blob\r\n * @param {string} fileName\r\n */\r\nexport default function downloadBlob(blob, fileName) {\r\n    const url = URL.createObjectURL(blob);\r\n\r\n    const a = document.createElement(\"a\");\r\n    a.style.display = \"none\";\r\n    a.href = url;\r\n    a.download = fileName;\r\n    document.body.appendChild(a);\r\n    a.click();\r\n\r\n    window.URL.revokeObjectURL(url);\r\n    document.body.removeChild(a);\r\n}\r\n","import BasicViewer from \"./BasicViewer\";\r\n\r\nimport * as THREE from \"three\";\r\nimport {\r\n    analyzeChainCode,\r\n    loadAnimations,\r\n    getFaceChangesQueue,\r\n} from \"helpers/viewerHelpers\";\r\n\r\nimport downloadBlob from \"helpers/downloadBlob\";\r\n\r\n/**\r\n *  Extension of Base Viewer that adds:\r\n *    - Animation\r\n *    - Recording Animation\r\n */\r\nexport class AniViewer extends BasicViewer {\r\n    afterMainModelLoad = () => {\r\n        this.saveMainModelInitState();\r\n        this.addAnimation();\r\n    };\r\n\r\n    afterMainModelUpdate = () => {\r\n        this.saveMainModelInitState();\r\n        this.addAnimation();\r\n    };\r\n\r\n    /**\r\n     * @param {ViewerProps} prev\r\n     * @param {ViewerProps} current\r\n     */\r\n    updateModel = async (prev, current) => {\r\n        await this.updateMainModel(prev.model, current.model);\r\n        this.updateAnimation(prev.animation, current.animation);\r\n    };\r\n\r\n    /**\r\n     * @param {ViewerProps} prev\r\n     * @param {ViewerProps} current\r\n     */\r\n    otherUpdate = (prev, current) => {\r\n        // Capture\r\n        if (current.capture.enable && !prev.capture.enable) {\r\n            this.captureAnimation();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * save main model's initial position and rotation\r\n     */\r\n    saveMainModelInitState = () => {\r\n        const model = this.models.main;\r\n        model.userData.initPos = model.position.clone();\r\n        model.userData.initRot = model.rotation.clone();\r\n    };\r\n\r\n    /**\r\n     * play animation stored in this.animations[newIdx]\r\n     * @param {number} newIdx\r\n     */\r\n    set aniIdx(newIdx) {\r\n        this._aniIdx = newIdx;\r\n\r\n        const { mixer } = this;\r\n        mixer.stopAllAction();\r\n\r\n        const ani = this.animations[newIdx];\r\n        const action = mixer.clipAction(ani);\r\n        const currentAniSettings = this.aniSettings[newIdx];\r\n        const { timeScale, repetitions, faceChanges } = currentAniSettings;\r\n        const currentClipDuration = ani.duration;\r\n\r\n        action.setLoop(THREE.LoopRepeat, repetitions);\r\n        action.timeScale = timeScale;\r\n        action.time = 0;\r\n\r\n        this.faceChanges = getFaceChangesQueue(faceChanges, repetitions);\r\n        this.faceChangeTime = this.faceChanges.map(\r\n            change => (currentClipDuration * change.time) / 100\r\n        );\r\n\r\n        mixer.setTime(0);\r\n        action.play();\r\n    }\r\n\r\n    /**\r\n     * reset model's face to the ones specified in model setting\r\n     */\r\n    resetFace = () => {\r\n        const { eyeIdx, mouthIdx } = this.props.model;\r\n        this.eyeIdx = eyeIdx;\r\n        this.mouthIdx = mouthIdx;\r\n    };\r\n\r\n    /**\r\n     * @param {number} newIdx\r\n     */\r\n    set eyeIdx(newIdx) {}\r\n\r\n    /**\r\n     * @param {number} newIdx\r\n     */\r\n    set mouthIdx(newIdx) {}\r\n\r\n    /**\r\n     * called before animation is attached\r\n     */\r\n    beforeAddAni = () => {\r\n        this.resetFace();\r\n    };\r\n\r\n    /**\r\n     * load and attach animations\r\n     */\r\n    addAnimation = async () => {\r\n        this.beforeAddAni();\r\n\r\n        const { code: aniCode, timeScale } = this.props.animation;\r\n        if (!aniCode) return;\r\n\r\n        this.disableInput();\r\n\r\n        const mainModel = this.models.main;\r\n        const aniList = analyzeChainCode(aniCode);\r\n        /**\r\n         * number of currently loaded animations\r\n         */\r\n        this.nAni = aniList.length;\r\n\r\n        mainModel.mixer = new THREE.AnimationMixer(mainModel);\r\n        /**\r\n         * @type {THREE.AnimationMixer}\r\n         */\r\n        this.mixer = mainModel.mixer;\r\n\r\n        this._aniIdx = 0;\r\n        mainModel.mixer.timeScale = timeScale; // Global timeScale\r\n        mainModel.mixer.addEventListener(\"finished\", this.playNextAni);\r\n        this.aniSettings = aniList;\r\n\r\n        /**\r\n         * @type {THREE.AnimationClip[]}\r\n         */\r\n        this.animations = await loadAnimations(aniList);\r\n\r\n        // play first animation\r\n        this.aniIdx = 0;\r\n        this.enableInput();\r\n    };\r\n\r\n    /**\r\n     * remove all loaded animation\r\n     */\r\n    removeAnimation = () => {\r\n        const mainModel = this.models.main;\r\n        mainModel.mixer?.stopAllAction?.();\r\n\r\n        // Reset position and rotation to initial value\r\n        const { initPos, initRot } = mainModel.userData;\r\n        mainModel.position.copy(initPos);\r\n        mainModel.rotation.copy(initRot);\r\n\r\n        this.mixer = null;\r\n        this.animations = [];\r\n        this.aniSettings = [];\r\n    };\r\n\r\n    /**\r\n     * play the next animation stored in this.animations\r\n     */\r\n    playNextAni = () => {\r\n        const { nAni } = this;\r\n        // if capturing and finished recording current chain, stop capturing and set capture flag back to false\r\n        const finishedRecording =\r\n            this.props.capture.enable && this._aniIdx === nAni - 1;\r\n        if (finishedRecording) {\r\n            this.mediaRecorder.stop();\r\n            this.props.toggleCapture();\r\n        }\r\n        const newIdx = (this._aniIdx + 1) % nAni;\r\n        this.aniIdx = newIdx;\r\n    };\r\n\r\n    /**\r\n     * update animation and global time scale\r\n     * @param {ViewerProps[\"animation\"]} prev\r\n     * @param {ViewerProps[\"animation\"]} current\r\n     */\r\n    updateAnimation = (prev, current) => {\r\n        const { code, timeScale } = current;\r\n        if (prev.code !== code) {\r\n            this.removeAnimation();\r\n            this.addAnimation();\r\n            return;\r\n        }\r\n        // Update timeScale if animation not changed\r\n        if (prev.timeScale !== timeScale) {\r\n            this.mixer.timeScale = timeScale;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * capture current animation and save as video\r\n     */\r\n    captureAnimation = () => {\r\n        /**\r\n         * @type {Blob[]}\r\n         */\r\n        this.chunks = [];\r\n        this.videoStream = this.canvas.captureStream(30);\r\n\r\n        if (!this.mediaRecorder) {\r\n            const { codec } = this.props.capture;\r\n            this.mediaRecorder = new MediaRecorder(this.videoStream, {\r\n                mimeType: codec,\r\n            });\r\n            this.mediaRecorder.ondataavailable = event =>\r\n                this.chunks.push(event.data);\r\n            this.mediaRecorder.onstop = () => {\r\n                this.enableInput();\r\n\r\n                const { format } = this.props.capture;\r\n\r\n                const superBuffer = new Blob(this.chunks, {\r\n                    type: `video/${format}`,\r\n                });\r\n                downloadBlob(superBuffer, `animation.${format}`);\r\n            };\r\n        }\r\n        this.disableInput(\"Recording\");\r\n        this.beforeCaptureAnimation();\r\n        // play first animation and start capturing\r\n        this.aniIdx = 0;\r\n        this.mediaRecorder.start();\r\n    };\r\n\r\n    /**\r\n     * called before animation capture\r\n     */\r\n    beforeCaptureAnimation = () => void 0;\r\n\r\n    everyAnimate = dt => {\r\n        this.mixer?.update(dt);\r\n\r\n        if (this.faceChanges && this.faceChanges.length) {\r\n            const elapsedTime = this.mixer.time;\r\n            const nextFaceChangeTime = this.faceChangeTime[0];\r\n            if (elapsedTime >= nextFaceChangeTime) {\r\n                this.faceChangeTime.shift();\r\n                const { eyeIdx, mouthIdx } = this.faceChanges.shift();\r\n                this.eyeIdx = eyeIdx;\r\n                this.mouthIdx = mouthIdx;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nexport default AniViewer;\r\n","import AniViewer from \"./AniViewer\";\r\n\r\nimport { DEFAULT_FACE_IDX } from \"helpers/consts\";\r\nimport {\r\n    calculateTextureOffset,\r\n    calculateIdxOffset,\r\n    analyzeWeaponCode,\r\n    loadModel,\r\n    applyEyeTexture,\r\n    applyMouthTexture,\r\n    applyEyeOffset,\r\n    applyMouthOffset,\r\n    dispose3dObject,\r\n    createOutline,\r\n    changeMaterial,\r\n} from \"helpers/viewerHelpers\";\r\n\r\nconst SIDES = [\"Right\", \"Left\"];\r\n\r\n/**\r\n *  Extension of Ani Viewer that adds:\r\n *    - Weapons\r\n *    - Face Texture\r\n *    - Face offset\r\n */\r\nexport class AdvViewer extends AniViewer {\r\n    /**\r\n     * @param {ViewerProps} props\r\n     */\r\n    constructor(props) {\r\n        super(props);\r\n        this._eyeIdx = this._mouthIdx = DEFAULT_FACE_IDX;\r\n    }\r\n\r\n    afterMainModelLoad = () => {\r\n        this.saveMainModelInitState();\r\n        this.initFace();\r\n        this.addWeapons();\r\n        this.addAnimation();\r\n    };\r\n\r\n    beforeMainModelUpdate = () => {\r\n        this.detachAllWeapons();\r\n    };\r\n\r\n    afterMainModelUpdate = () => {\r\n        this.saveMainModelInitState();\r\n        this.initFace();\r\n        this.attachAllWeapons();\r\n        this.addAnimation();\r\n    };\r\n\r\n    updateModel = async (prev, current) => {\r\n        if (prev === current) return;\r\n\r\n        const prevModel = prev.model;\r\n        const { model } = current;\r\n        await this.updateMainModel(prevModel, model);\r\n\r\n        if (prevModel.id === model.id) {\r\n            this.updateFace(prevModel, model);\r\n        }\r\n        this.updateWeapons(prevModel, model);\r\n        this.updateAnimation(prev.animation, current.animation);\r\n    };\r\n\r\n    /**\r\n     * initialize facial expressions\r\n     */\r\n    initFace = () => {\r\n        const modelId = this.props.model.id;\r\n        this._eyeIdx = this._mouthIdx = DEFAULT_FACE_IDX;\r\n        const defaultFaceParams = {\r\n            mouthTexture: modelId,\r\n            mouthIdx: DEFAULT_FACE_IDX,\r\n            eyeTexture: modelId,\r\n            eyeIdx: DEFAULT_FACE_IDX,\r\n        };\r\n        this.updateFace(defaultFaceParams, this.props.model);\r\n    };\r\n\r\n    /**\r\n     * add specified weapons\r\n     */\r\n    addWeapons = async () => {\r\n        this.getWeaponInfo();\r\n\r\n        const [weaponRight, weaponLeft] = await this.initWeaponLoad();\r\n        this.models = Object.assign(this.models, { weaponRight, weaponLeft });\r\n\r\n        await this.initAllWeapons();\r\n        this.attachAllWeapons();\r\n    };\r\n\r\n    /**\r\n     * extract data from weapon code\r\n     */\r\n    getWeaponInfo = () => {\r\n        const { weaponRight, weaponLeft } = this.props.model;\r\n        const newInfo = {\r\n            weaponRight: analyzeWeaponCode(weaponRight),\r\n            weaponLeft: analyzeWeaponCode(weaponLeft),\r\n        };\r\n        this.modelInfo = Object.assign(this.modelInfo, newInfo);\r\n    };\r\n\r\n    /**\r\n     * load weapons during initialization\r\n     */\r\n    initWeaponLoad = () => {\r\n        const weaponRight = this.modelInfo.weaponRight?.modelPath;\r\n        const loadWeaponR = loadModel(weaponRight);\r\n\r\n        const weaponLeft = this.modelInfo.weaponLeft?.modelPath;\r\n        const loadWeaponL = loadModel(weaponLeft);\r\n\r\n        return Promise.all([loadWeaponR, loadWeaponL]);\r\n    };\r\n\r\n    /**\r\n     * initialize all weapons\r\n     */\r\n    initAllWeapons = async () => {\r\n        const materialType = this.matType;\r\n        SIDES.forEach(side => {\r\n            const key = `weapon${side}`;\r\n            const weapon = this.models[key];\r\n            if (!weapon) return;\r\n\r\n            const weaponInfo = this.modelInfo[key];\r\n            const { texturePath, flipped } = weaponInfo;\r\n            changeMaterial(weapon, { materialType, texturePath });\r\n            if (flipped) weapon.rotation.y += Math.PI;\r\n\r\n            const outlineParams = this.props.outline;\r\n            this.outlines[key] = createOutline(weapon, outlineParams);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * attach weapon model to main model's hand\r\n     * @param {THREE.Group} weapon - weapon model\r\n     * @param {string} side - Left or Right\r\n     */\r\n    attachWeapon = (weapon, side) => {\r\n        const boneName = `jWeapon${side[0]}`;\r\n        this.models.main.traverse(child => {\r\n            if (child.name.includes(boneName) && child.children.length === 0) {\r\n                child.add(weapon);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * attach weapons when they are loaded\r\n     */\r\n    attachAllWeapons = () => {\r\n        SIDES.forEach(side => {\r\n            const key = `weapon${side}`;\r\n            const weapon = this.models[key];\r\n            if (!weapon) return;\r\n\r\n            this.attachWeapon(weapon, side);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * detach the weapon on one side\r\n     * @param {string} side - Left or Right\r\n     */\r\n    detachWeapon = side => {\r\n        const key = `weapon${side}`;\r\n        const model = this.models[key];\r\n        if (!model) return;\r\n\r\n        model.parent.remove(model);\r\n    };\r\n\r\n    /**\r\n     * detach all weapons attached to main model\r\n     */\r\n    detachAllWeapons = () => SIDES.forEach(side => this.detachWeapon(side));\r\n\r\n    /**\r\n     * change eye texture\r\n     * @param { AdvFaceState } prev - previous state\r\n     * @param { AdvFaceState } current - current state\r\n     * @return {Boolean} whether texture was updated\r\n     */\r\n    updateEyeTexture = (prev, current) => {\r\n        const currentTexture = current.eyeTexture;\r\n        const prevTexture = prev.eyeTexture;\r\n\r\n        if (currentTexture === prevTexture) return false;\r\n\r\n        const materialType = this.matType;\r\n        applyEyeTexture(this.models.main, {\r\n            materialType,\r\n            textureId: currentTexture,\r\n        });\r\n        const offset = calculateTextureOffset(currentTexture, prevTexture);\r\n        applyEyeOffset(this.models.main, offset);\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * @param {number} newIdx\r\n     */\r\n    set eyeIdx(newIdx) {\r\n        if (!newIdx) return;\r\n\r\n        const oldIdx = this._eyeIdx;\r\n        if (newIdx === oldIdx) return;\r\n\r\n        const offset = calculateIdxOffset(newIdx, oldIdx);\r\n        applyEyeOffset(this.models.main, offset);\r\n\r\n        this._eyeIdx = newIdx;\r\n    }\r\n\r\n    /**\r\n     * change mouth texture\r\n     * @param { AdvFaceState } prev - previous state\r\n     * @param { AdvFaceState } current - current state\r\n     * @return {Boolean} whether texture was updated\r\n     */\r\n    updateMouthTexture = (prev, current) => {\r\n        const currentTexture = current.mouthTexture;\r\n        const prevTexture = prev.mouthTexture;\r\n\r\n        if (currentTexture === prevTexture) return false;\r\n\r\n        const materialType = this.matType;\r\n        applyMouthTexture(this.models.main, {\r\n            materialType,\r\n            textureId: currentTexture,\r\n        });\r\n        const offset = calculateTextureOffset(currentTexture, prevTexture);\r\n        applyMouthOffset(this.models.main, offset);\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * @param {number} newIdx\r\n     */\r\n    set mouthIdx(newIdx) {\r\n        if (!newIdx) return;\r\n\r\n        const oldIdx = this._mouthIdx;\r\n        if (newIdx === oldIdx) return;\r\n\r\n        const offset = calculateIdxOffset(newIdx, oldIdx);\r\n        applyMouthOffset(this.models.main, offset);\r\n\r\n        this._mouthIdx = newIdx;\r\n    }\r\n\r\n    /**\r\n     * update eyes and mouth texture\r\n     * @param {AdvFaceState} prev\r\n     * @param {AdvFaceState} current\r\n     */\r\n    updateFaceTexture = (prev, current) => {\r\n        const eyeUpdated = this.updateEyeTexture(prev, current);\r\n        const mouthUpdated = this.updateMouthTexture(prev, current);\r\n        if (eyeUpdated || mouthUpdated) {\r\n            const mainModel = this.models.main;\r\n            this.applyNewModelMat(mainModel);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * update uv of face mesh\r\n     * @param {AdvFaceState} params\r\n     */\r\n    updateFaceOffset = ({ eyeIdx, mouthIdx }) => {\r\n        this.eyeIdx = eyeIdx;\r\n        this.mouthIdx = mouthIdx;\r\n    };\r\n\r\n    /**\r\n     * update face texture and offset\r\n     * @param {AdvFaceState} prev\r\n     * @param {AdvFaceState} current\r\n     */\r\n    updateFace = (prev, current) => {\r\n        this.updateFaceTexture(prev, current);\r\n        this.updateFaceOffset(current);\r\n    };\r\n\r\n    /**\r\n     * add, change, or remove weapons if needed\r\n     * @param {AppModelState} prev\r\n     * @param {AppModelState} current\r\n     */\r\n    updateWeapons = async (prev, current) => {\r\n        this.disableInput();\r\n        SIDES.forEach(async side => {\r\n            const key = `weapon${side}`;\r\n            if (prev[key] === current[key]) return;\r\n\r\n            // remove and dispose old weapon\r\n            this.detachWeapon(side);\r\n            dispose3dObject(this.models[key]);\r\n\r\n            // if current weapon is empty (weapon removed)\r\n            if (!current[key]) {\r\n                this.models[key] = null;\r\n                this.modelInfo[key] = \"\";\r\n                // remove reference to outline\r\n                this.outlines[key] = null;\r\n                return;\r\n            }\r\n\r\n            // load new weapon\r\n            this.modelInfo[key] = analyzeWeaponCode(current[key]);\r\n            const { modelPath, texturePath, flipped } = this.modelInfo[key];\r\n\r\n            // load new model\r\n            const model = await loadModel(modelPath);\r\n            this.models[key] = model;\r\n\r\n            // process new weapon\r\n            const materialType = this.matType;\r\n            changeMaterial(model, { materialType, texturePath });\r\n            this.applyNewModelMat(model);\r\n\r\n            if (flipped) {\r\n                model.rotation.y += Math.PI;\r\n            }\r\n\r\n            const outlineParams = this.props.outline;\r\n            this.outlines[key] = createOutline(model, outlineParams);\r\n\r\n            this.attachWeapon(model, side);\r\n        });\r\n        this.enableInput();\r\n    };\r\n}\r\n\r\nexport default AdvViewer;\r\n"],"sourceRoot":""}