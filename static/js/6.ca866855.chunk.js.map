{"version":3,"sources":["helpers/downloadBlob.js","components/viewers/AniViewer.js","helpers/downloadURL.js","components/viewers/BasicViewer.js"],"names":["downloadBlob","blob","fileName","url","URL","createObjectURL","a","document","createElement","style","display","href","download","body","appendChild","click","window","revokeObjectURL","removeChild","AniViewer","afterMainModelLoad","saveMainModelInitState","addAnimation","afterMainModelUpdate","updateModel","prev","current","updateMainModel","model","updateAnimation","animation","otherUpdate","capture","enable","captureAnimation","models","main","userData","initPos","position","clone","initRot","rotation","resetFace","props","eyeIdx","mouthIdx","beforeAddAni","aniCode","code","timeScale","disableInput","mainModel","aniList","analyzeChainCode","nAni","length","mixer","THREE","_aniIdx","addEventListener","playNextAni","aniSettings","loadAnimations","animations","aniIdx","enableInput","removeAnimation","stopAllAction","copy","mediaRecorder","stop","onCaptureFinish","newIdx","chunks","videoStream","canvas","captureStream","codec","MediaRecorder","mimeType","ondataavailable","event","push","data","onstop","format","superBuffer","Blob","type","getDateTimeString","beforeCaptureAnimation","start","updateScene","dt","update","faceChanges","time","faceChangeTime","shift","this","ani","action","clipAction","currentAniSettings","repetitions","currentClipDuration","duration","setLoop","getFaceChangesQueue","map","change","setTime","play","BasicViewer","downloadURL","uri","addFullScreenListener","fscreen","fullscreenEnabled","toggleFullScreen","fullscreenElement","exitFullscreen","requestFullscreen","mount","removeFullScreenListener","removeEventListener","msg","setLoadingMsg","initialize","initScene","outlines","modelInfo","loadMainModel","viewport","width","innerWidth","height","innerHeight","clock","scene","background","camera","CAM_PARAMS","angle","near","far","cameraPosition","set","updateProjectionMatrix","lights","addAllLights","pixelRatio","rendererAA","antialias","alpha","outputEncoding","setPixelRatio","rendererNoAA","AAEnabled","antiAliasing","_AA","renderer","finalRenderer","setSize","domElement","controls","OrbitControls","controlsPosition","target","animate","modelId","id","modelPath","getModelPath","loadModel","basicMainProcessing","addLight","light","params","newLight","createLight","add","forEach","removeLight","remove","removeAllLights","addToScene","initTexture","texture","defaultTexture","getDefaultTexture","split","source","name","textureSource","textureName","texturePath","fbxSource","replaceTexture","oldTexture","applyModelMod","modCode","mod","applyMod","removeEffects","disableFrustumCulling","materialType","matType","isBlade","analyzeWeaponCode","changeMaterial","forced","applyNewModelMat","outlineParams","outline","createOutline","updateViewer","updateExport","export","updateCommon","updateViewport","updateOutline","updateMaterial","material","updateLights","updateAscii","ascii","updateCamera","updateControl","updatePixelRatio","AA","aspect","setVideoBackgroundSize","disposeMainModel","dispose3dObject","replaceMainModel","idChanged","beforeMainModelUpdate","updateOutlineParams","Object","values","flat","applyOutlineSettings","updatedKeys","keys","filter","key","Map","matParams","updateMatParams","prevParams","useTexture","matTypeChanged","some","showAscii","charSet","color","bgColor","invert","AsciiEffect","effect","exportModel","onExportFinish","cameraStream","screenWidth","screenAspectRatio","getVideoTracks","getSettings","camWidth","camAspectRatio","aspectRatio","videoWidth","videoHeight","video","useCameraAsBackground","navigator","mediaDevices","getUserMedia","audio","facingMode","rearCameraStream","assign","srcObject","autoplay","playsinline","videoTexture","minFilter","rotateModel","rotateSpeed","Math","PI","rotateY","getScreenshot","querySelector","toDataURL","frameId","requestAnimationFrame","getDelta","visibilityState","render","tmp","finishedInit","console","log","logUpdate","cancelAnimationFrame","renderLists","dispose","enabled","newCanvas","allParams","paramList","getParamsList","filterObject","bg","_canvas","oldCanvas","ref","el","PureComponent"],"mappings":"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","file":"static/js/6.ca866855.chunk.js","sourcesContent":["/**\r\n * download a blob as the given file name\r\n * @param {Blob} blob\r\n * @param {string} fileName\r\n */\r\nexport default function downloadBlob(blob, fileName) {\r\n    const url = URL.createObjectURL(blob);\r\n\r\n    const a = document.createElement(\"a\");\r\n    a.style.display = \"none\";\r\n    a.href = url;\r\n    a.download = fileName;\r\n    document.body.appendChild(a);\r\n    a.click();\r\n\r\n    window.URL.revokeObjectURL(url);\r\n    document.body.removeChild(a);\r\n}\r\n","import BasicViewer from \"./BasicViewer\";\r\n\r\nimport * as THREE from \"three\";\r\nimport {\r\n    analyzeChainCode,\r\n    loadAnimations,\r\n    getFaceChangesQueue,\r\n} from \"helpers/viewerHelpers\";\r\n\r\nimport { getDateTimeString } from \"helpers/helpers\";\r\n\r\nimport downloadBlob from \"helpers/downloadBlob\";\r\n\r\n/**\r\n *  Extension of Base Viewer that adds:\r\n *    - Animation\r\n *    - Recording Animation\r\n */\r\nexport class AniViewer extends BasicViewer {\r\n    afterMainModelLoad = () => {\r\n        this.saveMainModelInitState();\r\n        this.addAnimation();\r\n    };\r\n\r\n    afterMainModelUpdate = () => {\r\n        this.saveMainModelInitState();\r\n        this.addAnimation();\r\n    };\r\n\r\n    /**\r\n     * @param {ViewerProps} prev\r\n     * @param {ViewerProps} current\r\n     */\r\n    updateModel = async (prev, current) => {\r\n        await this.updateMainModel(prev.model, current.model);\r\n        this.updateAnimation(prev.animation, current.animation);\r\n    };\r\n\r\n    /**\r\n     * @param {ViewerProps} prev\r\n     * @param {ViewerProps} current\r\n     */\r\n    otherUpdate = (prev, current) => {\r\n        // Capture\r\n        if (current.capture.enable && !prev.capture.enable) {\r\n            this.captureAnimation();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * save main model's initial position and rotation\r\n     */\r\n    saveMainModelInitState = () => {\r\n        const model = this.models.main;\r\n        model.userData.initPos = model.position.clone();\r\n        model.userData.initRot = model.rotation.clone();\r\n    };\r\n\r\n    /**\r\n     * play animation stored in this.animations[newIdx]\r\n     * @param {number} newIdx\r\n     */\r\n    set aniIdx(newIdx) {\r\n        this._aniIdx = newIdx;\r\n\r\n        const { mixer } = this;\r\n        mixer.stopAllAction();\r\n\r\n        const ani = this.animations[newIdx];\r\n        const action = mixer.clipAction(ani);\r\n        const currentAniSettings = this.aniSettings[newIdx];\r\n        const { timeScale, repetitions, faceChanges } = currentAniSettings;\r\n        const currentClipDuration = ani.duration;\r\n\r\n        action.setLoop(THREE.LoopRepeat, repetitions);\r\n        action.timeScale = timeScale;\r\n        action.time = 0;\r\n\r\n        this.faceChanges = getFaceChangesQueue(faceChanges, repetitions);\r\n        this.faceChangeTime = this.faceChanges.map(\r\n            change => (currentClipDuration * change.time) / 100\r\n        );\r\n\r\n        mixer.setTime(0);\r\n        action.play();\r\n    }\r\n\r\n    /**\r\n     * reset model's face to the ones specified in model setting\r\n     */\r\n    resetFace = () => {\r\n        const { eyeIdx, mouthIdx } = this.props.model;\r\n        this.eyeIdx = eyeIdx;\r\n        this.mouthIdx = mouthIdx;\r\n    };\r\n\r\n    /**\r\n     * @param {number} newIdx\r\n     */\r\n    set eyeIdx(newIdx) {}\r\n\r\n    /**\r\n     * @param {number} newIdx\r\n     */\r\n    set mouthIdx(newIdx) {}\r\n\r\n    /**\r\n     * called before animation is attached\r\n     */\r\n    beforeAddAni = () => {\r\n        this.resetFace();\r\n    };\r\n\r\n    /**\r\n     * load and attach animations\r\n     */\r\n    addAnimation = async () => {\r\n        this.beforeAddAni();\r\n\r\n        const { code: aniCode, timeScale } = this.props.animation;\r\n        if (!aniCode) return;\r\n\r\n        this.disableInput();\r\n\r\n        const mainModel = this.models.main;\r\n        const aniList = analyzeChainCode(aniCode);\r\n        /**\r\n         * number of currently loaded animations\r\n         */\r\n        this.nAni = aniList.length;\r\n\r\n        mainModel.mixer = new THREE.AnimationMixer(mainModel);\r\n        /**\r\n         * @type {THREE.AnimationMixer}\r\n         */\r\n        this.mixer = mainModel.mixer;\r\n\r\n        this._aniIdx = 0;\r\n        mainModel.mixer.timeScale = timeScale; // Global timeScale\r\n        mainModel.mixer.addEventListener(\"finished\", this.playNextAni);\r\n        this.aniSettings = aniList;\r\n\r\n        /**\r\n         * @type {THREE.AnimationClip[]}\r\n         */\r\n        this.animations = await loadAnimations(aniList);\r\n\r\n        // play first animation\r\n        this.aniIdx = 0;\r\n        this.enableInput();\r\n    };\r\n\r\n    /**\r\n     * remove all loaded animation\r\n     */\r\n    removeAnimation = () => {\r\n        const mainModel = this.models.main;\r\n        mainModel.mixer?.stopAllAction?.();\r\n\r\n        // Reset position and rotation to initial value\r\n        const { initPos, initRot } = mainModel.userData;\r\n        mainModel.position.copy(initPos);\r\n        mainModel.rotation.copy(initRot);\r\n\r\n        this.mixer = null;\r\n        this.animations = [];\r\n        this.aniSettings = [];\r\n    };\r\n\r\n    /**\r\n     * play the next animation stored in this.animations\r\n     */\r\n    playNextAni = () => {\r\n        const { nAni } = this;\r\n        // if capturing and finished recording current chain, stop capturing and set capture flag back to false\r\n        const finishedRecording =\r\n            this.props.capture.enable && this._aniIdx === nAni - 1;\r\n        if (finishedRecording) {\r\n            this.mediaRecorder.stop();\r\n            this.props.onCaptureFinish();\r\n        }\r\n        const newIdx = (this._aniIdx + 1) % nAni;\r\n        this.aniIdx = newIdx;\r\n    };\r\n\r\n    /**\r\n     * update animation and global time scale\r\n     * @param {ViewerProps[\"animation\"]} prev\r\n     * @param {ViewerProps[\"animation\"]} current\r\n     */\r\n    updateAnimation = (prev, current) => {\r\n        const { code, timeScale } = current;\r\n        if (prev.code !== code) {\r\n            this.removeAnimation();\r\n            this.addAnimation();\r\n            return;\r\n        }\r\n        // Update timeScale if animation not changed\r\n        if (prev.timeScale !== timeScale) {\r\n            this.mixer.timeScale = timeScale;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * capture current animation and save as video\r\n     */\r\n    captureAnimation = () => {\r\n        /**\r\n         * @type {Blob[]}\r\n         */\r\n        this.chunks = [];\r\n        this.videoStream = this.canvas.captureStream(30);\r\n\r\n        if (!this.mediaRecorder) {\r\n            const { codec } = this.props.capture;\r\n            this.mediaRecorder = new MediaRecorder(this.videoStream, {\r\n                mimeType: codec,\r\n            });\r\n            this.mediaRecorder.ondataavailable = event =>\r\n                this.chunks.push(event.data);\r\n            this.mediaRecorder.onstop = () => {\r\n                this.enableInput();\r\n\r\n                const { format } = this.props.capture;\r\n\r\n                const superBuffer = new Blob(this.chunks, {\r\n                    type: `video/${format}`,\r\n                });\r\n\r\n                const fileName = `ani_${getDateTimeString()}.${format}`;\r\n\r\n                downloadBlob(superBuffer, fileName);\r\n            };\r\n        }\r\n        this.disableInput(\"Recording\");\r\n        this.beforeCaptureAnimation();\r\n        // play first animation and start capturing\r\n        this.aniIdx = 0;\r\n        this.mediaRecorder.start();\r\n    };\r\n\r\n    /**\r\n     * called before animation capture\r\n     */\r\n    beforeCaptureAnimation = () => void 0;\r\n\r\n    updateScene = dt => {\r\n        this.mixer?.update(dt);\r\n\r\n        if (this.faceChanges && this.faceChanges.length) {\r\n            const elapsedTime = this.mixer.time;\r\n            const nextFaceChangeTime = this.faceChangeTime[0];\r\n            if (elapsedTime >= nextFaceChangeTime) {\r\n                this.faceChangeTime.shift();\r\n                const { eyeIdx, mouthIdx } = this.faceChanges.shift();\r\n                this.eyeIdx = eyeIdx;\r\n                this.mouthIdx = mouthIdx;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nexport default AniViewer;\r\n","/**\r\n * download data URI as the given file name\r\n * @param {string} uri - data URI\r\n * @param {string} fileName\r\n */\r\nexport default function downloadURL(uri, fileName) {\r\n    const a = document.createElement(\"a\");\r\n    a.style.display = \"none\";\r\n    a.href = uri;\r\n    a.download = fileName;\r\n\r\n    document.body.appendChild(a);\r\n    a.click();\r\n\r\n    document.body.removeChild(a);\r\n}\r\n","import { PureComponent } from \"react\";\r\n\r\nimport * as THREE from \"three\";\r\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\r\n\r\nimport { CAM_PARAMS } from \"helpers/consts\";\r\nimport { isBlade, filterObject, getDefaultTexture } from \"helpers/helpers\";\r\nimport {\r\n    createLight,\r\n    analyzeWeaponCode,\r\n    getModelPath,\r\n    loadModel,\r\n    dispose3dObject,\r\n    createOutline,\r\n    applyOutlineSettings,\r\n    getParamsList,\r\n    changeMaterial,\r\n    updateMatParams,\r\n    removeEffects,\r\n    disableFrustumCulling,\r\n    replaceTexture,\r\n    applyMod,\r\n    logUpdate,\r\n} from \"helpers/viewerHelpers\";\r\n\r\nimport downloadURL from \"helpers/downloadURL\";\r\nimport { getDateTimeString } from \"helpers/helpers\";\r\nimport fscreen from \"fscreen\";\r\n\r\nimport { fbxSource } from \"App\";\r\n\r\n/**\r\n * Basic Viewer that supports adding / updating:\r\n *   - 1 main model\r\n *   - auto rotate\r\n *   - viewport\r\n *   - material\r\n *   - background color\r\n *   - lighting\r\n *   - anti aliasing\r\n *   - ASCII mode\r\n * @typedef {ViewerProps} Props\r\n * @extends PureComponent<Props>\r\n */\r\nclass BasicViewer extends PureComponent {\r\n    async componentDidMount() {\r\n        // window.app = this;\r\n\r\n        // const { fbx2json } = await import(\"helpers/fbx2json\");\r\n        // await fbx2json();\r\n\r\n        await this.initialize();\r\n        this.finishedInit = true;\r\n\r\n        this.addFullScreenListener();\r\n    }\r\n\r\n    /**\r\n     * @param {ViewerProps} prev\r\n     */\r\n    componentDidUpdate(prev) {\r\n        if (!this.finishedInit) return;\r\n        /**\r\n         * @type {ViewerProps}\r\n         */\r\n        const current = this.props;\r\n\r\n        // print updated props to console\r\n        console.log(\"Updated\");\r\n        logUpdate(prev, current);\r\n\r\n        this.updateViewer(prev, current);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        this.cameraStream?.getVideoTracks()[0].stop();\r\n        this.removeFullScreenListener?.();\r\n        cancelAnimationFrame(this.frameId);\r\n        dispose3dObject(this.scene);\r\n        this.renderer = null;\r\n        this.rendererAA.renderLists?.dispose();\r\n        this.rendererAA.dispose();\r\n        this.rendererAA = null;\r\n        this.rendererNoAA.renderLists?.dispose();\r\n        this.rendererNoAA.dispose();\r\n        this.rendererNoAA = null;\r\n        this.mixer = null;\r\n        this.clock = null;\r\n        this.scene = null;\r\n    }\r\n\r\n    addFullScreenListener = () => {\r\n        if (!fscreen.fullscreenEnabled) return;\r\n\r\n        const toggleFullScreen = () => {\r\n            if (!fscreen.fullscreenElement) {\r\n                fscreen.requestFullscreen(this.mount);\r\n                return;\r\n            }\r\n\r\n            fscreen.exitFullscreen();\r\n        };\r\n        this.mount?.addEventListener(\"dblclick\", () => toggleFullScreen());\r\n        this.removeFullScreenListener = () =>\r\n            this.mount?.removeEventListener(\"dblclick\", () =>\r\n                toggleFullScreen()\r\n            );\r\n    };\r\n\r\n    /**\r\n     * disable input and display a message, default is \"Loading...\"\r\n     * @param {string} [msg]\r\n     */\r\n    disableInput = msg => this.props.setLoadingMsg(msg || \"Loading...\");\r\n\r\n    /**\r\n     * remove loading message\r\n     */\r\n    enableInput = () => this.props.setLoadingMsg(\"\");\r\n\r\n    /**\r\n     * called when viewer is mounted to initialize the scene\r\n     */\r\n    initialize = async () => {\r\n        this.disableInput();\r\n\r\n        this.initScene();\r\n\r\n        this.outlines = {};\r\n        this.models = {};\r\n        this.modelInfo = {};\r\n        await this.loadMainModel();\r\n        await this.afterMainModelLoad();\r\n\r\n        this.enableInput();\r\n    };\r\n\r\n    /**\r\n     * Called after main model is loaded and added to scene\r\n     */\r\n    afterMainModelLoad = () => void 0;\r\n\r\n    /**\r\n     * initialize scene, display size, floor, clock, light, camera, controls, and renderers\r\n     */\r\n    initScene = () => {\r\n        // viewport\r\n        this.viewport = this.props.viewport || {\r\n            width: window.innerWidth,\r\n            height: window.innerHeight,\r\n        };\r\n\r\n        // clock\r\n        this.clock = new THREE.Clock();\r\n\r\n        // Scene\r\n        this.scene = new THREE.Scene();\r\n        this.background = this.props.background;\r\n\r\n        // Camera\r\n        this.camera = new THREE.PerspectiveCamera(\r\n            CAM_PARAMS.angle,\r\n            this.viewport.width / this.viewport.height,\r\n            CAM_PARAMS.near,\r\n            CAM_PARAMS.far\r\n        );\r\n        /**\r\n         * @type {xyzCoordinate}\r\n         */\r\n        this.cameraPosition = this.props.cameraPosition || [2, 0, 10];\r\n        this.camera.position.set(...this.cameraPosition);\r\n        this.camera.updateProjectionMatrix();\r\n\r\n        // Light\r\n        const { lights } = this.props;\r\n        this.addAllLights(lights);\r\n\r\n        // Renderer\r\n        const { pixelRatio } = this.props;\r\n        this.rendererAA = new THREE.WebGLRenderer({\r\n            antialias: true,\r\n            alpha: true,\r\n            // logarithmicDepthBuffer: true,\r\n        });\r\n        this.rendererAA.outputEncoding = THREE.sRGBEncoding;\r\n        this.rendererAA.setPixelRatio(pixelRatio);\r\n\r\n        this.rendererNoAA = new THREE.WebGLRenderer({\r\n            antialias: false,\r\n            alpha: true,\r\n            // logarithmicDepthBuffer: true,\r\n        });\r\n        this.rendererNoAA.outputEncoding = THREE.sRGBEncoding;\r\n        this.rendererNoAA.setPixelRatio(pixelRatio);\r\n\r\n        const AAEnabled = this.props.antiAliasing;\r\n        this._AA = AAEnabled;\r\n\r\n        this.renderer = AAEnabled ? this.rendererAA : this.rendererNoAA;\r\n\r\n        this.finalRenderer = this.renderer;\r\n        const { width, height } = this.props.viewport;\r\n        this.finalRenderer.setSize(width, height);\r\n\r\n        const canvas = this.finalRenderer.domElement;\r\n        this.canvas = canvas;\r\n\r\n        // Controls\r\n        this.controls = new OrbitControls(this.camera, this.mount);\r\n        /**\r\n         * @type {xyzCoordinate}\r\n         */\r\n        this.controlsPosition = this.props.controlsPosition || [0, 0, 0];\r\n        this.controls.target.set(...this.controlsPosition);\r\n        this.controls.update();\r\n\r\n        this.animate();\r\n    };\r\n\r\n    /**\r\n     * load, and perform basic processing on main model\r\n     */\r\n    loadMainModel = async () => {\r\n        const modelId = this.props.model.id;\r\n        this.modelInfo.main = modelId;\r\n\r\n        const modelPath = getModelPath(modelId);\r\n        const model = await loadModel(modelPath);\r\n        this.models.main = model;\r\n\r\n        await this.basicMainProcessing();\r\n        return;\r\n    };\r\n\r\n    /**\r\n     * enable / disable Anti Aliasing\r\n     * @param {Boolean} enabled\r\n     */\r\n    set AA(enabled) {\r\n        if (enabled === this._AA) return;\r\n\r\n        this._AA = enabled;\r\n        this.renderer = enabled ? this.rendererAA : this.rendererNoAA;\r\n        const { width, height } = this.viewport;\r\n        this.renderer.setSize(width, height);\r\n\r\n        if (this.props.ascii.enable) return;\r\n\r\n        this.finalRenderer = this.renderer;\r\n\r\n        const newCanvas = this.renderer.domElement;\r\n        this.canvas = newCanvas;\r\n    }\r\n\r\n    /**\r\n     * add light to scene\r\n     * @param {LightParam} light\r\n     */\r\n    addLight = light => {\r\n        const { id, enable, ...params } = light;\r\n        if (!enable) return;\r\n\r\n        const newLight = createLight(params);\r\n\r\n        this.scene.add(newLight);\r\n        this.lights.push(newLight);\r\n    };\r\n\r\n    /**\r\n     * add lights to scene\r\n     * @param {LightParam[]} lights\r\n     */\r\n    addAllLights = lights => {\r\n        /**\r\n         * @type {THREE.Light[]}\r\n         */\r\n        this.lights = [];\r\n        lights.forEach(this.addLight);\r\n    };\r\n\r\n    /**\r\n     * remove light from scene\r\n     * @param {THREE.Light} light\r\n     */\r\n    removeLight = light => this.scene.remove(light);\r\n\r\n    /**\r\n     * remove all lights in the scene\r\n     */\r\n    removeAllLights = () => this.lights.forEach(this.removeLight);\r\n\r\n    /**\r\n     * add model to scene\r\n     * @param {THREE.Object3D} model\r\n     */\r\n    addToScene = model => this.scene?.add(model);\r\n\r\n    /**\r\n     * change main model's texture if specified\r\n     */\r\n    initTexture = async () => {\r\n        const { id: modelId, texture } = this.props.model;\r\n        if (!texture || texture === \">\") return;\r\n\r\n        const defaultTexture = getDefaultTexture(modelId);\r\n        const [source, name] = texture.split(\">\");\r\n        const textureSource = source || modelId;\r\n        const textureName = name || getDefaultTexture(textureSource);\r\n\r\n        const texturePath = `${fbxSource}/fbx/${textureSource}/${textureName}.png`;\r\n        const mainModel = this.models.main;\r\n        await replaceTexture(mainModel, {\r\n            oldTexture: defaultTexture,\r\n            texturePath,\r\n        });\r\n    };\r\n\r\n    /**\r\n     * apply modifier code to main model\r\n     */\r\n    applyModelMod = () => {\r\n        const modCode = this.props.model.mod;\r\n        modCode && applyMod(this.models.main, modCode);\r\n    };\r\n\r\n    /**\r\n     * main model basic processing:\r\n     * remove effects, change material, change texture, add outline, then add to scene\r\n     */\r\n    basicMainProcessing = async () => {\r\n        const model = this.models.main;\r\n\r\n        removeEffects(model);\r\n        disableFrustumCulling(model);\r\n\r\n        const materialType = this.matType;\r\n        const modelId = this.props.model.id;\r\n        if (isBlade(modelId)) {\r\n            const { texturePath } = analyzeWeaponCode(`${modelId}n`);\r\n            changeMaterial(model, { materialType, texturePath });\r\n        } else {\r\n            changeMaterial(model, { materialType, forced: true });\r\n        }\r\n\r\n        await this.initTexture();\r\n        this.applyModelMod();\r\n\r\n        this.applyNewModelMat(model);\r\n\r\n        const outlineParams = this.props.outline;\r\n        this.outlines.main = await createOutline(model, outlineParams);\r\n\r\n        this.addToScene(model);\r\n    };\r\n\r\n    /**\r\n     * update viewer's display\r\n     * @param {ViewerProps} prev\r\n     * @param {ViewerProps} current\r\n     */\r\n    updateViewer = async (prev, current) => {\r\n        await this.updateExport(prev.export, current.export);\r\n        this.updateCommon(prev, current);\r\n        this.updateModel(prev, current);\r\n        this.otherUpdate(prev, current);\r\n    };\r\n\r\n    /**\r\n     * update settings other than model and environment\r\n     * @param {ViewerProps} prev\r\n     * @param {ViewerProps} current\r\n     */\r\n    otherUpdate = (prev, current) => void 0;\r\n\r\n    /**\r\n     * update viewport, outline, material, lighting, ASCII,\r\n     * camera, control, background, and Anti Aliasing\r\n     * @param {ViewerProps} prev\r\n     * @param {ViewerProps} current\r\n     */\r\n    updateCommon = (prev, current) => {\r\n        this.updateViewport(prev.viewport, current.viewport);\r\n        this.updateOutline(prev.outline, current.outline);\r\n        this.updateMaterial(prev.material, current.material);\r\n        this.updateLights(prev.lights, current.lights);\r\n        this.updateAscii(prev.ascii, current.ascii);\r\n        this.updateCamera(prev.cameraPosition, current.cameraPosition);\r\n        this.updateControl(prev.controlsPosition, current.controlsPosition);\r\n        this.updatePixelRatio(prev.pixelRatio, current.pixelRatio);\r\n\r\n        // Update background color\r\n        if (prev.background !== current.background) {\r\n            this.background = current.background;\r\n        }\r\n\r\n        this.AA = current.antiAliasing;\r\n    };\r\n\r\n    /**\r\n     * update model settings\r\n     * @param {ViewerProps} prev\r\n     * @param {ViewerProps} current\r\n     */\r\n    updateModel = (prev, current) => {\r\n        this.updateMainModel(prev.model, current.model);\r\n    };\r\n\r\n    /**\r\n     * update viewport\r\n     * @param {ViewerProps[\"viewport\"]} prev\r\n     * @param {ViewerProps[\"viewport\"]} current\r\n     */\r\n    updateViewport = (prev, current) => {\r\n        const { width, height } = current;\r\n        if (prev.width === width && prev.height === height) return;\r\n\r\n        this.viewport.width = width;\r\n        this.viewport.height = height;\r\n\r\n        this.finalRenderer.setSize(width, height);\r\n        this.camera.aspect = width / height;\r\n        this.camera.updateProjectionMatrix();\r\n\r\n        this.props.background === \"camera\" && this.setVideoBackgroundSize();\r\n    };\r\n\r\n    /**\r\n     * remove from scene and dispose main model\r\n     */\r\n    disposeMainModel = () => {\r\n        const mainModel = this.models.main;\r\n        this.scene?.remove(mainModel);\r\n        dispose3dObject(mainModel);\r\n    };\r\n\r\n    /**\r\n     * replace main model\r\n     */\r\n    replaceMainModel = async () => {\r\n        this.disableInput();\r\n\r\n        this.disposeMainModel();\r\n        await this.loadMainModel();\r\n        this.applyNewModelMat(this.models.main);\r\n\r\n        this.enableInput();\r\n    };\r\n\r\n    /**\r\n     * update main model\r\n     * @param {ViewerProps[\"model\"]} prev\r\n     * @param {ViewerProps[\"model\"]} current\r\n     */\r\n    updateMainModel = async (prev, current) => {\r\n        const modelId = current.id;\r\n        const idChanged = prev.id !== modelId;\r\n        const modChanged = prev.mod !== current.mod;\r\n\r\n        modChanged && this.applyModelMod();\r\n\r\n        if (!idChanged) return;\r\n\r\n        this.beforeMainModelUpdate();\r\n        await this.replaceMainModel();\r\n        this.afterMainModelUpdate();\r\n    };\r\n\r\n    /**\r\n     * called before main model is updated\r\n     */\r\n    beforeMainModelUpdate = () => void 0;\r\n\r\n    /**\r\n     * called after main model is updated\r\n     */\r\n    afterMainModelUpdate = () => void 0;\r\n\r\n    /**\r\n     * update outline parameters\r\n     * @param {Map<string, *>} update\r\n     */\r\n    updateOutlineParams = update => {\r\n        const outlines = Object.values(this.outlines).flat();\r\n        outlines.forEach(outline => {\r\n            applyOutlineSettings(outline, update);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * update outline settings\r\n     * @param {AppOutlineState} prev - previous settings\r\n     * @param {AppOutlineState} current - current settings\r\n     */\r\n    updateOutline = (prev, current) => {\r\n        if (prev === current) return;\r\n\r\n        const updatedKeys = Object.keys(current).filter(\r\n            key => prev[key] !== current[key]\r\n        );\r\n        if (updatedKeys.length === 0) return;\r\n\r\n        const update = new Map(updatedKeys.map(key => [key, current[key]]));\r\n        this.updateOutlineParams(update);\r\n    };\r\n\r\n    /**\r\n     * get relevant parameters for the current material type\r\n     */\r\n    get matParams() {\r\n        const { type: materialType, ...allParams } = this.props.material;\r\n        const paramList = getParamsList(materialType);\r\n        return filterObject(allParams, paramList);\r\n    }\r\n\r\n    /**\r\n     * get the current material type\r\n     */\r\n    get matType() {\r\n        return this.props.material.type;\r\n    }\r\n\r\n    /**\r\n     * apply material setting to a newly loaded model\r\n     */\r\n    applyNewModelMat = model => {\r\n        const params = this.matParams;\r\n        const defaultParams = { useTexture: true };\r\n        updateMatParams(model, { prevParams: defaultParams, params });\r\n    };\r\n\r\n    /**\r\n     * update material settings\r\n     */\r\n    updateMaterial = (prev, current) => {\r\n        if (prev === current) return;\r\n\r\n        const materialType = this.matType;\r\n        const mainModel = this.models.main;\r\n\r\n        const matTypeChanged = prev.type !== materialType;\r\n        if (matTypeChanged) {\r\n            changeMaterial(this.models.main, { materialType });\r\n        }\r\n\r\n        const prevParams = matTypeChanged\r\n            ? { useTexture: prev.useTexture }\r\n            : prev;\r\n        const params = this.matParams;\r\n        updateMatParams(mainModel, { prevParams, params });\r\n    };\r\n\r\n    /**\r\n     * update lighting\r\n     * @param {LightParam[]} prev\r\n     * @param {LightParam[]} current\r\n     */\r\n    updateLights = (prev, current) => {\r\n        if (prev !== current) {\r\n            this.removeAllLights();\r\n            this.addAllLights(current);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Update ASCII settings\r\n     * @param {ViewerProps[\"ascii\"]} prev\r\n     * @param {ViewerProps[\"ascii\"]} current\r\n     */\r\n    updateAscii = async (prev, current) => {\r\n        const updated = Object.keys(prev).some(\r\n            key => prev[key] !== current[key]\r\n        );\r\n        if (!updated) return;\r\n\r\n        const { enable } = current;\r\n        if (!enable) {\r\n            this.finalRenderer = this.renderer;\r\n\r\n            const { width, height } = this.viewport;\r\n            this.renderer.setSize(width, height);\r\n\r\n            const canvas = this.renderer.domElement;\r\n            this.canvas = canvas;\r\n\r\n            return;\r\n        }\r\n\r\n        this.showAscii();\r\n    };\r\n\r\n    /**\r\n     * render scene as ASCII\r\n     */\r\n    showAscii = async () => {\r\n        const { charSet, color, bgColor, invert } = this.props.ascii;\r\n        const { AsciiEffect } = await import(\r\n            /* webpackChunkName: \"AsciiEffect\" */\r\n            \"three/examples/jsm/effects/AsciiEffect\"\r\n        );\r\n\r\n        this.effect = new AsciiEffect(this.renderer, charSet, { invert });\r\n\r\n        const { width, height } = this.viewport;\r\n        this.effect.setSize(width, height);\r\n\r\n        const canvas = this.effect.domElement;\r\n        canvas.style.color = color;\r\n        canvas.style.background = bgColor;\r\n        this.canvas = canvas;\r\n\r\n        this.finalRenderer = this.effect;\r\n    };\r\n\r\n    /**\r\n     * @param {xyzCoordinate} prev\r\n     * @param {xyzCoordinate} current\r\n     */\r\n    updateCamera = (prev, current) => {\r\n        if (prev === current) return;\r\n\r\n        this.camera.position.set(...current);\r\n        this.camera.updateProjectionMatrix();\r\n    };\r\n\r\n    /**\r\n     * @param {xyzCoordinate} prev\r\n     * @param {xyzCoordinate} current\r\n     */\r\n    updateControl = (prev, current) => {\r\n        if (prev === current) return;\r\n\r\n        this.controls.target.set(...current);\r\n        this.controls.update();\r\n    };\r\n\r\n    /**\r\n     * update renderer's pixel ratio\r\n     * @param {number} prev\r\n     * @param {number} current\r\n     */\r\n    updatePixelRatio = (prev, current) => {\r\n        if (prev === current) return;\r\n\r\n        this.rendererAA.setPixelRatio(current);\r\n        this.rendererNoAA.setPixelRatio(current);\r\n    };\r\n\r\n    /**\r\n     * @param {ViewerProps[\"export\"]} prev\r\n     * @param {ViewerProps[\"export\"]} current\r\n     */\r\n    updateExport = async (prev, current) => {\r\n        if (!current.enable || prev.enable) return;\r\n        this.disableInput(\"Exporting\");\r\n\r\n        const { exportModel } = await import(\r\n            /* webpackChunkName: \"exporter\" */ \"helpers/exportModel\"\r\n        );\r\n        await exportModel(this.models.main, current);\r\n        this.props.onExportFinish();\r\n\r\n        this.enableInput();\r\n    };\r\n\r\n    /**\r\n     * @param {ColorCode | 'transparent' | 'camera'} bg\r\n     */\r\n    set background(bg) {\r\n        switch (bg) {\r\n            case \"transparent\":\r\n                this.scene.background = null;\r\n                return;\r\n            case \"camera\":\r\n                this.useCameraAsBackground();\r\n                return;\r\n            default:\r\n                this.cameraStream?.getVideoTracks()[0].stop();\r\n                this.scene.background = new THREE.Color(bg);\r\n        }\r\n    }\r\n\r\n    setVideoBackgroundSize = () => {\r\n        if (!this.cameraStream) return;\r\n\r\n        const { width: screenWidth, height: screenHeight } = this.viewport;\r\n        const screenAspectRatio = screenWidth / screenHeight;\r\n\r\n        const {\r\n            width: camWidth,\r\n            aspectRatio: camAspectRatio,\r\n        } = this.cameraStream.getVideoTracks()[0].getSettings();\r\n\r\n        const videoWidth =\r\n            camAspectRatio > screenAspectRatio ? screenWidth : camWidth;\r\n        const videoAspectRatio =\r\n            camAspectRatio > screenAspectRatio\r\n                ? screenAspectRatio\r\n                : camAspectRatio;\r\n        const videoHeight = videoWidth / videoAspectRatio;\r\n\r\n        this.video.width = videoWidth;\r\n        this.video.height = videoHeight;\r\n    };\r\n\r\n    /**\r\n     * use hardware camera as background, rear facing is prioritized\r\n     */\r\n    useCameraAsBackground = async () => {\r\n        if (!navigator.mediaDevices?.getUserMedia) return;\r\n\r\n        const rearCameraStream = await navigator.mediaDevices?.getUserMedia({\r\n            audio: false,\r\n            video: { facingMode: \"environment\" },\r\n        });\r\n\r\n        this.cameraStream =\r\n            rearCameraStream ||\r\n            (await navigator.mediaDevices?.getUserMedia({\r\n                audio: false,\r\n                video: { facingMode: \"user\" },\r\n            }));\r\n\r\n        if (!this.cameraStream) return;\r\n\r\n        this.video = document.createElement(\"video\");\r\n\r\n        Object.assign(this.video, {\r\n            srcObject: this.cameraStream,\r\n            autoplay: true,\r\n            playsinline: true,\r\n        });\r\n\r\n        const videoTexture = new THREE.VideoTexture(this.video);\r\n        videoTexture.minFilter = THREE.LinearFilter;\r\n        this.scene.background = videoTexture;\r\n\r\n        // this.setVideoBackgroundSize();\r\n    };\r\n\r\n    /**\r\n     * set display canvas\r\n     */\r\n    set canvas(canvas) {\r\n        const oldCanvas = this._canvas;\r\n        oldCanvas && this.mount.removeChild(oldCanvas);\r\n        this.mount.appendChild(canvas);\r\n        this._canvas = canvas;\r\n    }\r\n\r\n    /**\r\n     * get currently displayed canvas\r\n     */\r\n    get canvas() {\r\n        return this._canvas;\r\n    }\r\n\r\n    /**\r\n     * rotate the floor\r\n     * @param {number} dt - time difference\r\n     */\r\n    rotateModel = dt => {\r\n        const { rotateSpeed } = this.props;\r\n        if (!rotateSpeed) return;\r\n\r\n        const angle = (rotateSpeed * dt * Math.PI) / 2;\r\n        this.models.main.rotateY(angle);\r\n    };\r\n\r\n    /**\r\n     * called during every animation frame\r\n     * @param {number} dt - time difference since last call\r\n     */\r\n    updateScene = dt => void 0;\r\n\r\n    getScreenshot = () => {\r\n        const canvas = document.querySelector(\"canvas\");\r\n        const screenshot = canvas.toDataURL(\"image/png\");\r\n\r\n        downloadURL(screenshot, `screenshot_${getDateTimeString()}.png`);\r\n    };\r\n\r\n    /**\r\n     * render loop\r\n     */\r\n    animate = () => {\r\n        this.frameId = requestAnimationFrame(this.animate);\r\n\r\n        const dt = this.clock.getDelta();\r\n        if (document.visibilityState === \"hidden\") return;\r\n\r\n        this.rotateModel(dt);\r\n\r\n        this.updateScene(dt);\r\n\r\n        this.finalRenderer.render(this.scene, this.camera);\r\n        if (window.getScreenshot) {\r\n            const tmp = this.scene.background;\r\n            this.scene.background = null;\r\n\r\n            this.finalRenderer.render(this.scene, this.camera);\r\n            this.getScreenshot();\r\n\r\n            this.scene.background = tmp;\r\n            window.getScreenshot = false;\r\n            return;\r\n        }\r\n\r\n        this.finalRenderer.render(this.scene, this.camera);\r\n    };\r\n\r\n    render() {\r\n        return (\r\n            <div\r\n                ref={el => {\r\n                    this.mount = el;\r\n                }}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default BasicViewer;\r\n"],"sourceRoot":""}