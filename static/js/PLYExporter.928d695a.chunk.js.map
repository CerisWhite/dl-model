{"version":3,"sources":["../node_modules/three/examples/jsm/exporters/PLYExporter.js"],"names":["PLYExporter","object","onDone","options","traverseMeshes","cb","traverse","child","isMesh","mesh","geometry","isBufferGeometry","Error","hasAttribute","console","warn","undefined","excludeAttributes","Object","assign","binary","littleEndian","includeNormals","includeColors","includeUVs","vertexCount","faceCount","vertices","getAttribute","normals","uvs","colors","indices","getIndex","count","includeIndices","indexOf","Math","floor","error","header","vertex","Vector3","normalMatrixWorld","Matrix3","result","headerBin","TextEncoder","encode","vertexListLength","faceListLength","output","DataView","ArrayBuffer","length","Uint8Array","buffer","set","vOffset","fOffset","writtenVertices","getNormalMatrix","matrixWorld","i","l","x","getX","y","getY","z","getZ","applyMatrix4","setFloat32","applyMatrix3","normalize","setUint8","setUint32","vertexList","faceList","line","requestAnimationFrame"],"mappings":"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","file":"static/js/PLYExporter.928d695a.chunk.js","sourcesContent":["import {\n\tMatrix3,\n\tVector3\n} from 'three';\n\n/**\n * https://github.com/gkjohnson/ply-exporter-js\n *\n * Usage:\n *  const exporter = new PLYExporter();\n *\n *  // second argument is a list of options\n *  exporter.parse(mesh, data => console.log(data), { binary: true, excludeAttributes: [ 'color' ], littleEndian: true });\n *\n * Format Definition:\n * http://paulbourke.net/dataformats/ply/\n */\n\nclass PLYExporter {\n\n\tparse( object, onDone, options ) {\n\n\t\tif ( onDone && typeof onDone === 'object' ) {\n\n\t\t\tconsole.warn( 'THREE.PLYExporter: The options parameter is now the third argument to the \"parse\" function. See the documentation for the new API.' );\n\t\t\toptions = onDone;\n\t\t\tonDone = undefined;\n\n\t\t}\n\n\t\t// Iterate over the valid meshes in the object\n\t\tfunction traverseMeshes( cb ) {\n\n\t\t\tobject.traverse( function ( child ) {\n\n\t\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\t\tconst mesh = child;\n\t\t\t\t\tconst geometry = mesh.geometry;\n\n\t\t\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometry.hasAttribute( 'position' ) === true ) {\n\n\t\t\t\t\t\tcb( mesh, geometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// Default options\n\t\tconst defaultOptions = {\n\t\t\tbinary: false,\n\t\t\texcludeAttributes: [], // normal, uv, color, index\n\t\t\tlittleEndian: false\n\t\t};\n\n\t\toptions = Object.assign( defaultOptions, options );\n\n\t\tconst excludeAttributes = options.excludeAttributes;\n\t\tlet includeNormals = false;\n\t\tlet includeColors = false;\n\t\tlet includeUVs = false;\n\n\t\t// count the vertices, check which properties are used,\n\t\t// and cache the BufferGeometry\n\t\tlet vertexCount = 0;\n\t\tlet faceCount = 0;\n\t\tobject.traverse( function ( child ) {\n\n\t\t\tif ( child.isMesh === true ) {\n\n\t\t\t\tconst mesh = child;\n\t\t\t\tconst geometry = mesh.geometry;\n\n\t\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.PLYExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\t\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t\tif ( vertices === undefined ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvertexCount += vertices.count;\n\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\n\t\t\t\tif ( normals !== undefined ) includeNormals = true;\n\n\t\t\t\tif ( uvs !== undefined ) includeUVs = true;\n\n\t\t\t\tif ( colors !== undefined ) includeColors = true;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst includeIndices = excludeAttributes.indexOf( 'index' ) === - 1;\n\t\tincludeNormals = includeNormals && excludeAttributes.indexOf( 'normal' ) === - 1;\n\t\tincludeColors = includeColors && excludeAttributes.indexOf( 'color' ) === - 1;\n\t\tincludeUVs = includeUVs && excludeAttributes.indexOf( 'uv' ) === - 1;\n\n\n\t\tif ( includeIndices && faceCount !== Math.floor( faceCount ) ) {\n\n\t\t\t// point cloud meshes will not have an index array and may not have a\n\t\t\t// number of vertices that is divisble by 3 (and therefore representable\n\t\t\t// as triangles)\n\t\t\tconsole.error(\n\n\t\t\t\t'PLYExporter: Failed to generate a valid PLY file with triangle indices because the ' +\n\t\t\t\t'number of indices is not divisible by 3.'\n\n\t\t\t);\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst indexByteCount = 4;\n\n\t\tlet header =\n\t\t\t'ply\\n' +\n\t\t\t`format ${ options.binary ? ( options.littleEndian ? 'binary_little_endian' : 'binary_big_endian' ) : 'ascii' } 1.0\\n` +\n\t\t\t`element vertex ${vertexCount}\\n` +\n\n\t\t\t// position\n\t\t\t'property float x\\n' +\n\t\t\t'property float y\\n' +\n\t\t\t'property float z\\n';\n\n\t\tif ( includeNormals === true ) {\n\n\t\t\t// normal\n\t\t\theader +=\n\t\t\t\t'property float nx\\n' +\n\t\t\t\t'property float ny\\n' +\n\t\t\t\t'property float nz\\n';\n\n\t\t}\n\n\t\tif ( includeUVs === true ) {\n\n\t\t\t// uvs\n\t\t\theader +=\n\t\t\t\t'property float s\\n' +\n\t\t\t\t'property float t\\n';\n\n\t\t}\n\n\t\tif ( includeColors === true ) {\n\n\t\t\t// colors\n\t\t\theader +=\n\t\t\t\t'property uchar red\\n' +\n\t\t\t\t'property uchar green\\n' +\n\t\t\t\t'property uchar blue\\n';\n\n\t\t}\n\n\t\tif ( includeIndices === true ) {\n\n\t\t\t// faces\n\t\t\theader +=\n\t\t\t\t`element face ${faceCount}\\n` +\n\t\t\t\t'property list uchar int vertex_index\\n';\n\n\t\t}\n\n\t\theader += 'end_header\\n';\n\n\n\t\t// Generate attribute data\n\t\tconst vertex = new Vector3();\n\t\tconst normalMatrixWorld = new Matrix3();\n\t\tlet result = null;\n\n\t\tif ( options.binary === true ) {\n\n\t\t\t// Binary File Generation\n\t\t\tconst headerBin = new TextEncoder().encode( header );\n\n\t\t\t// 3 position values at 4 bytes\n\t\t\t// 3 normal values at 4 bytes\n\t\t\t// 3 color channels with 1 byte\n\t\t\t// 2 uv values at 4 bytes\n\t\t\tconst vertexListLength = vertexCount * ( 4 * 3 + ( includeNormals ? 4 * 3 : 0 ) + ( includeColors ? 3 : 0 ) + ( includeUVs ? 4 * 2 : 0 ) );\n\n\t\t\t// 1 byte shape desciptor\n\t\t\t// 3 vertex indices at ${indexByteCount} bytes\n\t\t\tconst faceListLength = includeIndices ? faceCount * ( indexByteCount * 3 + 1 ) : 0;\n\t\t\tconst output = new DataView( new ArrayBuffer( headerBin.length + vertexListLength + faceListLength ) );\n\t\t\tnew Uint8Array( output.buffer ).set( headerBin, 0 );\n\n\n\t\t\tlet vOffset = headerBin.length;\n\t\t\tlet fOffset = headerBin.length + vertexListLength;\n\t\t\tlet writtenVertices = 0;\n\t\t\ttraverseMeshes( function ( mesh, geometry ) {\n\n\t\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\t\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++ ) {\n\n\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\n\t\t\t\t\t// Position information\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.x, options.littleEndian );\n\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.y, options.littleEndian );\n\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\toutput.setFloat32( vOffset, vertex.z, options.littleEndian );\n\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t// Normal information\n\t\t\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t\t\tif ( normals != null ) {\n\n\t\t\t\t\t\t\tvertex.x = normals.getX( i );\n\t\t\t\t\t\t\tvertex.y = normals.getY( i );\n\t\t\t\t\t\t\tvertex.z = normals.getZ( i );\n\n\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.x, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.y, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, vertex.z, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// UV information\n\t\t\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t\t\tif ( uvs != null ) {\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getX( i ), options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, uvs.getY( i ), options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t} else if ( includeUVs !== false ) {\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t\toutput.setFloat32( vOffset, 0, options.littleEndian );\n\t\t\t\t\t\t\tvOffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Color information\n\t\t\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t\t\tif ( colors != null ) {\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getX( i ) * 255 ) );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getY( i ) * 255 ) );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, Math.floor( colors.getZ( i ) * 255 ) );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint8( vOffset, 255 );\n\t\t\t\t\t\t\tvOffset += 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t\t// Create the face list\n\n\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\n\t\t\t\t\t\t\tfOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 0 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 1 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, indices.getX( i + 2 ) + writtenVertices, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\toutput.setUint8( fOffset, 3 );\n\t\t\t\t\t\t\tfOffset += 1;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i + 1, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t\toutput.setUint32( fOffset, writtenVertices + i + 2, options.littleEndian );\n\t\t\t\t\t\t\tfOffset += indexByteCount;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// Save the amount of verts we've already written so we can offset\n\t\t\t\t// the face index on the next mesh\n\t\t\t\twrittenVertices += vertices.count;\n\n\t\t\t} );\n\n\t\t\tresult = output.buffer;\n\n\t\t} else {\n\n\t\t\t// Ascii File Generation\n\t\t\t// count the number of vertices\n\t\t\tlet writtenVertices = 0;\n\t\t\tlet vertexList = '';\n\t\t\tlet faceList = '';\n\n\t\t\ttraverseMeshes( function ( mesh, geometry ) {\n\n\t\t\t\tconst vertices = geometry.getAttribute( 'position' );\n\t\t\t\tconst normals = geometry.getAttribute( 'normal' );\n\t\t\t\tconst uvs = geometry.getAttribute( 'uv' );\n\t\t\t\tconst colors = geometry.getAttribute( 'color' );\n\t\t\t\tconst indices = geometry.getIndex();\n\n\t\t\t\tnormalMatrixWorld.getNormalMatrix( mesh.matrixWorld );\n\n\t\t\t\t// form each line\n\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i ++ ) {\n\n\t\t\t\t\tvertex.x = vertices.getX( i );\n\t\t\t\t\tvertex.y = vertices.getY( i );\n\t\t\t\t\tvertex.z = vertices.getZ( i );\n\n\t\t\t\t\tvertex.applyMatrix4( mesh.matrixWorld );\n\n\n\t\t\t\t\t// Position information\n\t\t\t\t\tlet line =\n\t\t\t\t\t\tvertex.x + ' ' +\n\t\t\t\t\t\tvertex.y + ' ' +\n\t\t\t\t\t\tvertex.z;\n\n\t\t\t\t\t// Normal information\n\t\t\t\t\tif ( includeNormals === true ) {\n\n\t\t\t\t\t\tif ( normals != null ) {\n\n\t\t\t\t\t\t\tvertex.x = normals.getX( i );\n\t\t\t\t\t\t\tvertex.y = normals.getY( i );\n\t\t\t\t\t\t\tvertex.z = normals.getZ( i );\n\n\t\t\t\t\t\t\tvertex.applyMatrix3( normalMatrixWorld ).normalize();\n\n\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\tvertex.x + ' ' +\n\t\t\t\t\t\t\t\tvertex.y + ' ' +\n\t\t\t\t\t\t\t\tvertex.z;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tline += ' 0 0 0';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// UV information\n\t\t\t\t\tif ( includeUVs === true ) {\n\n\t\t\t\t\t\tif ( uvs != null ) {\n\n\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\tuvs.getX( i ) + ' ' +\n\t\t\t\t\t\t\t\tuvs.getY( i );\n\n\t\t\t\t\t\t} else if ( includeUVs !== false ) {\n\n\t\t\t\t\t\t\tline += ' 0 0';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Color information\n\t\t\t\t\tif ( includeColors === true ) {\n\n\t\t\t\t\t\tif ( colors != null ) {\n\n\t\t\t\t\t\t\tline += ' ' +\n\t\t\t\t\t\t\t\tMath.floor( colors.getX( i ) * 255 ) + ' ' +\n\t\t\t\t\t\t\t\tMath.floor( colors.getY( i ) * 255 ) + ' ' +\n\t\t\t\t\t\t\t\tMath.floor( colors.getZ( i ) * 255 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tline += ' 255 255 255';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvertexList += line + '\\n';\n\n\t\t\t\t}\n\n\t\t\t\t// Create the face list\n\t\t\t\tif ( includeIndices === true ) {\n\n\t\t\t\t\tif ( indices !== null ) {\n\n\t\t\t\t\t\tfor ( let i = 0, l = indices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tfaceList += `3 ${ indices.getX( i + 0 ) + writtenVertices }`;\n\t\t\t\t\t\t\tfaceList += ` ${ indices.getX( i + 1 ) + writtenVertices }`;\n\t\t\t\t\t\t\tfaceList += ` ${ indices.getX( i + 2 ) + writtenVertices }\\n`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor ( let i = 0, l = vertices.count; i < l; i += 3 ) {\n\n\t\t\t\t\t\t\tfaceList += `3 ${ writtenVertices + i } ${ writtenVertices + i + 1 } ${ writtenVertices + i + 2 }\\n`;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\n\t\t\t\t}\n\n\t\t\t\twrittenVertices += vertices.count;\n\n\t\t\t} );\n\n\t\t\tresult = `${ header }${vertexList}${ includeIndices ? `${faceList}\\n` : '\\n' }`;\n\n\t\t}\n\n\t\tif ( typeof onDone === 'function' ) requestAnimationFrame( () => onDone( result ) );\n\n\t\treturn result;\n\n\t}\n\n}\n\nexport { PLYExporter };\n"],"sourceRoot":""}