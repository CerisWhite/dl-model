{"version":3,"sources":["../node_modules/three/examples/jsm/exporters/STLExporter.js"],"names":["STLExporter","prototype","constructor","parse","scene","options","undefined","output","binary","objects","triangles","traverse","object","isMesh","geometry","isBufferGeometry","Error","index","positionAttribute","getAttribute","count","push","object3d","offset","arrayBuffer","ArrayBuffer","DataView","setUint32","vA","Vector3","vB","vC","cb","ab","normal","i","il","length","j","writeFace","getX","a","b","c","fromBufferAttribute","isSkinnedMesh","boneTransform","applyMatrix4","matrixWorld","subVectors","cross","normalize","copy","setFloat32","x","y","z","writeNormal","writeVertex","setUint16","vertex"],"mappings":"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","file":"static/js/STLExporter.218dae08.chunk.js","sourcesContent":["import {\n\tVector3\n} from '../../../build/three.module.js';\n\n/**\n * Usage:\n *  var exporter = new STLExporter();\n *\n *  // second argument is a list of options\n *  var data = exporter.parse( mesh, { binary: true } );\n *\n */\n\nvar STLExporter = function () {};\n\nSTLExporter.prototype = {\n\n\tconstructor: STLExporter,\n\n\tparse: function ( scene, options ) {\n\n\t\tif ( options === undefined ) options = {};\n\n\t\tvar binary = options.binary !== undefined ? options.binary : false;\n\n\t\t//\n\n\t\tvar objects = [];\n\t\tvar triangles = 0;\n\n\t\tscene.traverse( function ( object ) {\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tvar geometry = object.geometry;\n\n\t\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.STLExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t\t}\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\t\ttriangles += ( index !== null ) ? ( index.count / 3 ) : ( positionAttribute.count / 3 );\n\n\t\t\t\tobjects.push( {\n\t\t\t\t\tobject3d: object,\n\t\t\t\t\tgeometry: geometry\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tvar output;\n\t\tvar offset = 80; // skip header\n\n\t\tif ( binary === true ) {\n\n\t\t\tvar bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n\t\t\tvar arrayBuffer = new ArrayBuffer( bufferLength );\n\t\t\toutput = new DataView( arrayBuffer );\n\t\t\toutput.setUint32( offset, triangles, true ); offset += 4;\n\n\t\t} else {\n\n\t\t\toutput = '';\n\t\t\toutput += 'solid exported\\n';\n\n\t\t}\n\n\t\tvar vA = new Vector3();\n\t\tvar vB = new Vector3();\n\t\tvar vC = new Vector3();\n\t\tvar cb = new Vector3();\n\t\tvar ab = new Vector3();\n\t\tvar normal = new Vector3();\n\n\t\tfor ( var i = 0, il = objects.length; i < il; i ++ ) {\n\n\t\t\tvar object = objects[ i ].object3d;\n\t\t\tvar geometry = objects[ i ].geometry;\n\n\t\t\tvar index = geometry.index;\n\t\t\tvar positionAttribute = geometry.getAttribute( 'position' );\n\n\t\t\tif ( index !== null ) {\n\n\t\t\t\t// indexed geometry\n\n\t\t\t\tfor ( var j = 0; j < index.count; j += 3 ) {\n\n\t\t\t\t\tvar a = index.getX( j + 0 );\n\t\t\t\t\tvar b = index.getX( j + 1 );\n\t\t\t\t\tvar c = index.getX( j + 2 );\n\n\t\t\t\t\twriteFace( a, b, c, positionAttribute, object );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed geometry\n\n\t\t\t\tfor ( var j = 0; j < positionAttribute.count; j += 3 ) {\n\n\t\t\t\t\tvar a = j + 0;\n\t\t\t\t\tvar b = j + 1;\n\t\t\t\t\tvar c = j + 2;\n\n\t\t\t\t\twriteFace( a, b, c, positionAttribute, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( binary === false ) {\n\n\t\t\toutput += 'endsolid exported\\n';\n\n\t\t}\n\n\t\treturn output;\n\n\t\tfunction writeFace( a, b, c, positionAttribute, object ) {\n\n\t\t\tvA.fromBufferAttribute( positionAttribute, a );\n\t\t\tvB.fromBufferAttribute( positionAttribute, b );\n\t\t\tvC.fromBufferAttribute( positionAttribute, c );\n\n\t\t\tif ( object.isSkinnedMesh === true ) {\n\n\t\t\t\tobject.boneTransform( a, vA );\n\t\t\t\tobject.boneTransform( b, vB );\n\t\t\t\tobject.boneTransform( c, vC );\n\n\t\t\t}\n\n\t\t\tvA.applyMatrix4( object.matrixWorld );\n\t\t\tvB.applyMatrix4( object.matrixWorld );\n\t\t\tvC.applyMatrix4( object.matrixWorld );\n\n\t\t\twriteNormal( vA, vB, vC );\n\n\t\t\twriteVertex( vA );\n\t\t\twriteVertex( vB );\n\t\t\twriteVertex( vC );\n\n\t\t\tif ( binary === true ) {\n\n\t\t\t\toutput.setUint16( offset, 0, true ); offset += 2;\n\n\t\t\t} else {\n\n\t\t\t\toutput += '\\t\\tendloop\\n';\n\t\t\t\toutput += '\\tendfacet\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction writeNormal( vA, vB, vC ) {\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab ).normalize();\n\n\t\t\tnormal.copy( cb ).normalize();\n\n\t\t\tif ( binary === true ) {\n\n\t\t\t\toutput.setFloat32( offset, normal.x, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, normal.y, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, normal.z, true ); offset += 4;\n\n\t\t\t} else {\n\n\t\t\t\toutput += '\\tfacet normal ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n\t\t\t\toutput += '\\t\\touter loop\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction writeVertex( vertex ) {\n\n\t\t\tif ( binary === true ) {\n\n\t\t\t\toutput.setFloat32( offset, vertex.x, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, vertex.y, true ); offset += 4;\n\t\t\t\toutput.setFloat32( offset, vertex.z, true ); offset += 4;\n\n\t\t\t} else {\n\n\t\t\t\toutput += '\\t\\t\\tvertex ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\nexport { STLExporter };\n"],"sourceRoot":""}