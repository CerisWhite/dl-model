{"version":3,"sources":["components/viewers/AdvViewer.js"],"names":["SIDES","AdvViewer","props","afterMainModelLoad","saveMainModelInitState","initFace","addWeapons","addAnimation","beforeMainModelUpdate","detachAllWeapons","afterMainModelUpdate","attachAllWeapons","updateModel","prev","current","a","prevModel","model","updateMainModel","id","updateFace","updateWeapons","updateAnimation","animation","modelId","_eyeIdx","_mouthIdx","DEFAULT_FACE_IDX","defaultFaceParams","mouthTexture","mouthIdx","eyeTexture","eyeIdx","getWeaponInfo","initWeaponLoad","weaponRight","weaponLeft","models","Object","assign","initAllWeapons","newInfo","analyzeWeaponCode","modelInfo","modelPath","loadWeaponR","loadModel","loadWeaponL","Promise","all","materialType","matType","forEach","side","key","weapon","weaponInfo","texturePath","flipped","changeMaterial","rotation","y","Math","PI","outlineParams","outline","createOutline","outlines","attachWeapon","boneName","main","traverse","child","name","includes","children","length","add","detachWeapon","parent","remove","updateEyeTexture","currentTexture","prevTexture","applyEyeTexture","textureId","offset","calculateTextureOffset","applyEyeOffset","updateMouthTexture","applyMouthTexture","applyMouthOffset","updateFaceTexture","eyeUpdated","mouthUpdated","mainModel","applyNewModelMat","updateFaceOffset","disableInput","dispose3dObject","enableInput","newIdx","oldIdx","this","calculateIdxOffset","AniViewer"],"mappings":"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","file":"static/js/66.a7c5617a.chunk.js","sourcesContent":["import AniViewer from \"./AniViewer\";\r\n\r\nimport { DEFAULT_FACE_IDX } from \"helpers/consts\";\r\nimport {\r\n    calculateTextureOffset,\r\n    calculateIdxOffset,\r\n    analyzeWeaponCode,\r\n    loadModel,\r\n    applyEyeTexture,\r\n    applyMouthTexture,\r\n    applyEyeOffset,\r\n    applyMouthOffset,\r\n    dispose3dObject,\r\n    createOutline,\r\n    changeMaterial,\r\n} from \"helpers/viewerHelpers\";\r\n\r\nconst SIDES = [\"Right\", \"Left\"];\r\n\r\n/**\r\n *  Extension of Ani Viewer that adds:\r\n *    - Weapons\r\n *    - Face Texture\r\n *    - Face offset\r\n */\r\nexport class AdvViewer extends AniViewer {\r\n    /**\r\n     * @param {ViewerProps} props\r\n     */\r\n    constructor(props) {\r\n        super(props);\r\n        this._eyeIdx = this._mouthIdx = DEFAULT_FACE_IDX;\r\n    }\r\n\r\n    afterMainModelLoad = () => {\r\n        this.saveMainModelInitState();\r\n        this.initFace();\r\n        this.addWeapons();\r\n        this.addAnimation();\r\n    };\r\n\r\n    beforeMainModelUpdate = () => {\r\n        this.detachAllWeapons();\r\n    };\r\n\r\n    afterMainModelUpdate = () => {\r\n        this.saveMainModelInitState();\r\n        this.initFace();\r\n        this.attachAllWeapons();\r\n        this.addAnimation();\r\n    };\r\n\r\n    updateModel = async (prev, current) => {\r\n        if (prev === current) return;\r\n\r\n        const prevModel = prev.model;\r\n        const { model } = current;\r\n        await this.updateMainModel(prevModel, model);\r\n\r\n        if (prevModel.id === model.id) {\r\n            this.updateFace(prevModel, model);\r\n        }\r\n        this.updateWeapons(prevModel, model);\r\n        this.updateAnimation(prev.animation, current.animation);\r\n    };\r\n\r\n    /**\r\n     * initialize facial expressions\r\n     */\r\n    initFace = () => {\r\n        const modelId = this.props.model.id;\r\n        this._eyeIdx = this._mouthIdx = DEFAULT_FACE_IDX;\r\n        const defaultFaceParams = {\r\n            mouthTexture: modelId,\r\n            mouthIdx: DEFAULT_FACE_IDX,\r\n            eyeTexture: modelId,\r\n            eyeIdx: DEFAULT_FACE_IDX,\r\n        };\r\n        this.updateFace(defaultFaceParams, this.props.model);\r\n    };\r\n\r\n    /**\r\n     * add specified weapons\r\n     */\r\n    addWeapons = async () => {\r\n        this.getWeaponInfo();\r\n\r\n        const [weaponRight, weaponLeft] = await this.initWeaponLoad();\r\n        this.models = Object.assign(this.models, { weaponRight, weaponLeft });\r\n\r\n        await this.initAllWeapons();\r\n        this.attachAllWeapons();\r\n    };\r\n\r\n    /**\r\n     * extract data from weapon code\r\n     */\r\n    getWeaponInfo = () => {\r\n        const { weaponRight, weaponLeft } = this.props.model;\r\n        const newInfo = {\r\n            weaponRight: analyzeWeaponCode(weaponRight),\r\n            weaponLeft: analyzeWeaponCode(weaponLeft),\r\n        };\r\n        this.modelInfo = Object.assign(this.modelInfo, newInfo);\r\n    };\r\n\r\n    /**\r\n     * load weapons during initialization\r\n     */\r\n    initWeaponLoad = () => {\r\n        const weaponRight = this.modelInfo.weaponRight?.modelPath;\r\n        const loadWeaponR = loadModel(weaponRight);\r\n\r\n        const weaponLeft = this.modelInfo.weaponLeft?.modelPath;\r\n        const loadWeaponL = loadModel(weaponLeft);\r\n\r\n        return Promise.all([loadWeaponR, loadWeaponL]);\r\n    };\r\n\r\n    /**\r\n     * initialize all weapons\r\n     */\r\n    initAllWeapons = async () => {\r\n        const materialType = this.matType;\r\n        SIDES.forEach(async side => {\r\n            const key = `weapon${side}`;\r\n            const weapon = this.models[key];\r\n            if (!weapon) return;\r\n\r\n            const weaponInfo = this.modelInfo[key];\r\n            const { texturePath, flipped } = weaponInfo;\r\n            changeMaterial(weapon, { materialType, texturePath });\r\n            if (flipped) weapon.rotation.y += Math.PI;\r\n\r\n            const outlineParams = this.props.outline;\r\n            this.outlines[key] = await createOutline(weapon, outlineParams);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * attach weapon model to main model's hand\r\n     * @param {THREE.Group} weapon - weapon model\r\n     * @param {string} side - Left or Right\r\n     */\r\n    attachWeapon = (weapon, side) => {\r\n        const boneName = `jWeapon${side[0]}`;\r\n        this.models.main.traverse(child => {\r\n            if (child.name.includes(boneName) && child.children.length === 0) {\r\n                child.add(weapon);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * attach weapons when they are loaded\r\n     */\r\n    attachAllWeapons = () => {\r\n        SIDES.forEach(side => {\r\n            const key = `weapon${side}`;\r\n            const weapon = this.models[key];\r\n            if (!weapon) return;\r\n\r\n            this.attachWeapon(weapon, side);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * detach the weapon on one side\r\n     * @param {string} side - Left or Right\r\n     */\r\n    detachWeapon = side => {\r\n        const key = `weapon${side}`;\r\n        const model = this.models[key];\r\n        if (!model) return;\r\n\r\n        model.parent.remove(model);\r\n    };\r\n\r\n    /**\r\n     * detach all weapons attached to main model\r\n     */\r\n    detachAllWeapons = () => SIDES.forEach(side => this.detachWeapon(side));\r\n\r\n    /**\r\n     * change eye texture\r\n     * @param { AdvFaceState } prev - previous state\r\n     * @param { AdvFaceState } current - current state\r\n     * @return {Boolean} whether texture was updated\r\n     */\r\n    updateEyeTexture = (prev, current) => {\r\n        const currentTexture = current.eyeTexture;\r\n        const prevTexture = prev.eyeTexture;\r\n\r\n        if (currentTexture === prevTexture) return false;\r\n\r\n        const materialType = this.matType;\r\n        applyEyeTexture(this.models.main, {\r\n            materialType,\r\n            textureId: currentTexture,\r\n        });\r\n        const offset = calculateTextureOffset(currentTexture, prevTexture);\r\n        applyEyeOffset(this.models.main, offset);\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * @param {number} newIdx\r\n     */\r\n    set eyeIdx(newIdx) {\r\n        if (!newIdx) return;\r\n\r\n        const oldIdx = this._eyeIdx;\r\n        if (newIdx === oldIdx) return;\r\n\r\n        const offset = calculateIdxOffset(newIdx, oldIdx);\r\n        applyEyeOffset(this.models.main, offset);\r\n\r\n        this._eyeIdx = newIdx;\r\n    }\r\n\r\n    /**\r\n     * change mouth texture\r\n     * @param { AdvFaceState } prev - previous state\r\n     * @param { AdvFaceState } current - current state\r\n     * @return {Boolean} whether texture was updated\r\n     */\r\n    updateMouthTexture = (prev, current) => {\r\n        const currentTexture = current.mouthTexture;\r\n        const prevTexture = prev.mouthTexture;\r\n\r\n        if (currentTexture === prevTexture) return false;\r\n\r\n        const materialType = this.matType;\r\n        applyMouthTexture(this.models.main, {\r\n            materialType,\r\n            textureId: currentTexture,\r\n        });\r\n        const offset = calculateTextureOffset(currentTexture, prevTexture);\r\n        applyMouthOffset(this.models.main, offset);\r\n\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * @param {number} newIdx\r\n     */\r\n    set mouthIdx(newIdx) {\r\n        if (!newIdx) return;\r\n\r\n        const oldIdx = this._mouthIdx;\r\n        if (newIdx === oldIdx) return;\r\n\r\n        const offset = calculateIdxOffset(newIdx, oldIdx);\r\n        applyMouthOffset(this.models.main, offset);\r\n\r\n        this._mouthIdx = newIdx;\r\n    }\r\n\r\n    /**\r\n     * update eyes and mouth texture\r\n     * @param {AdvFaceState} prev\r\n     * @param {AdvFaceState} current\r\n     */\r\n    updateFaceTexture = (prev, current) => {\r\n        const eyeUpdated = this.updateEyeTexture(prev, current);\r\n        const mouthUpdated = this.updateMouthTexture(prev, current);\r\n        if (eyeUpdated || mouthUpdated) {\r\n            const mainModel = this.models.main;\r\n            this.applyNewModelMat(mainModel);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * update uv of face mesh\r\n     * @param {AdvFaceState} params\r\n     */\r\n    updateFaceOffset = ({ eyeIdx, mouthIdx }) => {\r\n        this.eyeIdx = eyeIdx;\r\n        this.mouthIdx = mouthIdx;\r\n    };\r\n\r\n    /**\r\n     * update face texture and offset\r\n     * @param {AdvFaceState} prev\r\n     * @param {AdvFaceState} current\r\n     */\r\n    updateFace = (prev, current) => {\r\n        this.updateFaceTexture(prev, current);\r\n        this.updateFaceOffset(current);\r\n    };\r\n\r\n    /**\r\n     * add, change, or remove weapons if needed\r\n     * @param {AppModelState} prev\r\n     * @param {AppModelState} current\r\n     */\r\n    updateWeapons = async (prev, current) => {\r\n        this.disableInput();\r\n        SIDES.forEach(async side => {\r\n            const key = `weapon${side}`;\r\n            if (prev[key] === current[key]) return;\r\n\r\n            // remove and dispose old weapon\r\n            this.detachWeapon(side);\r\n            dispose3dObject(this.models[key]);\r\n\r\n            // if current weapon is empty (weapon removed)\r\n            if (!current[key]) {\r\n                this.models[key] = null;\r\n                this.modelInfo[key] = \"\";\r\n                // remove reference to outline\r\n                this.outlines[key] = null;\r\n                return;\r\n            }\r\n\r\n            // load new weapon\r\n            this.modelInfo[key] = analyzeWeaponCode(current[key]);\r\n            const { modelPath, texturePath, flipped } = this.modelInfo[key];\r\n\r\n            // load new model\r\n            const model = await loadModel(modelPath);\r\n            this.models[key] = model;\r\n\r\n            // process new weapon\r\n            const materialType = this.matType;\r\n            changeMaterial(model, { materialType, texturePath });\r\n            this.applyNewModelMat(model);\r\n\r\n            if (flipped) {\r\n                model.rotation.y += Math.PI;\r\n            }\r\n\r\n            const outlineParams = this.props.outline;\r\n            this.outlines[key] = await createOutline(model, outlineParams);\r\n\r\n            this.attachWeapon(model, side);\r\n        });\r\n        this.enableInput();\r\n    };\r\n}\r\n\r\nexport default AdvViewer;\r\n"],"sourceRoot":""}