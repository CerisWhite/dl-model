{"version":3,"sources":["../node_modules/three/examples/jsm/exporters/GLTFExporter.js"],"names":["GLTFExporter","this","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsPBRSpecularGlossiness","prototype","constructor","callback","indexOf","push","unregister","splice","parse","input","onDone","options","GLTFWriter","plugins","i","il","length","setPlugins","write","WEBGL_CONSTANTS","THREE_TO_WEBGL","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","PATH_PROPERTIES","scale","position","quaternion","morphTargetInfluences","equalArray","array1","array2","every","element","index","getPaddedBufferSize","bufferSize","Math","ceil","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","byteLength","array","Uint8Array","set","buffer","cachedCanvas","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","name","Object","assign","binary","trs","onlyVisible","truncateDrawRange","embedImages","maxTextureSize","Infinity","animations","includeCustomExtensions","processInput","Promise","all","then","reader","blob","Blob","type","extensionsUsedList","keys","size","window","FileReader","readAsArrayBuffer","onloadend","binaryChunk","result","binaryChunkPrefix","DataView","ArrayBuffer","setUint32","jsonChunk","text","undefined","TextEncoder","encode","value","charCodeAt","stringToArrayBuffer","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","uri","serializeUserData","object","objectDef","userData","gltfExtensions","extensionName","extensions","extras","error","console","warn","message","getUID","has","get","isNormalizedNormalAttribute","normal","v","Vector3","count","abs","fromBufferAttribute","createNormalizedNormalAttribute","attribute","clone","x","y","z","setX","normalize","setXYZ","applyTextureTransform","mapDef","texture","didTransform","transformDef","offset","toArray","rotation","repeat","processBuffer","processBufferView","componentType","start","target","componentSize","bufferViews","itemSize","dataView","a","getX","getY","getZ","getW","setFloat32","setUint16","setUint8","bufferViewDef","byteStride","id","processBufferViewImage","resolve","processAccessor","geometry","Float32Array","Uint32Array","Uint16Array","Error","end","end2","drawRange","max","min","bufferViewTarget","minMax","output","Array","fill","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","getMinMax","bufferView","accessorDef","1","2","3","4","16","normalized","accessors","processImage","image","format","flipY","cachedImages","mimeType","RGBAFormat","key","toString","imageDef","canvas","document","createElement","width","height","ctx","getContext","translate","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","ImageBitmap","drawImage","RGBFormat","data","Uint8ClampedArray","j","putImageData","ImageData","toBlob","bufferViewIndex","toDataURL","src","processSampler","map","samplers","samplerDef","magFilter","minFilter","wrapS","wrapT","processTexture","textureDef","sampler","source","_invokeAll","ext","writeTexture","processMaterial","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","baseColorFactor","metallicFactor","metalness","roughnessFactor","roughness","metalnessMap","roughnessMap","metalRoughMapDef","metallicRoughnessTexture","baseColorMapDef","baseColorTexture","emissive","multiplyScalar","emissiveIntensity","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","texCoord","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","DoubleSide","doubleSided","writeMaterial","processMesh","mesh","meshCacheKeyParts","uuid","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","isBufferGeometry","meshDef","primitives","targets","nameConversion","uv","uv2","skinWeight","skinIndex","originalNormal","getAttribute","setAttribute","modifiedAttribute","attributeName","substr","toUpperCase","test","BufferAttribute","accessor","weights","targetNames","reverseDictionary","morphTargetDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","jl","isMultiMaterial","groups","materialIndex","primitive","cacheKey","indices","writeMesh","processCamera","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","MathUtils","degToRad","fov","processAnimation","clip","root","tracks","Utils","mergeMorphTargetTracks","channels","track","trackBinding","PropertyBinding","parseTrackName","trackNode","findNode","nodeName","trackProperty","propertyName","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","interpolation","outputItemSize","values","times","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","getInterpolation","InterpolateDiscrete","node","path","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","Matrix4","copy","boneInverses","multiply","bindMatrix","skin","processNode","nodeDef","translation","matrixAutoUpdate","updateMatrix","matrix","elements","String","isMesh","meshIndex","isCamera","children","child","visible","nodeIndex","writeNode","processScene","scene","scenes","sceneDef","processObjects","objects","Scene","beforeParse","objectsWithoutScene","afterParse","func","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isGLTFSpecularGlossinessMaterial","extensionDef","diffuseFactor","specularFactor","specular","glossinessFactor","glossiness","diffuseTexture","specularMap","specularMapDef","specularGlossinessTexture","insertKeyframe","time","tolerance","valueSize","getValueSize","TimeBufferType","ValueBufferType","interpolant","evaluate","slice","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","InterpolateLinear","mergedTrack","targetCount","targetIndex","sourceInterpolant","keyframeIndex"],"mappings":"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","file":"static/js/75.e17dd2ea.chunk.js","sourcesContent":["import {\n\tBufferAttribute,\n\tClampToEdgeWrapping,\n\tDoubleSide,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tMathUtils,\n\tMatrix4,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tPropertyBinding,\n\tRGBAFormat,\n\tRGBFormat,\n\tRepeatWrapping,\n\tScene,\n\tVector3\n} from '../../../build/three.module.js';\n\nvar GLTFExporter = ( function () {\n\n\tfunction GLTFExporter() {\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFLightExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsUnlitExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsPBRSpecularGlossiness( writer );\n\n\t\t} );\n\n\t}\n\n\tGLTFExporter.prototype = {\n\n\t\tconstructor: GLTFExporter,\n\n\t\tregister: function ( callback ) {\n\n\t\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tunregister: function ( callback ) {\n\n\t\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t/**\n\t\t * Parse scenes and generate GLTF output\n\t\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t\t * @param  {Function} onDone  Callback on completed\n\t\t * @param  {Object} options options\n\t\t */\n\t\tparse: function ( input, onDone, options ) {\n\n\t\t\tvar writer = new GLTFWriter();\n\t\t\tvar plugins = [];\n\n\t\t\tfor ( var i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {\n\n\t\t\t\tplugins.push( this.pluginCallbacks[ i ]( writer ) );\n\n\t\t\t}\n\n\t\t\twriter.setPlugins( plugins );\n\t\t\twriter.write( input, onDone, options );\n\n\t\t}\n\n\t};\n\n\t//------------------------------------------------------------------------------\n\t// Constants\n\t//------------------------------------------------------------------------------\n\n\tvar WEBGL_CONSTANTS = {\n\t\tPOINTS: 0x0000,\n\t\tLINES: 0x0001,\n\t\tLINE_LOOP: 0x0002,\n\t\tLINE_STRIP: 0x0003,\n\t\tTRIANGLES: 0x0004,\n\t\tTRIANGLE_STRIP: 0x0005,\n\t\tTRIANGLE_FAN: 0x0006,\n\n\t\tUNSIGNED_BYTE: 0x1401,\n\t\tUNSIGNED_SHORT: 0x1403,\n\t\tFLOAT: 0x1406,\n\t\tUNSIGNED_INT: 0x1405,\n\t\tARRAY_BUFFER: 0x8892,\n\t\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\t\tNEAREST: 0x2600,\n\t\tLINEAR: 0x2601,\n\t\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\t\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\t\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\t\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\t\tCLAMP_TO_EDGE: 33071,\n\t\tMIRRORED_REPEAT: 33648,\n\t\tREPEAT: 10497\n\t};\n\n\tvar THREE_TO_WEBGL = {};\n\n\tTHREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\n\tTHREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\n\tTHREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\n\tTHREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\n\tTHREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\n\tTHREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\n\tTHREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\n\tTHREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\n\tTHREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\n\tvar PATH_PROPERTIES = {\n\t\tscale: 'scale',\n\t\tposition: 'translation',\n\t\tquaternion: 'rotation',\n\t\tmorphTargetInfluences: 'weights'\n\t};\n\n\t// GLB constants\n\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\tvar GLB_HEADER_BYTES = 12;\n\tvar GLB_HEADER_MAGIC = 0x46546C67;\n\tvar GLB_VERSION = 2;\n\n\tvar GLB_CHUNK_PREFIX_BYTES = 8;\n\tvar GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\n\tvar GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n\t//------------------------------------------------------------------------------\n\t// Utility functions\n\t//------------------------------------------------------------------------------\n\n\t/**\n\t * Compare two arrays\n\t * @param  {Array} array1 Array 1 to compare\n\t * @param  {Array} array2 Array 2 to compare\n\t * @return {Boolean}        Returns true if both arrays are equal\n\t */\n\tfunction equalArray( array1, array2 ) {\n\n\t\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\t\treturn element === array2[ index ];\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Converts a string to an ArrayBuffer.\n\t * @param  {string} text\n\t * @return {ArrayBuffer}\n\t */\n\tfunction stringToArrayBuffer( text ) {\n\n\t\tif ( window.TextEncoder !== undefined ) {\n\n\t\t\treturn new TextEncoder().encode( text ).buffer;\n\n\t\t}\n\n\t\tvar array = new Uint8Array( new ArrayBuffer( text.length ) );\n\n\t\tfor ( var i = 0, il = text.length; i < il; i ++ ) {\n\n\t\t\tvar value = text.charCodeAt( i );\n\n\t\t\t// Replacing multi-byte character with space(0x20).\n\t\t\tarray[ i ] = value > 0xFF ? 0x20 : value;\n\n\t\t}\n\n\t\treturn array.buffer;\n\n\t}\n\n\t/**\n\t * Is identity matrix\n\t *\n\t * @param {Matrix4} matrix\n\t * @returns {Boolean} Returns true, if parameter is identity matrix\n\t */\n\tfunction isIdentityMatrix( matrix ) {\n\n\t\treturn equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );\n\n\t}\n\n\t/**\n\t * Get the min and max vectors from the given attribute\n\t * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n\t * @param  {Integer} start\n\t * @param  {Integer} count\n\t * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n\t */\n\tfunction getMinMax( attribute, start, count ) {\n\n\t\tvar output = {\n\n\t\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t\t};\n\n\t\tfor ( var i = start; i < start + count; i ++ ) {\n\n\t\t\tfor ( var a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\tvar value;\n\n\t\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\t}\n\n\t\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n\t * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n\t *\n\t * @param {Integer} bufferSize The size the original buffer.\n\t * @returns {Integer} new buffer size with required padding.\n\t *\n\t */\n\tfunction getPaddedBufferSize( bufferSize ) {\n\n\t\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n\t}\n\n\t/**\n\t * Returns a buffer aligned to 4-byte boundary.\n\t *\n\t * @param {ArrayBuffer} arrayBuffer Buffer to pad\n\t * @param {Integer} paddingByte (Optional)\n\t * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n\t */\n\tfunction getPaddedArrayBuffer( arrayBuffer, paddingByte ) {\n\n\t\tpaddingByte = paddingByte || 0;\n\n\t\tvar paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\t\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\t\tvar array = new Uint8Array( paddedLength );\n\t\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\t\tif ( paddingByte !== 0 ) {\n\n\t\t\t\tfor ( var i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn array.buffer;\n\n\t\t}\n\n\t\treturn arrayBuffer;\n\n\t}\n\n\tvar cachedCanvas = null;\n\n\t/**\n\t * Writer\n\t */\n\tfunction GLTFWriter() {\n\n\t\tthis.plugins = [];\n\n\t\tthis.options = {};\n\t\tthis.pending = [];\n\t\tthis.buffers = [];\n\n\t\tthis.byteOffset = 0;\n\t\tthis.buffers = [];\n\t\tthis.nodeMap = new Map();\n\t\tthis.skins = [];\n\t\tthis.extensionsUsed = {};\n\n\t\tthis.uids = new Map();\n\t\tthis.uid = 0;\n\n\t\tthis.json = {\n\t\t\tasset: {\n\t\t\t\tversion: '2.0',\n\t\t\t\tgenerator: 'THREE.GLTFExporter'\n\t\t\t}\n\t\t};\n\n\t\tthis.cache = {\n\t\t\tmeshes: new Map(),\n\t\t\tattributes: new Map(),\n\t\t\tattributesNormalized: new Map(),\n\t\t\tmaterials: new Map(),\n\t\t\ttextures: new Map(),\n\t\t\timages: new Map()\n\t\t};\n\n\t}\n\n\tGLTFWriter.prototype = {\n\n\t\tconstructor: GLTFWriter,\n\n\t\tsetPlugins: function ( plugins ) {\n\n\t\t\tthis.plugins = plugins;\n\n\t\t},\n\n\t\t/**\n\t\t * Parse scenes and generate GLTF output\n\t\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t\t * @param  {Function} onDone  Callback on completed\n\t\t * @param  {Object} options options\n\t\t */\n\t\twrite: function ( input, onDone, options ) {\n\n\t\t\tthis.options = Object.assign( {}, {\n\t\t\t\t// default options\n\t\t\t\tbinary: false,\n\t\t\t\ttrs: false,\n\t\t\t\tonlyVisible: true,\n\t\t\t\ttruncateDrawRange: true,\n\t\t\t\tembedImages: true,\n\t\t\t\tmaxTextureSize: Infinity,\n\t\t\t\tanimations: [],\n\t\t\t\tincludeCustomExtensions: false\n\t\t\t}, options );\n\n\t\t\tif ( this.options.animations.length > 0 ) {\n\n\t\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\t\tthis.options.trs = true;\n\n\t\t\t}\n\n\t\t\tthis.processInput( input );\n\n\t\t\tvar writer = this;\n\n\t\t\tPromise.all( this.pending ).then( function () {\n\n\t\t\t\tvar buffers = writer.buffers;\n\t\t\t\tvar json = writer.json;\n\t\t\t\tvar options = writer.options;\n\t\t\t\tvar extensionsUsed = writer.extensionsUsed;\n\n\t\t\t\t// Merge buffers.\n\t\t\t\tvar blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t\t\t// Declare extensions.\n\t\t\t\tvar extensionsUsedList = Object.keys( extensionsUsed );\n\n\t\t\t\tif ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;\n\n\t\t\t\t// Update bytelength of the single buffer.\n\t\t\t\tif ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;\n\n\t\t\t\tif ( options.binary === true ) {\n\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\t\treader.readAsArrayBuffer( blob );\n\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\t// Binary chunk.\n\t\t\t\t\t\tvar binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\t\t\tvar binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t\t\t// JSON chunk.\n\t\t\t\t\t\tvar jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );\n\t\t\t\t\t\tvar jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t\t\t// GLB header.\n\t\t\t\t\t\tvar header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\t\t\tvar headerView = new DataView( header );\n\t\t\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\t\t\tvar totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\t\t\tvar glbBlob = new Blob( [\n\t\t\t\t\t\t\theader,\n\t\t\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\t\t\tjsonChunk,\n\t\t\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\t\t\tbinaryChunk\n\t\t\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\t\t\tvar glbReader = new window.FileReader();\n\t\t\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t};\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( json.buffers && json.buffers.length > 0 ) {\n\n\t\t\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\t\tvar base64data = reader.result;\n\t\t\t\t\t\t\tjson.buffers[ 0 ].uri = base64data;\n\t\t\t\t\t\t\tonDone( json );\n\n\t\t\t\t\t\t};\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tonDone( json );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t},\n\n\t\t/**\n\t\t * Serializes a userData.\n\t\t *\n\t\t * @param {THREE.Object3D|THREE.Material} object\n\t\t * @param {Object} objectDef\n\t\t */\n\t\tserializeUserData: function ( object, objectDef ) {\n\n\t\t\tif ( Object.keys( object.userData ).length === 0 ) return;\n\n\t\t\tvar options = this.options;\n\t\t\tvar extensionsUsed = this.extensionsUsed;\n\n\t\t\ttry {\n\n\t\t\t\tvar json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\t\tif ( objectDef.extensions === undefined ) objectDef.extensions = {};\n\n\t\t\t\t\tfor ( var extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\t\tobjectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t\t}\n\n\t\t\t\tif ( Object.keys( json ).length > 0 ) objectDef.extras = json;\n\n\t\t\t} catch ( error ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t * Assign and return a temporal unique id for an object\n\t\t * especially which doesn't have .uuid\n\t\t * @param  {Object} object\n\t\t * @return {Integer}\n\t\t */\n\t\tgetUID: function ( object ) {\n\n\t\t\tif ( ! this.uids.has( object ) ) this.uids.set( object, this.uid ++ );\n\n\t\t\treturn this.uids.get( object );\n\n\t\t},\n\n\t\t/**\n\t\t * Checks if normal attribute values are normalized.\n\t\t *\n\t\t * @param {BufferAttribute} normal\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisNormalizedNormalAttribute: function ( normal ) {\n\n\t\t\tvar cache = this.cache;\n\n\t\t\tif ( cache.attributesNormalized.has( normal ) ) return false;\n\n\t\t\tvar v = new Vector3();\n\n\t\t\tfor ( var i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t\t// 0.0005 is from glTF-validator\n\t\t\t\tif ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t},\n\n\t\t/**\n\t\t * Creates normalized normal buffer attribute.\n\t\t *\n\t\t * @param {BufferAttribute} normal\n\t\t * @returns {BufferAttribute}\n\t\t *\n\t\t */\n\t\tcreateNormalizedNormalAttribute: function ( normal ) {\n\n\t\t\tvar cache = this.cache;\n\n\t\t\tif ( cache.attributesNormalized.has( normal ) )\treturn cache.attributesNormalized.get( normal );\n\n\t\t\tvar attribute = normal.clone();\n\t\t\tvar v = new Vector3();\n\n\t\t\tfor ( var i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\t\tv.fromBufferAttribute( attribute, i );\n\n\t\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\t\tv.setX( 1.0 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv.normalize();\n\n\t\t\t\t}\n\n\t\t\t\tattribute.setXYZ( i, v.x, v.y, v.z );\n\n\t\t\t}\n\n\t\t\tcache.attributesNormalized.set( normal, attribute );\n\n\t\t\treturn attribute;\n\n\t\t},\n\n\t\t/**\n\t\t * Applies a texture transform, if present, to the map definition. Requires\n\t\t * the KHR_texture_transform extension.\n\t\t *\n\t\t * @param {Object} mapDef\n\t\t * @param {THREE.Texture} texture\n\t\t */\n\t\tapplyTextureTransform: function ( mapDef, texture ) {\n\n\t\t\tvar didTransform = false;\n\t\t\tvar transformDef = {};\n\n\t\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\t\tdidTransform = true;\n\n\t\t\t}\n\n\t\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\t\tdidTransform = true;\n\n\t\t\t}\n\n\t\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\t\tdidTransform = true;\n\n\t\t\t}\n\n\t\t\tif ( didTransform ) {\n\n\t\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\t\tthis.extensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t\t}\n\n\t\t},\n\n\t\t/**\n\t\t * Process a buffer to append to the default one.\n\t\t * @param  {ArrayBuffer} buffer\n\t\t * @return {Integer}\n\t\t */\n\t\tprocessBuffer: function ( buffer ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar buffers = this.buffers;\n\n\t\t\tif ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];\n\n\t\t\t// All buffers are merged before export.\n\t\t\tbuffers.push( buffer );\n\n\t\t\treturn 0;\n\n\t\t},\n\n\t\t/**\n\t\t * Process and generate a BufferView\n\t\t * @param  {BufferAttribute} attribute\n\t\t * @param  {number} componentType\n\t\t * @param  {number} start\n\t\t * @param  {number} count\n\t\t * @param  {number} target (Optional) Target usage of the BufferView\n\t\t * @return {Object}\n\t\t */\n\t\tprocessBufferView: function ( attribute, componentType, start, count, target ) {\n\n\t\t\tvar json = this.json;\n\n\t\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\t\tvar componentSize;\n\n\t\t\tif ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\tcomponentSize = 1;\n\n\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\tcomponentSize = 2;\n\n\t\t\t} else {\n\n\t\t\t\tcomponentSize = 4;\n\n\t\t\t}\n\n\t\t\tvar byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );\n\t\t\tvar dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\t\tvar offset = 0;\n\n\t\t\tfor ( var i = start; i < start + count; i ++ ) {\n\n\t\t\t\tfor ( var a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\tvar value;\n\n\t\t\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += componentSize;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar bufferViewDef = {\n\n\t\t\t\tbuffer: this.processBuffer( dataView.buffer ),\n\t\t\t\tbyteOffset: this.byteOffset,\n\t\t\t\tbyteLength: byteLength\n\n\t\t\t};\n\n\t\t\tif ( target !== undefined ) bufferViewDef.target = target;\n\n\t\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t\t// Only define byteStride for vertex attributes.\n\t\t\t\tbufferViewDef.byteStride = attribute.itemSize * componentSize;\n\n\t\t\t}\n\n\t\t\tthis.byteOffset += byteLength;\n\n\t\t\tjson.bufferViews.push( bufferViewDef );\n\n\t\t\t// @TODO Merge bufferViews where possible.\n\t\t\tvar output = {\n\n\t\t\t\tid: json.bufferViews.length - 1,\n\t\t\t\tbyteLength: 0\n\n\t\t\t};\n\n\t\t\treturn output;\n\n\t\t},\n\n\t\t/**\n\t\t * Process and generate a BufferView from an image Blob.\n\t\t * @param {Blob} blob\n\t\t * @return {Promise<Integer>}\n\t\t */\n\t\tprocessBufferViewImage: function ( blob ) {\n\n\t\t\tvar writer = this;\n\t\t\tvar json = writer.json;\n\n\t\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\treader.readAsArrayBuffer( blob );\n\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\tvar buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\t\tvar bufferViewDef = {\n\t\t\t\t\t\tbuffer: writer.processBuffer( buffer ),\n\t\t\t\t\t\tbyteOffset: writer.byteOffset,\n\t\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t\t};\n\n\t\t\t\t\twriter.byteOffset += buffer.byteLength;\n\t\t\t\t\tresolve( json.bufferViews.push( bufferViewDef ) - 1 );\n\n\t\t\t\t};\n\n\t\t\t} );\n\n\t\t},\n\n\t\t/**\n\t\t * Process attribute to generate an accessor\n\t\t * @param  {BufferAttribute} attribute Attribute to process\n\t\t * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n\t\t * @param  {Integer} start (Optional)\n\t\t * @param  {Integer} count (Optional)\n\t\t * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n\t\t */\n\t\tprocessAccessor: function ( attribute, geometry, start, count ) {\n\n\t\t\tvar options = this.options;\n\t\t\tvar json = this.json;\n\n\t\t\tvar types = {\n\n\t\t\t\t1: 'SCALAR',\n\t\t\t\t2: 'VEC2',\n\t\t\t\t3: 'VEC3',\n\t\t\t\t4: 'VEC4',\n\t\t\t\t16: 'MAT4'\n\n\t\t\t};\n\n\t\t\tvar componentType;\n\n\t\t\t// Detect the component type of the attribute array (float, uint or ushort)\n\t\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );\n\n\t\t\t}\n\n\t\t\tif ( start === undefined ) start = 0;\n\t\t\tif ( count === undefined ) count = attribute.count;\n\n\t\t\t// @TODO Indexed buffer geometry with drawRange not supported yet\n\t\t\tif ( options.truncateDrawRange && geometry !== undefined && geometry.index === null ) {\n\n\t\t\t\tvar end = start + count;\n\t\t\t\tvar end2 = geometry.drawRange.count === Infinity\n\t\t\t\t\t? attribute.count\n\t\t\t\t\t: geometry.drawRange.start + geometry.drawRange.count;\n\n\t\t\t\tstart = Math.max( start, geometry.drawRange.start );\n\t\t\t\tcount = Math.min( end, end2 ) - start;\n\n\t\t\t\tif ( count < 0 ) count = 0;\n\n\t\t\t}\n\n\t\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\t\tif ( count === 0 ) return null;\n\n\t\t\tvar minMax = getMinMax( attribute, start, count );\n\t\t\tvar bufferViewTarget;\n\n\t\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t\t// animation samplers, target must not be set.\n\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t\t}\n\n\t\t\tvar bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\t\tvar accessorDef = {\n\n\t\t\t\tbufferView: bufferView.id,\n\t\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\t\tcomponentType: componentType,\n\t\t\t\tcount: count,\n\t\t\t\tmax: minMax.max,\n\t\t\t\tmin: minMax.min,\n\t\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t\t};\n\n\t\t\tif ( attribute.normalized === true ) accessorDef.normalized = true;\n\t\t\tif ( ! json.accessors ) json.accessors = [];\n\n\t\t\treturn json.accessors.push( accessorDef ) - 1;\n\n\t\t},\n\n\t\t/**\n\t\t * Process image\n\t\t * @param  {Image} image to process\n\t\t * @param  {Integer} format of the image (e.g. RGBFormat, RGBAFormat etc)\n\t\t * @param  {Boolean} flipY before writing out the image\n\t\t * @return {Integer}     Index of the processed texture in the \"images\" array\n\t\t */\n\t\tprocessImage: function ( image, format, flipY ) {\n\n\t\t\tvar writer = this;\n\t\t\tvar cache = writer.cache;\n\t\t\tvar json = writer.json;\n\t\t\tvar options = writer.options;\n\t\t\tvar pending = writer.pending;\n\n\t\t\tif ( ! cache.images.has( image ) ) cache.images.set( image, {} );\n\n\t\t\tvar cachedImages = cache.images.get( image );\n\t\t\tvar mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\n\t\t\tvar key = mimeType + ':flipY/' + flipY.toString();\n\n\t\t\tif ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];\n\n\t\t\tif ( ! json.images ) json.images = [];\n\n\t\t\tvar imageDef = { mimeType: mimeType };\n\n\t\t\tif ( options.embedImages ) {\n\n\t\t\t\tvar canvas = cachedCanvas = cachedCanvas || document.createElement( 'canvas' );\n\n\t\t\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\t\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\t\t\tvar ctx = canvas.getContext( '2d' );\n\n\t\t\t\tif ( flipY === true ) {\n\n\t\t\t\t\tctx.translate( 0, canvas.height );\n\t\t\t\t\tctx.scale( 1, - 1 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t\t( typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas ) ||\n\t\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {\n\n\t\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( format !== RGBAFormat && format !== RGBFormat ) {\n\n\t\t\t\t\t\tconsole.error( 'GLTFExporter: Only RGB and RGBA formats are supported.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {\n\n\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar data = image.data;\n\n\t\t\t\t\tif ( format === RGBFormat ) {\n\n\t\t\t\t\t\tdata = new Uint8ClampedArray( image.height * image.width * 4 );\n\n\t\t\t\t\t\tfor ( var i = 0, j = 0; i < data.length; i += 4, j += 3 ) {\n\n\t\t\t\t\t\t\tdata[ i + 0 ] = image.data[ j + 0 ];\n\t\t\t\t\t\t\tdata[ i + 1 ] = image.data[ j + 1 ];\n\t\t\t\t\t\t\tdata[ i + 2 ] = image.data[ j + 2 ];\n\t\t\t\t\t\t\tdata[ i + 3 ] = 255;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( options.binary === true ) {\n\n\t\t\t\t\tpending.push( new Promise( function ( resolve ) {\n\n\t\t\t\t\t\tcanvas.toBlob( function ( blob ) {\n\n\t\t\t\t\t\t\twriter.processBufferViewImage( blob ).then( function ( bufferViewIndex ) {\n\n\t\t\t\t\t\t\t\timageDef.bufferView = bufferViewIndex;\n\t\t\t\t\t\t\t\tresolve();\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}, mimeType );\n\n\t\t\t\t\t} ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\timageDef.uri = canvas.toDataURL( mimeType );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\timageDef.uri = image.src;\n\n\t\t\t}\n\n\t\t\tvar index = json.images.push( imageDef ) - 1;\n\t\t\tcachedImages[ key ] = index;\n\t\t\treturn index;\n\n\t\t},\n\n\t\t/**\n\t\t * Process sampler\n\t\t * @param  {Texture} map Texture to process\n\t\t * @return {Integer}     Index of the processed texture in the \"samplers\" array\n\t\t */\n\t\tprocessSampler: function ( map ) {\n\n\t\t\tvar json = this.json;\n\n\t\t\tif ( ! json.samplers ) json.samplers = [];\n\n\t\t\tvar samplerDef = {\n\t\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\t\t\t};\n\n\t\t\treturn json.samplers.push( samplerDef ) - 1;\n\n\t\t},\n\n\t\t/**\n\t\t * Process texture\n\t\t * @param  {Texture} map Map to process\n\t\t * @return {Integer} Index of the processed texture in the \"textures\" array\n\t\t */\n\t\tprocessTexture: function ( map ) {\n\n\t\t\tvar cache = this.cache;\n\t\t\tvar json = this.json;\n\n\t\t\tif ( cache.textures.has( map ) ) return cache.textures.get( map );\n\n\t\t\tif ( ! json.textures ) json.textures = [];\n\n\t\t\tvar textureDef = {\n\t\t\t\tsampler: this.processSampler( map ),\n\t\t\t\tsource: this.processImage( map.image, map.format, map.flipY )\n\t\t\t};\n\n\t\t\tif ( map.name ) textureDef.name = map.name;\n\n\t\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\t\text.writeTexture && ext.writeTexture( map, textureDef );\n\n\t\t\t} );\n\n\t\t\tvar index = json.textures.push( textureDef ) - 1;\n\t\t\tcache.textures.set( map, index );\n\t\t\treturn index;\n\n\t\t},\n\n\t\t/**\n\t\t * Process material\n\t\t * @param  {THREE.Material} material Material to process\n\t\t * @return {Integer|null} Index of the processed material in the \"materials\" array\n\t\t */\n\t\tprocessMaterial: function ( material ) {\n\n\t\t\tvar cache = this.cache;\n\t\t\tvar json = this.json;\n\n\t\t\tif ( cache.materials.has( material ) ) return cache.materials.get( material );\n\n\t\t\tif ( material.isShaderMaterial ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( ! json.materials ) json.materials = [];\n\n\t\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\t\tvar materialDef = {\tpbrMetallicRoughness: {} };\n\n\t\t\tif ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t\t}\n\n\t\t\t// pbrMetallicRoughness.baseColorFactor\n\t\t\tvar color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t\t}\n\n\t\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t\t} else {\n\n\t\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n\t\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n\n\t\t\t}\n\n\t\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\t\tif ( material.metalnessMap === material.roughnessMap ) {\n\n\t\t\t\t\tvar metalRoughMapDef = { index: this.processTexture( material.metalnessMap ) };\n\t\t\t\t\tthis.applyTextureTransform( metalRoughMapDef, material.metalnessMap );\n\t\t\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\t\t\tif ( material.map ) {\n\n\t\t\t\tvar baseColorMapDef = { index: this.processTexture( material.map ) };\n\t\t\t\tthis.applyTextureTransform( baseColorMapDef, material.map );\n\t\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t\t}\n\n\t\t\tif ( material.emissive ) {\n\n\t\t\t\t// emissiveFactor\n\t\t\t\tvar emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity ).toArray();\n\n\t\t\t\tif ( ! equalArray( emissive, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\t\tmaterialDef.emissiveFactor = emissive;\n\n\t\t\t\t}\n\n\t\t\t\t// emissiveTexture\n\t\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\t\tvar emissiveMapDef = { index: this.processTexture( material.emissiveMap ) };\n\t\t\t\t\tthis.applyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\t\tmaterialDef.emissiveTexture = emissiveMapDef;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normalTexture\n\t\t\tif ( material.normalMap ) {\n\n\t\t\t\tvar normalMapDef = { index: this.processTexture( material.normalMap ) };\n\n\t\t\t\tif ( material.normalScale && material.normalScale.x !== - 1 ) {\n\n\t\t\t\t\tif ( material.normalScale.x !== material.normalScale.y ) {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t\t}\n\n\t\t\t\tthis.applyTextureTransform( normalMapDef, material.normalMap );\n\t\t\t\tmaterialDef.normalTexture = normalMapDef;\n\n\t\t\t}\n\n\t\t\t// occlusionTexture\n\t\t\tif ( material.aoMap ) {\n\n\t\t\t\tvar occlusionMapDef = {\n\t\t\t\t\tindex: this.processTexture( material.aoMap ),\n\t\t\t\t\ttexCoord: 1\n\t\t\t\t};\n\n\t\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t\t}\n\n\t\t\t\tthis.applyTextureTransform( occlusionMapDef, material.aoMap );\n\t\t\t\tmaterialDef.occlusionTexture = occlusionMapDef;\n\n\t\t\t}\n\n\t\t\t// alphaMode\n\t\t\tif ( material.transparent ) {\n\n\t\t\t\tmaterialDef.alphaMode = 'BLEND';\n\n\t\t\t} else {\n\n\t\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\t\tmaterialDef.alphaMode = 'MASK';\n\t\t\t\t\tmaterialDef.alphaCutoff = material.alphaTest;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// doubleSided\n\t\t\tif ( material.side === DoubleSide ) materialDef.doubleSided = true;\n\t\t\tif ( material.name !== '' ) materialDef.name = material.name;\n\n\t\t\tthis.serializeUserData( material, materialDef );\n\n\t\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\t\text.writeMaterial && ext.writeMaterial( material, materialDef );\n\n\t\t\t} );\n\n\t\t\tvar index = json.materials.push( materialDef ) - 1;\n\t\t\tcache.materials.set( material, index );\n\t\t\treturn index;\n\n\t\t},\n\n\t\t/**\n\t\t * Process mesh\n\t\t * @param  {THREE.Mesh} mesh Mesh to process\n\t\t * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n\t\t */\n\t\tprocessMesh: function ( mesh ) {\n\n\t\t\tvar cache = this.cache;\n\t\t\tvar json = this.json;\n\n\t\t\tvar meshCacheKeyParts = [ mesh.geometry.uuid ];\n\n\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\tfor ( var i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t\t}\n\n\t\t\tvar meshCacheKey = meshCacheKeyParts.join( ':' );\n\n\t\t\tif ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );\n\n\t\t\tvar geometry = mesh.geometry;\n\t\t\tvar mode;\n\n\t\t\t// Use the correct mode\n\t\t\tif ( mesh.isLineSegments ) {\n\n\t\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t\t} else if ( mesh.isLine ) {\n\n\t\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t\t} else if ( mesh.isPoints ) {\n\n\t\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t\t} else {\n\n\t\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t\t}\n\n\t\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t\t}\n\n\t\t\tvar meshDef = {};\n\t\t\tvar attributes = {};\n\t\t\tvar primitives = [];\n\t\t\tvar targets = [];\n\n\t\t\t// Conversion between attributes names in threejs and gltf spec\n\t\t\tvar nameConversion = {\n\t\t\t\tuv: 'TEXCOORD_0',\n\t\t\t\tuv2: 'TEXCOORD_1',\n\t\t\t\tcolor: 'COLOR_0',\n\t\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\t\tskinIndex: 'JOINTS_0'\n\t\t\t};\n\n\t\t\tvar originalNormal = geometry.getAttribute( 'normal' );\n\n\t\t\tif ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\t\tgeometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t\t}\n\n\t\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t\t// For every attribute create an accessor\n\t\t\tvar modifiedAttribute = null;\n\n\t\t\tfor ( var attributeName in geometry.attributes ) {\n\n\t\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\t\tif ( attributeName.substr( 0, 5 ) === 'morph' ) continue;\n\n\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\n\t\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\t\tvar validVertexAttributes =\n\t\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\n\t\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;\n\n\t\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\n\n\t\t\t\t\tattributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\t\t\t\tmodifiedAttribute = null;\n\t\t\t\tvar array = attribute.array;\n\n\t\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\t\tmodifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t\t}\n\n\t\t\t\tvar accessor = this.processAccessor( modifiedAttribute || attribute, geometry );\n\n\t\t\t\tif ( accessor !== null ) {\n\n\t\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\t\tcache.attributes.set( this.getUID( attribute ), accessor );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t\t// Skip if no exportable attributes found\n\t\t\tif ( Object.keys( attributes ).length === 0 ) return null;\n\n\t\t\t// Morph targets\n\t\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\t\tvar weights = [];\n\t\t\t\tvar targetNames = [];\n\t\t\t\tvar reverseDictionary = {};\n\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\t\tfor ( var key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\t\tvar target = {};\n\t\t\t\t\tvar warned = false;\n\n\t\t\t\t\tfor ( var attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\t\tvar gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\t\tvar baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\n\n\t\t\t\t\t\t\ttarget[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute ) );\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\t\tvar relativeAttribute = attribute.clone();\n\n\t\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\t\tfor ( var j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\trelativeAttribute.setXYZ(\n\t\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\t\tattribute.getX( j ) - baseAttribute.getX( j ),\n\t\t\t\t\t\t\t\t\tattribute.getY( j ) - baseAttribute.getY( j ),\n\t\t\t\t\t\t\t\t\tattribute.getZ( j ) - baseAttribute.getZ( j )\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttarget[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );\n\t\t\t\t\t\tcache.attributes.set( this.getUID( baseAttribute ), target[ gltfAttributeName ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttargets.push( target );\n\n\t\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\n\t\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\tmeshDef.weights = weights;\n\n\t\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\t\tmeshDef.extras = {};\n\t\t\t\t\tmeshDef.extras.targetNames = targetNames;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar isMultiMaterial = Array.isArray( mesh.material );\n\n\t\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\t\tvar materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\t\tvar groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\t\tfor ( var i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tvar primitive = {\n\t\t\t\t\tmode: mode,\n\t\t\t\t\tattributes: attributes,\n\t\t\t\t};\n\n\t\t\t\tthis.serializeUserData( geometry, primitive );\n\n\t\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\t\tvar cacheKey = this.getUID( geometry.index );\n\n\t\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( cache.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\t\tprimitive.indices = cache.attributes.get( cacheKey );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tprimitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\t\tcache.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t\t}\n\n\t\t\t\tvar material = this.processMaterial( materials[ groups[ i ].materialIndex ] );\n\n\t\t\t\tif ( material !== null ) primitive.material = material;\n\n\t\t\t\tprimitives.push( primitive );\n\n\t\t\t}\n\n\t\t\tmeshDef.primitives = primitives;\n\n\t\t\tif ( ! json.meshes ) json.meshes = [];\n\n\t\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\t\text.writeMesh && ext.writeMesh( mesh, meshDef );\n\n\t\t\t} );\n\n\t\t\tvar index = json.meshes.push( meshDef ) - 1;\n\t\t\tcache.meshes.set( meshCacheKey, index );\n\t\t\treturn index;\n\n\t\t},\n\n\t\t/**\n\t\t * Process camera\n\t\t * @param  {THREE.Camera} camera Camera to process\n\t\t * @return {Integer}      Index of the processed mesh in the \"camera\" array\n\t\t */\n\t\tprocessCamera: function ( camera ) {\n\n\t\t\tvar json = this.json;\n\n\t\t\tif ( ! json.cameras ) json.cameras = [];\n\n\t\t\tvar isOrtho = camera.isOrthographicCamera;\n\n\t\t\tvar cameraDef = {\n\t\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\t\t\t};\n\n\t\t\tif ( isOrtho ) {\n\n\t\t\t\tcameraDef.orthographic = {\n\t\t\t\t\txmag: camera.right * 2,\n\t\t\t\t\tymag: camera.top * 2,\n\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tcameraDef.perspective = {\n\t\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\t\tyfov: MathUtils.degToRad( camera.fov ),\n\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// Question: Is saving \"type\" as name intentional?\n\t\t\tif ( camera.name !== '' ) cameraDef.name = camera.type;\n\n\t\t\treturn json.cameras.push( cameraDef ) - 1;\n\n\t\t},\n\n\t\t/**\n\t\t * Creates glTF animation entry from AnimationClip object.\n\t\t *\n\t\t * Status:\n\t\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t\t *\n\t\t * @param {THREE.AnimationClip} clip\n\t\t * @param {THREE.Object3D} root\n\t\t * @return {number|null}\n\t\t */\n\t\tprocessAnimation: function ( clip, root ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar nodeMap = this.nodeMap;\n\n\t\t\tif ( ! json.animations ) json.animations = [];\n\n\t\t\tclip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\t\tvar tracks = clip.tracks;\n\t\t\tvar channels = [];\n\t\t\tvar samplers = [];\n\n\t\t\tfor ( var i = 0; i < tracks.length; ++ i ) {\n\n\t\t\t\tvar track = tracks[ i ];\n\t\t\t\tvar trackBinding = PropertyBinding.parseTrackName( track.name );\n\t\t\t\tvar trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\t\tvar trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t\tvar inputItemSize = 1;\n\t\t\t\tvar outputItemSize = track.values.length / track.times.length;\n\n\t\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t\t}\n\n\t\t\t\tvar interpolation;\n\n\t\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t\t// valid value from .getInterpolation().\n\t\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\t\toutputItemSize /= 3;\n\n\t\t\t\t} else if ( track.getInterpolation() === InterpolateDiscrete ) {\n\n\t\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t\t}\n\n\t\t\t\tsamplers.push( {\n\t\t\t\t\tinput: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\t\toutput: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\t\tinterpolation: interpolation\n\t\t\t\t} );\n\n\t\t\t\tchannels.push( {\n\t\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\t\ttarget: {\n\t\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\t\tpath: trackProperty\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tjson.animations.push( {\n\t\t\t\tname: clip.name || 'clip_' + json.animations.length,\n\t\t\t\tsamplers: samplers,\n\t\t\t\tchannels: channels\n\t\t\t} );\n\n\t\t\treturn json.animations.length - 1;\n\n\t\t},\n\n\t\t/**\n\t\t * @param {THREE.Object3D} object\n\t\t * @return {number|null}\n\t\t */\n\t\t processSkin: function ( object ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar nodeMap = this.nodeMap;\n\n\t\t\tvar node = json.nodes[ nodeMap.get( object ) ];\n\n\t\t\tvar skeleton = object.skeleton;\n\n\t\t\tif ( skeleton === undefined ) return null;\n\n\t\t\tvar rootJoint = object.skeleton.bones[ 0 ];\n\n\t\t\tif ( rootJoint === undefined ) return null;\n\n\t\t\tvar joints = [];\n\t\t\tvar inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\t\t\tvar temporaryBoneInverse = new Matrix4();\n\n\t\t\tfor ( var i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\t\t\t\ttemporaryBoneInverse.copy( skeleton.boneInverses[ i ] );\n\t\t\t\ttemporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );\n\n\t\t\t}\n\n\t\t\tif ( json.skins === undefined ) json.skins = [];\n\n\t\t\tjson.skins.push( {\n\t\t\t\tinverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\t\tjoints: joints,\n\t\t\t\tskeleton: nodeMap.get( rootJoint )\n\t\t\t} );\n\n\t\t\tvar skinIndex = node.skin = json.skins.length - 1;\n\n\t\t\treturn skinIndex;\n\n\t\t},\n\n\t\t/**\n\t\t * Process Object3D node\n\t\t * @param  {THREE.Object3D} node Object3D to processNode\n\t\t * @return {Integer} Index of the node in the nodes list\n\t\t */\n\t\tprocessNode: function ( object ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar options = this.options;\n\t\t\tvar nodeMap = this.nodeMap;\n\n\t\t\tif ( ! json.nodes ) json.nodes = [];\n\n\t\t\tvar nodeDef = {};\n\n\t\t\tif ( options.trs ) {\n\n\t\t\t\tvar rotation = object.quaternion.toArray();\n\t\t\t\tvar position = object.position.toArray();\n\t\t\t\tvar scale = object.scale.toArray();\n\n\t\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\t\tnodeDef.rotation = rotation;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\t\tnodeDef.translation = position;\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\t\tnodeDef.scale = scale;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\t\tobject.updateMatrix();\n\n\t\t\t\t}\n\n\t\t\t\tif ( isIdentityMatrix( object.matrix ) === false ) {\n\n\t\t\t\t\tnodeDef.matrix = object.matrix.elements;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\t\tif ( object.name !== '' ) nodeDef.name = String( object.name );\n\n\t\t\tthis.serializeUserData( object, nodeDef );\n\n\t\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\t\tvar meshIndex = this.processMesh( object );\n\n\t\t\t\tif ( meshIndex !== null ) nodeDef.mesh = meshIndex;\n\n\t\t\t} else if ( object.isCamera ) {\n\n\t\t\t\tnodeDef.camera = this.processCamera( object );\n\n\t\t\t}\n\n\t\t\tif ( object.isSkinnedMesh ) this.skins.push( object );\n\n\t\t\tif ( object.children.length > 0 ) {\n\n\t\t\t\tvar children = [];\n\n\t\t\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\t\tvar child = object.children[ i ];\n\n\t\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\t\tvar nodeIndex = this.processNode( child );\n\n\t\t\t\t\t\tif ( nodeIndex !== null ) children.push( nodeIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( children.length > 0 ) nodeDef.children = children;\n\n\t\t\t}\n\n\t\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\t\text.writeNode && ext.writeNode( object, nodeDef );\n\n\t\t\t} );\n\n\t\t\tvar nodeIndex = json.nodes.push( nodeDef ) - 1;\n\t\t\tnodeMap.set( object, nodeIndex );\n\t\t\treturn nodeIndex;\n\n\t\t},\n\n\t\t/**\n\t\t * Process Scene\n\t\t * @param  {Scene} node Scene to process\n\t\t */\n\t\tprocessScene: function ( scene ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar options = this.options;\n\n\t\t\tif ( ! json.scenes ) {\n\n\t\t\t\tjson.scenes = [];\n\t\t\t\tjson.scene = 0;\n\n\t\t\t}\n\n\t\t\tvar sceneDef = {};\n\n\t\t\tif ( scene.name !== '' ) sceneDef.name = scene.name;\n\n\t\t\tjson.scenes.push( sceneDef );\n\n\t\t\tvar nodes = [];\n\n\t\t\tfor ( var i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\t\tvar child = scene.children[ i ];\n\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\tvar nodeIndex = this.processNode( child );\n\n\t\t\t\t\tif ( nodeIndex !== null ) nodes.push( nodeIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( nodes.length > 0 ) sceneDef.nodes = nodes;\n\n\t\t\tthis.serializeUserData( scene, sceneDef );\n\n\t\t},\n\n\t\t/**\n\t\t * Creates a Scene to hold a list of objects and parse it\n\t\t * @param  {Array} objects List of objects to process\n\t\t */\n\t\tprocessObjects: function ( objects ) {\n\n\t\t\tvar scene = new Scene();\n\t\t\tscene.name = 'AuxScene';\n\n\t\t\tfor ( var i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\t\tscene.children.push( objects[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.processScene( scene );\n\n\t\t},\n\n\t\t/**\n\t\t * @param {THREE.Object3D|Array<THREE.Object3D>} input\n\t\t */\n\t\tprocessInput: function ( input ) {\n\n\t\t\tvar options = this.options;\n\n\t\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\t\text.beforeParse && ext.beforeParse( input );\n\n\t\t\t} );\n\n\t\t\tvar objectsWithoutScene = [];\n\n\t\t\tfor ( var i = 0; i < input.length; i ++ ) {\n\n\t\t\t\tif ( input[ i ] instanceof Scene ) {\n\n\t\t\t\t\tthis.processScene( input[ i ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );\n\n\t\t\tfor ( var i = 0; i < this.skins.length; ++ i ) {\n\n\t\t\t\tthis.processSkin( this.skins[ i ] );\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\t\tthis.processAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t\t}\n\n\t\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\t\text.afterParse && ext.afterParse( input );\n\n\t\t\t} );\n\n\t\t},\n\n\t\t_invokeAll: function ( func ) {\n\n\t\t\tfor ( var i = 0, il = this.plugins.length; i < il; i ++ ) {\n\n\t\t\t\tfunc( this.plugins[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Punctual Lights Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\t */\n\tfunction GLTFLightExtension( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_lights_punctual';\n\n\t}\n\n\tGLTFLightExtension.prototype = {\n\n\t\tconstructor: GLTFLightExtension,\n\n\t\twriteNode: function ( light, nodeDef ) {\n\n\t\t\tif ( ! light.isLight ) return;\n\n\t\t\tif ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar writer = this.writer;\n\t\t\tvar json = writer.json;\n\t\t\tvar extensionsUsed = writer.extensionsUsed;\n\n\t\t\tvar lightDef = {};\n\n\t\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\t\tlightDef.color = light.color.toArray();\n\n\t\t\tlightDef.intensity = light.intensity;\n\n\t\t\tif ( light.isDirectionalLight ) {\n\n\t\t\t\tlightDef.type = 'directional';\n\n\t\t\t} else if ( light.isPointLight ) {\n\n\t\t\t\tlightDef.type = 'point';\n\n\t\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\t} else if ( light.isSpotLight ) {\n\n\t\t\t\tlightDef.type = 'spot';\n\n\t\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\t\tlightDef.spot = {};\n\t\t\t\tlightDef.spot.innerConeAngle = ( light.penumbra - 1.0 ) * light.angle * - 1.0;\n\t\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t\t}\n\n\t\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t\t}\n\n\t\t\tif ( light.target\n\t\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t\t|| light.target.position.x !== 0\n\t\t\t\t\t|| light.target.position.y !== 0\n\t\t\t\t\t|| light.target.position.z !== - 1 ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t\t}\n\n\t\t\tif ( ! extensionsUsed[ this.name ] ) {\n\n\t\t\t\tjson.extensions = json.extensions || {};\n\t\t\t\tjson.extensions[ this.name ] = { lights: [] };\n\t\t\t\textensionsUsed[ this.name ] = true;\n\n\t\t\t}\n\n\t\t\tvar lights = json.extensions[ this.name ].lights;\n\t\t\tlights.push( lightDef );\n\n\t\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\t\tnodeDef.extensions[ this.name ] = { light: lights.length - 1 };\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Unlit Materials Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\t */\n\tfunction GLTFMaterialsUnlitExtension( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_unlit';\n\n\t}\n\n\tGLTFMaterialsUnlitExtension.prototype = {\n\n\t\tconstructor: GLTFMaterialsUnlitExtension,\n\n\t\twriteMaterial: function ( material, materialDef ) {\n\n\t\t\tif ( ! material.isMeshBasicMaterial ) return;\n\n\t\t\tvar writer = this.writer;\n\t\t\tvar extensionsUsed = writer.extensionsUsed;\n\n\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\t\tmaterialDef.extensions[ this.name ] = {};\n\n\t\t\textensionsUsed[ this.name ] = true;\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Specular-Glossiness Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n\t */\n\tfunction GLTFMaterialsPBRSpecularGlossiness( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_pbrSpecularGlossiness';\n\n\t}\n\n\tGLTFMaterialsPBRSpecularGlossiness.prototype = {\n\n\t\tconstructor: GLTFMaterialsPBRSpecularGlossiness,\n\n\t\twriteMaterial: function ( material, materialDef ) {\n\n\t\t\tif ( ! material.isGLTFSpecularGlossinessMaterial ) return;\n\n\t\t\tvar writer = this.writer;\n\t\t\tvar extensionsUsed = writer.extensionsUsed;\n\n\t\t\tvar extensionDef = {};\n\n\t\t\tif ( materialDef.pbrMetallicRoughness.baseColorFactor ) {\n\n\t\t\t\textensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n\n\t\t\t}\n\n\t\t\tvar specularFactor = [ 1, 1, 1 ];\n\t\t\tmaterial.specular.toArray( specularFactor, 0 );\n\t\t\textensionDef.specularFactor = specularFactor;\n\t\t\textensionDef.glossinessFactor = material.glossiness;\n\n\t\t\tif ( materialDef.pbrMetallicRoughness.baseColorTexture ) {\n\n\t\t\t\textensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n\n\t\t\t}\n\n\t\t\tif ( material.specularMap ) {\n\n\t\t\t\tvar specularMapDef = { index: writer.processTexture( material.specularMap ) };\n\t\t\t\twriter.applyTextureTransform( specularMapDef, material.specularMap );\n\t\t\t\textensionDef.specularGlossinessTexture = specularMapDef;\n\n\t\t\t}\n\n\t\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\t\t\textensionsUsed[ this.name ] = true;\n\n\t\t}\n\n\t};\n\n\t/**\n\t * Static utility functions\n\t */\n\tGLTFExporter.Utils = {\n\n\t\tinsertKeyframe: function ( track, time ) {\n\n\t\t\tvar tolerance = 0.001; // 1ms\n\t\t\tvar valueSize = track.getValueSize();\n\n\t\t\tvar times = new track.TimeBufferType( track.times.length + 1 );\n\t\t\tvar values = new track.ValueBufferType( track.values.length + valueSize );\n\t\t\tvar interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\t\tvar index;\n\n\t\t\tif ( track.times.length === 0 ) {\n\n\t\t\t\ttimes[ 0 ] = time;\n\n\t\t\t\tfor ( var i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tindex = 0;\n\n\t\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\t\ttimes[ 0 ] = time;\n\t\t\t\ttimes.set( track.times, 1 );\n\n\t\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\t\tindex = 0;\n\n\t\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\t\treturn track.times.length - 1;\n\n\t\t\t\t}\n\n\t\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\t\ttimes.set( track.times, 0 );\n\n\t\t\t\tvalues.set( track.values, 0 );\n\t\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\t\tindex = times.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\tfor ( var i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttrack.times = times;\n\t\t\ttrack.values = values;\n\n\t\t\treturn index;\n\n\t\t},\n\n\t\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\t\tvar tracks = [];\n\t\t\tvar mergedTracks = {};\n\t\t\tvar sourceTracks = clip.tracks;\n\n\t\t\tfor ( var i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\t\tvar sourceTrack = sourceTracks[ i ];\n\t\t\t\tvar sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\t\tvar sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t\t// affect all targets already.\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\t\tsourceTrack.setInterpolation( InterpolateLinear );\n\n\t\t\t\t}\n\n\t\t\t\tvar targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\t\tvar targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t\t}\n\n\t\t\t\tvar mergedTrack;\n\n\t\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\t\tvar values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\t\tfor ( var j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// We need to take into consideration the intended target node\n\t\t\t\t\t// of our original un-merged morphTarget animation.\n\t\t\t\t\tmergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';\n\t\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tvar sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t\t// interpolated) value from the source track.\n\t\t\t\tfor ( var j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t\t}\n\n\t\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\t\tfor ( var j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvar keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tclip.tracks = tracks;\n\n\t\t\treturn clip;\n\n\t\t}\n\n\t};\n\n\treturn GLTFExporter;\n\n} )();\n\nexport { GLTFExporter };\n"],"sourceRoot":""}