{"version":3,"sources":["components/viewers/AniViewer.js","components/viewers/DragonViewer.js"],"names":["AniViewer","afterMainModelLoad","saveMainModelInitState","addAnimation","afterMainModelUpdate","updateModel","prev","current","a","updateMainModel","model","updateAnimation","animation","otherUpdate","capture","enable","captureAnimation","models","main","initPos","position","clone","initRot","rotation","resetFace","props","eyeIdx","mouthIdx","beforeAddAni","aniCode","code","timeScale","disableInput","mainModel","aniList","analyzeChainCode","nAni","length","mixer","THREE","_aniIdx","addEventListener","playNextAni","aniSettings","loadAnimations","animations","aniIdx","enableInput","removeAnimation","stopAllAction","copy","mediaRecorder","stop","toggleCapture","newIdx","chunks","videoStream","canvas","captureStream","codec","MediaRecorder","mimeType","ondataavailable","event","push","data","onstop","superBuffer","Blob","type","url","URL","createObjectURL","document","createElement","style","display","href","download","body","appendChild","click","window","revokeObjectURL","removeChild","beforeCaptureAnimation","start","everyAnimate","dt","clock","getDelta","rotateFloor","update","faceChanges","time","faceChangeTime","shift","this","ani","action","clipAction","currentAniSettings","repetitions","currentClipDuration","duration","setLoop","clampWhenFinished","getFaceChangesArray","map","change","setTime","play","BasicViewer","DragonViewer","initNewModel","initFace","updateFace","eyes","getDragonEye","forEach","eye","frustumCulled","mouths","getDragonMouth","mouth","_eyeIdx","_mouthIdx","oldIdx","regex","mesh","name","id","exec","visible","parseInt"],"mappings":"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","file":"static/js/54.c50fa581.chunk.js","sourcesContent":["/* \r\n################################################\r\n# Extension of Base Viewer that adds:\r\n#    - Animation\r\n#    - Recording Animation\r\n################################################  \r\n*/\r\n\r\nimport BasicViewer from \"./BasicViewer\";\r\n\r\nimport * as THREE from \"three\";\r\nimport {\r\n    analyzeChainCode,\r\n    loadAnimations,\r\n    getFaceChangesArray,\r\n} from \"helpers/viewerHelpers\";\r\n\r\nexport class AniViewer extends BasicViewer {\r\n    afterMainModelLoad = () => {\r\n        this.saveMainModelInitState();\r\n        this.addAnimation();\r\n    };\r\n\r\n    afterMainModelUpdate = () => {\r\n        this.saveMainModelInitState();\r\n        this.addAnimation();\r\n    };\r\n\r\n    /**\r\n     * @param {ViewerProps} prev\r\n     * @param {ViewerProps} current\r\n     */\r\n    updateModel = async (prev, current) => {\r\n        await this.updateMainModel(prev.model, current.model);\r\n        this.updateAnimation(prev.animation, current.animation);\r\n    };\r\n\r\n    /**\r\n     * @param {ViewerProps} prev\r\n     * @param {ViewerProps} current\r\n     */\r\n    otherUpdate = (prev, current) => {\r\n        // Capture\r\n        if (current.capture.enable && !prev.capture.enable) {\r\n            this.captureAnimation();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * save main model's initial position and rotation\r\n     */\r\n    saveMainModelInitState = () => {\r\n        const model = this.models.main;\r\n        model.initPos = model.position.clone();\r\n        model.initRot = model.rotation.clone();\r\n    };\r\n\r\n    /**\r\n     * play animation stored in this.animations[newIdx]\r\n     * @param {number} newIdx\r\n     */\r\n    set aniIdx(newIdx) {\r\n        this._aniIdx = newIdx;\r\n\r\n        const { mixer } = this;\r\n        mixer.stopAllAction();\r\n\r\n        const ani = this.animations[newIdx];\r\n        const action = mixer.clipAction(ani);\r\n        const currentAniSettings = this.aniSettings[newIdx];\r\n        const { timeScale, repetitions, faceChanges } = currentAniSettings;\r\n        const currentClipDuration = ani.duration;\r\n\r\n        action.setLoop(THREE.LoopRepeat, repetitions);\r\n        action.clampWhenFinished = true;\r\n        action.timeScale = timeScale;\r\n        action.time = 0;\r\n\r\n        this.faceChanges = getFaceChangesArray(faceChanges, repetitions);\r\n        this.faceChangeTime = this.faceChanges.map(\r\n            change => (currentClipDuration * change.time) / 100\r\n        );\r\n\r\n        mixer.setTime(0);\r\n        action.play();\r\n    }\r\n\r\n    /**\r\n     * reset model's face to the ones specified in model setting\r\n     */\r\n    resetFace = () => {\r\n        const { eyeIdx, mouthIdx } = this.props.model;\r\n        this.eyeIdx = eyeIdx;\r\n        this.mouthIdx = mouthIdx;\r\n    };\r\n\r\n    /**\r\n     * @param {number} newIdx\r\n     */\r\n    set eyeIdx(newIdx) {}\r\n\r\n    /**\r\n     * @param {number} newIdx\r\n     */\r\n    set mouthIdx(newIdx) {}\r\n\r\n    /**\r\n     * called before animation is attached\r\n     */\r\n    beforeAddAni = () => {\r\n        this.resetFace();\r\n    };\r\n\r\n    /**\r\n     * load and attach animations\r\n     */\r\n    addAnimation = async () => {\r\n        this.beforeAddAni();\r\n\r\n        const { code: aniCode, timeScale } = this.props.animation;\r\n        if (!aniCode) return;\r\n\r\n        this.disableInput();\r\n\r\n        const mainModel = this.models.main;\r\n        const aniList = analyzeChainCode(aniCode);\r\n        /**\r\n         * number of currently loaded animations\r\n         */\r\n        this.nAni = aniList.length;\r\n\r\n        mainModel.mixer = new THREE.AnimationMixer(mainModel);\r\n        /**\r\n         * @type {THREE.AnimationMixer}\r\n         */\r\n        this.mixer = mainModel.mixer;\r\n\r\n        this._aniIdx = 0;\r\n        mainModel.mixer.timeScale = timeScale; // Global timeScale\r\n        mainModel.mixer.addEventListener(\"finished\", this.playNextAni);\r\n        this.aniSettings = aniList;\r\n\r\n        /**\r\n         * @type {THREE.AnimationClip[]}\r\n         */\r\n        this.animations = await loadAnimations(aniList);\r\n\r\n        // play first animation\r\n        this.aniIdx = 0;\r\n        this.enableInput();\r\n    };\r\n\r\n    /**\r\n     * remove all loaded animation\r\n     */\r\n    removeAnimation = () => {\r\n        const mainModel = this.models.main;\r\n        mainModel.mixer?.stopAllAction?.();\r\n\r\n        // Reset position and rotation to initial value\r\n        const { initPos, initRot } = mainModel;\r\n        mainModel.position.copy(initPos);\r\n        mainModel.rotation.copy(initRot);\r\n\r\n        this.mixer = null;\r\n        this.animations = [];\r\n        this.aniSettings = [];\r\n    };\r\n\r\n    /**\r\n     * play the next animation stored in this.animations\r\n     */\r\n    playNextAni = () => {\r\n        const { nAni } = this;\r\n        // if capturing and finished recording current chain, stop capturing and set capture flag back to false\r\n        const finishedRecording =\r\n            this.props.capture.enable && this._aniIdx === nAni - 1;\r\n        if (finishedRecording) {\r\n            this.mediaRecorder.stop();\r\n            this.props.toggleCapture();\r\n        }\r\n        const newIdx = (this._aniIdx + 1) % nAni;\r\n        this.aniIdx = newIdx;\r\n    };\r\n\r\n    /**\r\n     * update animation and global time scale\r\n     * @param {ViewerProps[\"animation\"]} prev\r\n     * @param {ViewerProps[\"animation\"]} current\r\n     */\r\n    updateAnimation = (prev, current) => {\r\n        const { code, timeScale } = current;\r\n        if (prev.code !== code) {\r\n            this.removeAnimation();\r\n            this.addAnimation();\r\n            return;\r\n        }\r\n        // Update timeScale if animation not changed\r\n        if (prev.timeScale !== timeScale) {\r\n            this.mixer.timeScale = timeScale;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * capture current animation and save as video\r\n     */\r\n    captureAnimation = () => {\r\n        /**\r\n         * @type {Blob[]}\r\n         */\r\n        this.chunks = [];\r\n        this.videoStream = this.canvas.captureStream(30);\r\n\r\n        if (!this.mediaRecorder) {\r\n            const { codec } = this.props.capture;\r\n            this.mediaRecorder = new MediaRecorder(this.videoStream, {\r\n                mimeType: codec,\r\n            });\r\n            this.mediaRecorder.ondataavailable = event =>\r\n                this.chunks.push(event.data);\r\n            this.mediaRecorder.onstop = () => {\r\n                this.enableInput();\r\n                const superBuffer = new Blob(this.chunks, {\r\n                    type: \"video/webm\",\r\n                });\r\n                const url = URL.createObjectURL(superBuffer);\r\n                const a = document.createElement(\"a\");\r\n                a.style.display = \"none\";\r\n                a.href = url;\r\n                a.download = \"animation.webm\";\r\n                document.body.appendChild(a);\r\n                a.click();\r\n                window.URL.revokeObjectURL(url);\r\n                document.body.removeChild(a);\r\n            };\r\n        }\r\n        this.disableInput(\"Recording\");\r\n        this.beforeCaptureAnimation();\r\n        // play first animation and start capturing\r\n        this.aniIdx = 0;\r\n        this.mediaRecorder.start();\r\n    };\r\n\r\n    /**\r\n     * called before animation capture\r\n     */\r\n    beforeCaptureAnimation = () => void 0;\r\n\r\n    everyAnimate = () => {\r\n        const dt = this.clock.getDelta();\r\n        this.rotateFloor(dt);\r\n        this.mixer?.update(dt);\r\n\r\n        if (this.faceChanges && this.faceChanges.length) {\r\n            const elapsedTime = this.mixer.time;\r\n            const nextFaceChangeTime = this.faceChangeTime[0];\r\n            if (elapsedTime >= nextFaceChangeTime) {\r\n                this.faceChangeTime.shift();\r\n                const { eyeIdx, mouthIdx } = this.faceChanges.shift();\r\n                this.eyeIdx = eyeIdx;\r\n                this.mouthIdx = mouthIdx;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nexport default AniViewer;\r\n","/* \r\n################################################\r\n# Extension of Ani Viewer for dragons that adds:\r\n#    - Eyes and Mouth\r\n################################################  \r\n*/\r\n\r\nimport AniViewer from \"./AniViewer\";\r\n\r\nimport { getDragonEye, getDragonMouth } from \"helpers/viewerHelpers\";\r\n\r\nexport class DragonViewer extends AniViewer {\r\n    constructor(props) {\r\n        super(props);\r\n        this._eyeIdx = this._mouthIdx = 0;\r\n    }\r\n\r\n    initNewModel = () => {\r\n        this.saveMainModelInitState();\r\n        this.initFace();\r\n        this.addAnimation();\r\n    };\r\n\r\n    afterMainModelLoad = () => {\r\n        this.initNewModel();\r\n    };\r\n\r\n    updateModel = async (prev, current) => {\r\n        await this.updateMainModel(prev.model, current.model);\r\n        this.updateFace(current.model);\r\n        this.updateAnimation(prev.animation, current.animation);\r\n    };\r\n\r\n    updateFace = ({ eyeIdx, mouthIdx }) => {\r\n        this.eyeIdx = eyeIdx;\r\n        this.mouthIdx = mouthIdx;\r\n    };\r\n\r\n    afterMainModelUpdate = () => {\r\n        this.initNewModel();\r\n    };\r\n\r\n    initFace = () => {\r\n        const mainModel = this.models.main;\r\n        this.eyes = getDragonEye(mainModel);\r\n        this.eyes.forEach(eye => (eye.frustumCulled = false));\r\n\r\n        this.mouths = getDragonMouth(mainModel);\r\n        this.mouths.forEach(mouth => (mouth.frustumCulled = false));\r\n\r\n        const { eyeIdx, mouthIdx } = this.props.model;\r\n        this.eyeIdx = eyeIdx;\r\n        this.mouthIdx = mouthIdx;\r\n    };\r\n\r\n    /**\r\n     * @param {number} newIdx\r\n     */\r\n    set eyeIdx(newIdx) {\r\n        const oldIdx = this._eyeIdx;\r\n        if (newIdx === oldIdx) return;\r\n\r\n        this._eyeIdx = newIdx;\r\n        const regex = /[0-9]{2}/;\r\n        this.eyes.forEach(mesh => {\r\n            const { name } = mesh;\r\n            const id = regex.exec(name)[0];\r\n            mesh.visible = parseInt(id) === newIdx;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param {number} newIdx\r\n     */\r\n    set mouthIdx(newIdx) {\r\n        const oldIdx = this._mouthIdx;\r\n        if (newIdx === oldIdx) return;\r\n\r\n        this._mouthIdx = newIdx;\r\n        const regex = /[0-9]{2}/;\r\n        this.mouths.forEach(mesh => {\r\n            const { name } = mesh;\r\n            const id = regex.exec(name)[0];\r\n            mesh.visible = parseInt(id) === newIdx;\r\n        });\r\n    }\r\n}\r\n\r\nexport default DragonViewer;\r\n"],"sourceRoot":""}