{"version":3,"sources":["../node_modules/three/examples/jsm/exporters/USDZExporter.js"],"names":["USDZExporter","scene","output","materials","traverse","object","isMesh","material","uuid","define","name","transform","matrix","array","elements","buildMatrixRow","buildMatrix","matrixWorld","buildXform","geometry","attributes","count","position","index","length","Array","fill","join","buildMeshVertexCount","i","push","buildMeshVertexIndices","id","buildVector3Array","normal","attribute","undefined","console","warn","data","buildVector2Array","uv","buildMesh","buildMaterial","buildMaterials","zipSync","strToU8","level","offset","color","r","g","b","metalness","roughness"],"mappings":"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","file":"static/js/64.266ba101.chunk.js","sourcesContent":["import { zipSync, strToU8 } from '../libs/fflate.module.min.js';\n\nclass USDZExporter {\n\n\tparse( scene ) {\n\n\t\tlet output = buildHeader();\n\n\t\tconst materials = {};\n\n\t\tscene.traverse( ( object ) => {\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tmaterials[ object.material.uuid ] = object.material;\n\t\t\t\toutput += buildXform( object, buildMesh( object.geometry, object.material ) );\n\n\t\t\t}\n\n\t\t} );\n\n\t\toutput += buildMaterials( materials );\n\n\t\treturn zipSync( { 'model.usda': strToU8( output ) }, { level: 0 } );\n\n\t}\n\n}\n\n//\n\nfunction buildHeader() {\n\n\treturn `#usda 1.0\n(\n    doc = \"Three.js\"\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n\n`;\n\n}\n\n// Xform\n\nfunction buildXform( object, define ) {\n\n\tconst name = object.name || 'Xform1';\n\tconst transform = buildMatrix( object.matrixWorld );\n\n\treturn `def Xform \"${ name }\"\n{\n    matrix4d xformOp:transform = ${ transform }\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n\n    ${ define }\n}\n\n`;\n\n}\n\nfunction buildMatrix( matrix ) {\n\n\tconst array = matrix.elements;\n\n\treturn `( ${ buildMatrixRow( array, 0 ) }, ${ buildMatrixRow( array, 4 ) }, ${ buildMatrixRow( array, 8 ) }, ${ buildMatrixRow( array, 12 ) } )`;\n\n}\n\nfunction buildMatrixRow( array, offset ) {\n\n\treturn `(${ array[ offset + 0 ] }, ${ array[ offset + 1 ] }, ${ array[ offset + 2 ] }, ${ array[ offset + 3 ] })`;\n\n}\n\n// Mesh\n\nfunction buildMesh( geometry, material ) {\n\n\tconst name = geometry.name || 'Mesh1';\n\tconst attributes = geometry.attributes;\n\tconst count = attributes.position.count;\n\n\treturn `def Mesh \"${ name }\"\n    {\n        int[] faceVertexCounts = [${ buildMeshVertexCount( geometry ) }]\n        int[] faceVertexIndices = [${ buildMeshVertexIndices( geometry ) }]\n        rel material:binding = </_materials/Material_${ material.id }>\n        normal3f[] normals = [${ buildVector3Array( attributes.normal, count )}] (\n            interpolation = \"faceVarying\"\n        )\n        point3f[] points = [${ buildVector3Array( attributes.position, count )}]\n        texCoord2f[] primvars:UVMap = [${ buildVector2Array( attributes.uv, count )}] (\n            interpolation = \"faceVarying\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`;\n\n}\n\nfunction buildMeshVertexCount( geometry ) {\n\n\tconst count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n\n\treturn Array( count / 3 ).fill( 3 ).join( ', ' );\n\n}\n\nfunction buildMeshVertexIndices( geometry ) {\n\n\tif ( geometry.index !== null ) {\n\n\t\treturn geometry.index.array.join( ', ' );\n\n\t}\n\n\tconst array = [];\n\tconst length = geometry.attributes.position.count;\n\n\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\tarray.push( i );\n\n\t}\n\n\treturn array.join( ', ' );\n\n}\n\nfunction buildVector3Array( attribute, count ) {\n\n\tif ( attribute === undefined ) {\n\n\t\tconsole.warn( 'USDZExporter: Normals missing.' );\n\t\treturn Array( count ).fill( '(0, 0, 0)' ).join( ', ' );\n\n\t}\n\n\tconst array = [];\n\tconst data = attribute.array;\n\n\tfor ( let i = 0; i < data.length; i += 3 ) {\n\n\t\tarray.push( `(${ data[ i + 0 ] }, ${ data[ i + 1 ] }, ${ data[ i + 2 ] })` );\n\n\t}\n\n\treturn array.join( ', ' );\n\n}\n\nfunction buildVector2Array( attribute, count ) {\n\n\tif ( attribute === undefined ) {\n\n\t\tconsole.warn( 'USDZExporter: UVs missing.' );\n\t\treturn Array( count ).fill( '(0, 0)' ).join( ', ' );\n\n\t}\n\n\tconst array = [];\n\tconst data = attribute.array;\n\n\tfor ( let i = 0; i < data.length; i += 2 ) {\n\n\t\tarray.push( `(${ data[ i + 0 ] }, ${ data[ i + 1 ] })` );\n\n\t}\n\n\treturn array.join( ', ' );\n\n}\n\n// Materials\n\nfunction buildMaterials( materials ) {\n\n\tconst array = [];\n\n\tfor ( const uuid in materials ) {\n\n\t\tconst material = materials[ uuid ];\n\n\t\tarray.push( buildMaterial( material ) );\n\n\t}\n\n\treturn `def \"_materials\"\n{\n${ array.join( '' ) }\n}\n\n`;\n\n}\n\nfunction buildMaterial( material ) {\n\n\treturn `\n    def Material \"Material_${ material.id }\"\n    {\n        token outputs:surface.connect = </_materials/Material_${ material.id }/previewShader.outputs:surface>\n\n        def Shader \"previewShader\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n            color3f inputs:diffuseColor = ${ buildColor( material.color ) }\n            float inputs:metallic = ${ material.metalness }\n            float inputs:roughness = ${ material.roughness }\n            token outputs:surface\n        }\n    }\n`;\n\n}\n\nfunction buildColor( color ) {\n\n\treturn `(${ color.r }, ${ color.g }, ${ color.b })`;\n\n}\n\nexport { USDZExporter };\n"],"sourceRoot":""}